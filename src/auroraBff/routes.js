const axios = require('axios');
const sharp = require('sharp');
const fs = require('fs');
const crypto = require('crypto');
const { buildRequestContext } = require('./requestContext');
const { buildEnvelope, makeAssistantMessage, makeEvent } = require('./envelope');
const { createStageProfiler } = require('./skinAnalysisProfiling');
const { runSkinDiagnosisV1, summarizeDiagnosisForPolicy, buildSkinAnalysisFromDiagnosisV1 } = require('./skinDiagnosisV1');
const { buildSkinVisionPrompt, buildSkinReportPrompt } = require('./skinLlmPrompts');
const {
  classifyPhotoQuality,
  inferDetectorConfidence,
  shouldCallLlm,
  downgradeSkinAnalysisConfidence,
  humanizeLlmReasons,
} = require('./skinLlmPolicy');
const {
  VisionUnavailabilityReason,
  classifyVisionAvailability,
  classifyVisionProviderFailure,
  executeVisionWithRetry,
  normalizeVisionReason,
  isVisionFailureReason,
  pickPrimaryVisionReason,
  buildVisionPhotoNotice,
} = require('./visionPolicy');
const {
  recordClarificationIdNormalizedEmpty,
  recordCatalogAvailabilityShortCircuit,
  recordRepeatedClarifyField,
  recordClarificationPresent,
  recordClarificationQuestionFiltered,
  recordClarificationAllQuestionsFiltered,
  recordClarificationSchemaInvalid,
  recordClarificationFlowV2Started,
  recordPendingClarificationStep,
  recordPendingClarificationCompleted,
  recordPendingClarificationAbandoned,
  recordClarificationHistorySent,
  recordAuroraChatSkipped,
  recordPendingClarificationUpgraded,
  recordPendingClarificationTruncated,
  recordResumePrefixInjected,
  recordResumePrefixHistoryItems,
  recordResumeResponseMode,
  recordResumePlaintextReaskDetected,
  recordProfileContextMissing,
  recordSessionPatchProfileEmitted,
  recordUpstreamCall,
  recordTemplateApplied,
  recordTemplateFallback,
  observeUpstreamLatency,
  recordVisionDecision,
  recordEnsembleProviderResult,
  recordEnsembleAgreementScore,
  recordVerifyCall,
  recordVerifyFail,
  recordVerifyBudgetGuard,
  recordVerifyCircuitOpen,
  recordVerifyRetry,
  recordVerifyAgreementScore,
  recordVerifyHardCase,
  recordAnalyzeRequest,
  recordGeometrySanitizerTotals,
  recordPhotoModulesCardEmitted,
  recordRegionsEmitted,
  recordModulesIssueCountHistogram,
  recordIngredientActionsEmitted,
  recordProductRecEmitted,
  recordProductRecSuppressed,
  recordClaimsTemplateFallback,
  recordClaimsViolation,
  recordAuroraSkinFlowMetric,
  recordSkinmaskEnabled,
  recordSkinmaskFallback,
  observeSkinmaskInferLatency,
  recordGeometrySanitizerDropReason,
  recordRecoGuardrailViolation,
  recordRecoCandidate,
  recordRecoExplanationAlignment,
  recordRecoGuardrailCircuitOpen,
  recordRecoEmployeeFeedback,
  recordRecoInterleaveClick,
  recordRecoInterleaveWin,
  recordRecoExplorationSlot,
  recordRecoAsyncUpdate,
  setRecoGuardrailRates,
  recordPrelabelRequest,
  recordPrelabelSuccess,
  recordPrelabelInvalidJson,
  recordPrelabelCacheHit,
  observePrelabelGeminiLatency,
  recordSuggestionsGeneratedPerBlock,
  recordQueueItemsServed,
  setPrelabelCacheHitRate,
  setLlmSuggestionOverturnedRate,
  renderVisionMetricsPrometheus,
} = require('./visionMetrics');
const {
  selectTemplate,
  renderAssistantMessage,
  adaptChips,
} = require('./templateSystem');
const { applyReplyTemplates } = require('./replyTemplates');
const { emitAudit } = require('./qualityAudit');
const { buildPhotoModulesCard } = require('./photoModulesV1');
const { inferSkinMaskOnFaceCrop } = require('./skinmaskOnnx');
const { runGeminiShadowVerify } = require('./diagVerify');
const { getDiagRolloutDecision } = require('./diagRollout');
const { assignExperiments } = require('./experiments');
const { sampleHardCase, deleteHardCasesForIdentity } = require('./hardCaseSampler');
const {
  V1ChatRequestSchema,
  UserProfilePatchSchema,
  TrackerLogSchema,
  RoutineSimulateRequestSchema,
  OffersResolveRequestSchema,
  AffiliateOutcomeRequestSchema,
  ProductParseRequestSchema,
  ProductAnalyzeRequestSchema,
  DupeCompareRequestSchema,
  DupeSuggestRequestSchema,
  RecoGenerateRequestSchema,
  PhotosPresignRequestSchema,
  PhotosConfirmRequestSchema,
  SkinAnalysisRequestSchema,
  AuthStartRequestSchema,
  AuthVerifyRequestSchema,
  AuthPasswordSetRequestSchema,
  AuthPasswordLoginRequestSchema,
  RecoEmployeeFeedbackRequestSchema,
  RecoInterleaveClickRequestSchema,
  RecoAsyncUpdatesRequestSchema,
  InternalPrelabelRequestSchema,
  PrelabelSuggestionsQuerySchema,
  LabelQueueQuerySchema,
} = require('./schemas');
const {
  getProfileForIdentity,
  upsertProfileForIdentity,
  upsertSkinLogForIdentity,
  getRecentSkinLogsForIdentity,
  saveLastAnalysisForIdentity,
  deleteIdentityData,
  isCheckinDue,
  resolveNextStateFromSessionPatch,
  upsertIdentityLink,
  migrateGuestDataToUser,
} = require('./memoryStore');
const {
  createOtpChallenge,
  verifyOtpChallenge,
  createSession,
  resolveSessionFromToken,
  revokeSessionToken,
  getBearerToken,
  setUserPassword,
  verifyPasswordForEmail,
} = require('./authStore');
const {
  profileCompleteness,
  looksLikeDiagnosisStart,
  looksLikeRecommendationRequest,
  looksLikeSuitabilityRequest,
  recommendationsAllowed,
  stateChangeAllowed,
  shouldDiagnosisGate,
  buildDiagnosisPrompt,
  buildDiagnosisChips,
  buildPendingClarificationForGate,
  stripRecommendationCards,
  hasUsableArtifactForRecommendations,
} = require('./gating');
const {
  DEFAULT_AGENT_STATE,
  normalizeAgentState,
  validateRequestedTransition,
  inferTextExplicitTransition,
  deriveRequestedTransitionFromAction,
} = require('./agentStateMachine');
const {
  normalizeProductParse,
  normalizeProductAnalysis,
  applyProductAnalysisGapContract,
  enrichProductAnalysisPayload,
  normalizeDupeCompare,
  normalizeRecoGenerate,
} = require('./normalize');
const { validateRecoBlocksResponse } = require('./contracts/recoBlocksValidator');
const { routeCandidates } = require('./competitorBlockRouter');
const { recoBlocks, social_enrich_async, skin_fit_heavy_async } = require('./recoBlocksDag');
const { buildRecoDogfoodConfig } = require('./recoDogfoodConfig');
const {
  createAsyncTicket,
  applyAsyncBlockPatch,
  getAsyncUpdates,
  registerRecoTrackingSnapshot,
  getRecoTrackingMetadata,
} = require('./recoAsyncUpdateStore');
const { recordRecoEmployeeFeedback: writeRecoEmployeeFeedbackEvent } = require('./recoEmployeeFeedbackStore');
const { generatePrelabelsForAnchor, loadSuggestionsForAnchor } = require('./recoPrelabelService');
const { listQueueCandidatesWithSuggestions } = require('./recoLabelSuggestionStore');
const { buildLabelQueue } = require('./recoLabelQueue');
const { PRELABEL_PROMPT_VERSION } = require('./recoPrelabelPrompts');
const { normalizeCanonicalScoreBreakdown, normalizeWhyCandidateObject } = require('./recoScoreExplain');
const { extractWhitelistedSocialChannels } = require('./socialSummaryUserVisible');
const { simulateConflicts } = require('./routineRules');
const { buildConflictHeatmapV1 } = require('./conflictHeatmapV1');
const { auroraChat, buildContextPrefix } = require('./auroraDecisionClient');
const { extractJsonObject, extractJsonObjectByKeys, parseJsonOnlyObject } = require('./jsonExtract');
const { normalizeKey: normalizeDupeKbKey, getDupeKbEntry, upsertDupeKbEntry } = require('./dupeKbStore');
const {
  normalizeKey: normalizeProductIntelKbKey,
  getProductIntelKbEntry,
  upsertProductIntelKbEntry,
} = require('./productIntelKbStore');
const { parseMultipart, rmrf } = require('../lookReplicator/multipart');
const {
  createArtifactId,
  saveDiagnosisArtifact,
  getLatestDiagnosisArtifact,
  saveIngredientPlan,
  getIngredientPlanByArtifactId,
  saveRecoRun,
} = require('./diagnosisArtifactStore');
const {
  LOW_CONFIDENCE_THRESHOLD,
  buildIngredientPlan,
} = require('./ingredientMapperV1');
const {
  buildProductRecommendationsBundle,
  toLegacyRecommendationsPayload,
} = require('./productMatcherV1');
const { evaluateSafetyBoundary } = require('./safetyBoundary');
const {
  resolveProductRef: resolveProductRefDirect = null,
  _internals: productGroundingResolverInternals = {},
} = require('../services/productGroundingResolver');
let resolveProductRefDirectImpl = resolveProductRefDirect;
const {
  normalizeBudgetHint,
  mapConcerns,
  mapBarrierStatus,
  mapAuroraProductParse,
  mapAuroraProductAnalysis,
  mapAuroraAlternativesToDupeCompare,
  mapAuroraAlternativesToRecoAlternatives,
  mapAuroraRoutineToRecoGenerate,
} = require('./auroraStructuredMapper');

const resolveKnownStableProductRef =
  typeof productGroundingResolverInternals.resolveKnownStableProductRef === 'function'
    ? productGroundingResolverInternals.resolveKnownStableProductRef
    : null;
const normalizeTextForStableResolver =
  typeof productGroundingResolverInternals.normalizeTextForResolver === 'function'
    ? productGroundingResolverInternals.normalizeTextForResolver
    : (value) => String(value || '').trim().toLowerCase();
const tokenizeStableResolverQuery =
  typeof productGroundingResolverInternals.tokenizeNormalizedResolverQuery === 'function'
    ? productGroundingResolverInternals.tokenizeNormalizedResolverQuery
    : (value) =>
        String(value || '')
          .trim()
          .toLowerCase()
          .split(/\s+/)
          .filter(Boolean);

const AURORA_DECISION_BASE_URL = String(process.env.AURORA_DECISION_BASE_URL || '').replace(/\/$/, '');
const PIVOTA_BACKEND_BASE_URL = String(process.env.PIVOTA_BACKEND_BASE_URL || process.env.PIVOTA_API_BASE || '')
  .replace(/\/$/, '');
const INCLUDE_RAW_AURORA_CONTEXT = String(process.env.AURORA_BFF_INCLUDE_RAW_CONTEXT || '').toLowerCase() === 'true';
const USE_AURORA_BFF_MOCK = String(process.env.AURORA_BFF_USE_MOCK || '').toLowerCase() === 'true';
const CONFLICT_HEATMAP_V1_ENABLED = String(process.env.AURORA_BFF_CONFLICT_HEATMAP_V1_ENABLED || '').toLowerCase() === 'true';
const AURORA_CHAT_CATALOG_AVAIL_FAST_PATH_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_CATALOG_AVAIL_FAST_PATH || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_CLARIFICATION_FILTER_KNOWN_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_CLARIFICATION_FILTER_KNOWN || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_CLARIFICATION_FLOW_V2 || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_CLARIFICATION_HISTORY_CONTEXT_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_CLARIFICATION_HISTORY_CONTEXT || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_RESUME_PREFIX_V1_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_RESUME_PREFIX_V1 || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_RESUME_PREFIX_V2_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_RESUME_PREFIX_V2 || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_CHAT_RESUME_PROBE_METRICS_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_RESUME_PROBE_METRICS || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const PENDING_CLARIFICATION_TTL_MS = 10 * 60 * 1000;
const RECO_CATALOG_GROUNDED_ENABLED = String(process.env.AURORA_BFF_RECO_CATALOG_GROUNDED || '').toLowerCase() === 'true';
const RECO_CATALOG_GROUNDED_QUERIES = String(process.env.AURORA_BFF_RECO_CATALOG_QUERIES || '').trim();
const RECO_CATALOG_SEARCH_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_SEARCH_TIMEOUT_MS || 1800);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1800;
  return Math.max(400, Math.min(12000, v));
})();
const RECO_CATALOG_SEARCH_CONCURRENCY = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_SEARCH_CONCURRENCY || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(4, v));
})();
const RECO_CATALOG_TRANSIENT_FALLBACK_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_TRANSIENT_FALLBACK || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_TRANSIENT_FALLBACK_MAX_ITEMS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_TRANSIENT_FALLBACK_MAX_ITEMS || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(6, v));
})();
const RECO_CATALOG_FAIL_FAST_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_FAIL_FAST || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_FAIL_FAST_THRESHOLD = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_FAIL_FAST_THRESHOLD || 1);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1;
  return Math.max(1, Math.min(8, v));
})();
const RECO_CATALOG_FAIL_FAST_COOLDOWN_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_FAIL_FAST_COOLDOWN_MS || 90000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 90000;
  return Math.max(3000, Math.min(300000, v));
})();
const RECO_CATALOG_FAIL_FAST_PROBE_INTERVAL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_FAIL_FAST_PROBE_INTERVAL_MS || 8000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 8000;
  return Math.max(500, Math.min(60000, v));
})();
const RECO_CATALOG_FAIL_FAST_PROBE_SEARCH_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_FAIL_FAST_PROBE_SEARCH_TIMEOUT_MS || 1200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1200;
  return Math.max(300, Math.min(6000, v));
})();
const RECO_CATALOG_SEARCH_BASE_URLS = String(
  process.env.AURORA_BFF_RECO_CATALOG_SEARCH_BASE_URLS ||
  process.env.AURORA_BFF_RECO_BACKEND_BASE_URLS ||
  '',
).trim();
const RECO_CATALOG_SEARCH_PATHS = String(process.env.AURORA_BFF_RECO_CATALOG_SEARCH_PATHS || '').trim();
const RECO_CATALOG_BEAUTY_ROUTE_FIRST_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_BEAUTY_ROUTE_FIRST || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_BEAUTY_PATH_FALLBACK_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_ENABLE_BEAUTY_PATH_FALLBACK || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_SEARCH_SOURCE = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_SEARCH_SOURCE || 'aurora-bff')
    .trim()
    .toLowerCase();
  return raw || 'aurora-bff';
})();
const RECO_CATALOG_MULTI_SOURCE_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_MULTI_SOURCE_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_MULTI_SOURCE_ON_EMPTY = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_CATALOG_MULTI_SOURCE_ON_EMPTY || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_CATALOG_SOURCE_EMPTY_FAIL_THRESHOLD = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_SOURCE_EMPTY_FAIL_THRESHOLD || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(20, v));
})();
const RECO_CATALOG_SOURCE_EMPTY_COOLDOWN_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_CATALOG_SOURCE_EMPTY_COOLDOWN_MS || 5 * 60 * 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 5 * 60 * 1000;
  return Math.max(1000, Math.min(60 * 60 * 1000, v));
})();
const CATALOG_AVAIL_RESOLVE_FALLBACK_ENABLED = (() => {
  const raw = String(process.env.AURORA_CHAT_CATALOG_AVAIL_RESOLVE_FALLBACK || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const CATALOG_AVAIL_RESOLVE_FALLBACK_ON_TRANSIENT = (() => {
  const raw = String(process.env.AURORA_CHAT_CATALOG_AVAIL_RESOLVE_ON_TRANSIENT || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const CATALOG_AVAIL_RESOLVE_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_CHAT_CATALOG_AVAIL_RESOLVE_TIMEOUT_MS || 1400);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1400;
  return Math.max(300, Math.min(6000, v));
})();
const CATALOG_AVAIL_SEARCH_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_CHAT_CATALOG_AVAIL_SEARCH_TIMEOUT_MS || 1200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1200;
  return Math.max(300, Math.min(6000, v));
})();
const AURORA_CHAT_UPSTREAM_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_CHAT_UPSTREAM_TIMEOUT_MS || 22000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 22000;
  return Math.max(6000, Math.min(60000, v));
})();
const PRODUCT_INTEL_CATALOG_FALLBACK_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_PRODUCT_INTEL_CATALOG_FALLBACK || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const PRODUCT_INTEL_CATALOG_FALLBACK_MAX_QUERIES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_INTEL_CATALOG_FALLBACK_MAX_QUERIES || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(6, v));
})();
const PRODUCT_URL_INGREDIENT_ANALYSIS_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_INGREDIENT_TIMEOUT_MS || 3500);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3500;
  return Math.max(800, Math.min(12000, v));
})();
const PRODUCT_URL_INGREDIENT_ANALYSIS_ENABLED = (() => {
  const explicitRealtimeFlag = String(process.env.AURORA_BFF_PRODUCT_URL_REALTIME_INTEL || '').trim();
  const raw = String(explicitRealtimeFlag || process.env.AURORA_BFF_PRODUCT_URL_INGREDIENT_ANALYSIS || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const PRODUCT_URL_INGREDIENT_ANALYSIS_MAX_BYTES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_INGREDIENT_MAX_BYTES || 900000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 900000;
  return Math.max(120000, Math.min(2_000_000, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_TIMEOUT_MS || 1200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1200;
  return Math.max(300, Math.min(5000, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_MAX_QUERIES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_MAX_QUERIES || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(4, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_MAX_CANDIDATES || 4);
  const v = Number.isFinite(n) ? Math.trunc(n) : 4;
  return Math.max(1, Math.min(8, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_ASYNC_ENRICH_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_ASYNC_ENRICH || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_BACKFILL_TIMEOUT_MS || 3200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3200;
  return Math.max(600, Math.min(12000, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_QUERIES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_BACKFILL_MAX_QUERIES || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(6, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_CANDIDATES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_BACKFILL_MAX_CANDIDATES || 6);
  const v = Number.isFinite(n) ? Math.trunc(n) : 6;
  return Math.max(1, Math.min(10, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_PREFERRED_COUNT || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(6, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_SYNC_TIMEOUT_MS || 1100);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1100;
  return Math.max(300, Math.min(3500, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_MAX_QUERIES = (() => {
  const n = Number(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_SYNC_MAX_QUERIES || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(4, v));
})();
const PRODUCT_URL_REALTIME_COMPETITOR_MAIN_SEARCH_ALL_MERCHANTS = (() => {
  const raw = String(process.env.AURORA_BFF_PRODUCT_URL_COMPETITOR_MAIN_SEARCH_ALL_MERCHANTS || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_BFF_RECO_BLOCKS_DAG_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_BLOCKS_DAG_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_BFF_RECO_BLOCKS_BUDGET_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_BUDGET_MS || 1200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1200;
  return Math.max(120, Math.min(12000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_CATALOG_ANN_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_CATALOG_ANN_MS || 450);
  const v = Number.isFinite(n) ? Math.trunc(n) : 450;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_INGREDIENT_INDEX_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_INGREDIENT_INDEX_MS || 300);
  const v = Number.isFinite(n) ? Math.trunc(n) : 300;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_SKIN_FIT_LIGHT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_SKIN_FIT_LIGHT_MS || 240);
  const v = Number.isFinite(n) ? Math.trunc(n) : 240;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_KB_BACKFILL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_KB_BACKFILL_MS || 220);
  const v = Number.isFinite(n) ? Math.trunc(n) : 220;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_DUPE_PIPELINE_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_DUPE_PIPELINE_MS || 350);
  const v = Number.isFinite(n) ? Math.trunc(n) : 350;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_TIMEOUT_ON_PAGE_RELATED_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_BLOCKS_TIMEOUT_ON_PAGE_RELATED_MS || 220);
  const v = Number.isFinite(n) ? Math.trunc(n) : 220;
  return Math.max(40, Math.min(8000, v));
})();
const AURORA_BFF_RECO_BLOCKS_ON_PAGE_MODE = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_BLOCKS_ON_PAGE_MODE || 'fallback_only')
    .trim()
    .toLowerCase();
  return raw === 'always' ? 'always' : 'fallback_only';
})();
const AURORA_BFF_RECO_GUARD_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_GUARD_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_BFF_RECO_GUARD_CIRCUIT_THRESHOLD = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_GUARD_CIRCUIT_THRESHOLD || 1);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1;
  return Math.max(1, Math.min(20, v));
})();
const AURORA_BFF_RECO_GUARD_CIRCUIT_COOLDOWN_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_GUARD_CIRCUIT_COOLDOWN_MS || 600000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 600000;
  return Math.max(1000, Math.min(60 * 60 * 1000, v));
})();
const AURORA_BFF_RECO_GUARD_STRICT_DEFAULT_MODE = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_GUARD_STRICT_DEFAULT_MODE || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const RECO_DOGFOOD_CONFIG = buildRecoDogfoodConfig(process.env);
const PRODUCT_INTEL_KB_ASYNC_BACKFILL_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_PRODUCT_INTEL_KB_ASYNC_BACKFILL || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const DUPE_KB_ASYNC_BACKFILL_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_DUPE_KB_ASYNC_BACKFILL || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const PIVOTA_BACKEND_AGENT_API_KEY = String(
  process.env.PIVOTA_BACKEND_AGENT_API_KEY ||
    process.env.PIVOTA_BACKEND_API_KEY ||
    process.env.PIVOTA_API_KEY ||
    process.env.SHOP_GATEWAY_AGENT_API_KEY ||
    process.env.PIVOTA_AGENT_API_KEY ||
    process.env.AGENT_API_KEY ||
    '',
).trim();
const OPENAI_API_KEY = String(process.env.OPENAI_API_KEY || '').trim();
const GEMINI_API_KEY = String(
  process.env.AURORA_SKIN_GEMINI_API_KEY || process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY || '',
).trim();
const OPENAI_BASE_URL = String(process.env.OPENAI_BASE_URL || process.env.OPENAI_API_BASE || '').trim();
const SKIN_VISION_ENABLED = String(process.env.AURORA_SKIN_VISION_ENABLED || '').toLowerCase() === 'true';
const SKIN_VISION_PROVIDER = (() => {
  const raw = String(process.env.AURORA_SKIN_VISION_PROVIDER || 'gemini')
    .trim()
    .toLowerCase();
  if (raw === 'openai' || raw === 'gemini' || raw === 'auto') return raw;
  return 'gemini';
})();
const SKIN_VISION_MODEL_OPENAI =
  String(process.env.AURORA_SKIN_VISION_MODEL_OPENAI || process.env.AURORA_SKIN_VISION_MODEL || 'gpt-4o-mini').trim() ||
  'gpt-4o-mini';
const SKIN_VISION_MODEL_GEMINI =
  String(process.env.AURORA_SKIN_VISION_MODEL_GEMINI || process.env.GEMINI_MODEL || 'gemini-2.0-flash').trim() ||
  'gemini-2.0-flash';
const SKIN_DEGRADED_MODE = (() => {
  const raw = String(process.env.AURORA_SKIN_DEGRADED_MODE || 'report')
    .trim()
    .toLowerCase();
  return raw === 'vision' ? 'vision' : 'report';
})();
const SKIN_VISION_TIMEOUT_MS = Math.max(
  2000,
  Math.min(30000, Number(process.env.AURORA_SKIN_VISION_TIMEOUT_MS || 12000)),
);
const SKIN_VISION_RETRY_MAX = Math.max(
  0,
  Math.min(2, Number(process.env.AURORA_SKIN_VISION_RETRY_MAX || 2)),
);
const SKIN_VISION_RETRY_BASE_MS = Math.max(
  50,
  Math.min(2000, Number(process.env.AURORA_SKIN_VISION_RETRY_BASE_MS || 250)),
);
const SKIN_VISION_FORCE_CALL = String(process.env.AURORA_SKIN_FORCE_VISION_CALL || '').toLowerCase() === 'true';
const PHOTO_UPLOAD_PROXY_MAX_BYTES = Math.max(
  1024 * 1024,
  Math.min(25 * 1024 * 1024, Number(process.env.AURORA_PHOTO_UPLOAD_MAX_BYTES || 10 * 1024 * 1024)),
);
const PHOTO_UPLOAD_PARSE_TIMEOUT_MS = Math.max(
  1000,
  Math.min(120000, Number(process.env.AURORA_PHOTO_UPLOAD_PARSE_TIMEOUT_MS || 30000)),
);
const PHOTO_DOWNLOAD_URL_TIMEOUT_MS = Math.max(
  1000,
  Math.min(20000, Number(process.env.AURORA_PHOTO_DOWNLOAD_URL_TIMEOUT_MS || 5000)),
);
const PHOTO_FETCH_TIMEOUT_MS = Math.max(
  1000,
  Math.min(20000, Number(process.env.AURORA_PHOTO_FETCH_TIMEOUT_MS || 3000)),
);
const PHOTO_FETCH_TOTAL_TIMEOUT_MS = Math.max(
  2000,
  Math.min(30000, Number(process.env.AURORA_PHOTO_FETCH_TOTAL_TIMEOUT_MS || 5000)),
);
const PHOTO_FETCH_RETRIES = Math.max(0, Math.min(5, Number(process.env.AURORA_PHOTO_FETCH_RETRIES || 2)));
const PHOTO_FETCH_RETRY_BASE_MS = Math.max(
  100,
  Math.min(2000, Number(process.env.AURORA_PHOTO_FETCH_RETRY_BASE_MS || 250)),
);
const PHOTO_BYTES_CACHE_MAX_ITEMS = Math.max(
  0,
  Math.min(500, Number(process.env.AURORA_PHOTO_CACHE_MAX_ITEMS || 40)),
);
const PHOTO_BYTES_CACHE_TTL_MS = Math.max(
  10 * 1000,
  Math.min(30 * 60 * 1000, Number(process.env.AURORA_PHOTO_CACHE_TTL_MS || 10 * 60 * 1000)),
);
const PHOTO_AUTO_ANALYZE_AFTER_CONFIRM = String(process.env.AURORA_PHOTO_AUTO_ANALYZE_AFTER_CONFIRM || 'true').toLowerCase() !== 'false';
const DIAG_PHOTO_MODULES_CARD = String(process.env.DIAG_PHOTO_MODULES_CARD || '').toLowerCase() === 'true';
const DIAG_VERIFY_ALLOW_GUARD_TEST = String(process.env.ALLOW_GUARD_TEST || '').toLowerCase() === 'true';
const DIAG_OVERLAY_MODE = (() => {
  const raw = String(process.env.DIAG_OVERLAY_MODE || 'client')
    .trim()
    .toLowerCase();
  return raw === 'client' ? 'client' : 'client';
})();
const DIAG_INGREDIENT_REC = String(process.env.DIAG_INGREDIENT_REC || 'true').toLowerCase() !== 'false';
const DIAG_PRODUCT_REC = String(process.env.DIAG_PRODUCT_REC || '').toLowerCase() === 'true';
const DIAG_SKINMASK_ENABLED = String(process.env.DIAG_SKINMASK_ENABLED || '').toLowerCase() === 'true';
const DIAG_SKINMASK_MODEL_PATH = String(process.env.DIAG_SKINMASK_MODEL_PATH || 'artifacts/skinmask_v2.onnx').trim();
const DIAG_SKINMASK_TIMEOUT_MS = (() => {
  const n = Number(process.env.DIAG_SKINMASK_TIMEOUT_MS || 1200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1200;
  return Math.max(100, Math.min(15000, v));
})();
const DIAG_PRODUCT_REC_MIN_CITATIONS = Math.max(
  0,
  Math.min(5, Math.trunc(Number(process.env.DIAG_PRODUCT_REC_MIN_CITATIONS || 1) || 1)),
);
const DIAG_PRODUCT_REC_MIN_EVIDENCE_GRADE = (() => {
  const token = String(process.env.DIAG_PRODUCT_REC_MIN_EVIDENCE_GRADE || 'B')
    .trim()
    .toUpperCase();
  if (token === 'A' || token === 'B' || token === 'C') return token;
  return 'B';
})();
const DIAG_PRODUCT_REC_REPAIR_ONLY_WHEN_DEGRADED =
  String(process.env.DIAG_PRODUCT_REC_REPAIR_ONLY_WHEN_DEGRADED || '').toLowerCase() === 'true';
const INTERNAL_TEST_MODE = String(process.env.INTERNAL_TEST_MODE || '').toLowerCase() === 'true';
const DIAG_INGREDIENT_KB_V2_PATH = String(process.env.INGREDIENT_KB_V2_PATH || '').trim() || null;
const DIAG_PRODUCT_CATALOG_PATH = String(process.env.AURORA_PRODUCT_REC_CATALOG_PATH || '').trim() || null;
const AURORA_DIAG_ARTIFACT_ENABLED = (() => {
  const raw = String(process.env.AURORA_DIAG_ARTIFACT_ENABLED || 'true').trim().toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_INGREDIENT_PLAN_ENABLED = (() => {
  const raw = String(process.env.AURORA_INGREDIENT_PLAN_ENABLED || 'true').trim().toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_PRODUCT_MATCHER_ENABLED = (() => {
  const raw = String(process.env.AURORA_PRODUCT_MATCHER_ENABLED || 'true').trim().toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();
const AURORA_AURORAAPP_PHOTO_PIPELINE_ENABLED = (() => {
  const raw = String(process.env.AURORA_AURORAAPP_PHOTO_PIPELINE_ENABLED || 'false').trim().toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_ALTERNATIVES_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_ALTERNATIVES_TIMEOUT_MS || 9000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 9000;
  return Math.max(2000, Math.min(20000, v));
})();

const RECO_ALTERNATIVES_MAX_PRODUCTS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_ALTERNATIVES_MAX_PRODUCTS || 5);
  const v = Number.isFinite(n) ? Math.trunc(n) : 5;
  return Math.max(0, Math.min(6, v));
})();

const RECO_ALTERNATIVES_CONCURRENCY = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_ALTERNATIVES_CONCURRENCY || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(4, v));
})();

const RECO_UPSTREAM_TIMEOUT_HARD_CAP_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_UPSTREAM_TIMEOUT_HARD_CAP_MS || 4500);
  const v = Number.isFinite(n) ? Math.trunc(n) : 4500;
  return Math.max(2000, Math.min(22000, v));
})();

const RECO_UPSTREAM_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_UPSTREAM_TIMEOUT_MS || 3500);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3500;
  const bounded = Math.max(3000, Math.min(22000, v));
  return Math.min(bounded, RECO_UPSTREAM_TIMEOUT_HARD_CAP_MS);
})();

const RECO_ROUTINE_UPSTREAM_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_ROUTINE_TIMEOUT_MS || 14000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 14000;
  return Math.max(3000, Math.min(22000, v));
})();

const RECO_PDP_RESOLVE_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_RESOLVE_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_RESOLVE_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_RESOLVE_TIMEOUT_MS || 900);
  const v = Number.isFinite(n) ? Math.trunc(n) : 900;
  return Math.max(300, Math.min(6000, v));
})();

const RECO_PDP_RESOLVE_TIMEOUT_STRICT_MIN_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_RESOLVE_TIMEOUT_STRICT_MIN_MS || 2200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2200;
  return Math.max(600, Math.min(12000, v));
})();

const RECO_PDP_OFFERS_RESOLVE_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_OFFERS_RESOLVE_TIMEOUT_MS || 2200);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2200;
  return Math.max(300, Math.min(6000, v));
})();

const RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED = (() => {
  const fallbackDefault = 'false';
  const raw = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED || fallbackDefault)
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_NO_CANDIDATES = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_NO_CANDIDATES || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_UPSTREAM_TIMEOUT = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_UPSTREAM_TIMEOUT || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_FAILURE = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_FAILURE || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_NO_CANDIDATES = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_NO_CANDIDATES || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_SKIP_OPAQUE_STABLE_IDS = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_SKIP_OPAQUE_STABLE_IDS || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_LOCAL_INVOKE_BASE_URL = (() => {
  const explicit = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_BASE_URL || '').trim();
  if (explicit) return explicit.replace(/\/+$/, '');
  const rawPort = String(process.env.PORT || '3000').trim();
  const normalizedPort = /^\d+$/.test(rawPort) ? rawPort : '3000';
  return `http://127.0.0.1:${normalizedPort}`;
})();

const RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS || 500);
  const v = Number.isFinite(n) ? Math.trunc(n) : 500;
  return Math.max(250, Math.min(4000, v));
})();

const RECO_PDP_LOCAL_SEARCH_FALLBACK_ON_TRANSIENT = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_LOCAL_SEARCH_FALLBACK_ON_TRANSIENT || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_ENRICH_CONCURRENCY = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_ENRICH_CONCURRENCY || 6);
  const v = Number.isFinite(n) ? Math.trunc(n) : 6;
  return Math.max(1, Math.min(12, v));
})();

const RECO_PDP_ENRICH_MAX_NETWORK_ITEMS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_PDP_ENRICH_MAX_NETWORK_ITEMS || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(0, Math.min(8, v));
})();

const RECO_PDP_CHAT_DISABLE_LOCAL_DOUBLE_HOP = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_CHAT_DISABLE_LOCAL_DOUBLE_HOP || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_FAST_EXTERNAL_FALLBACK_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_FAST_EXTERNAL_FALLBACK || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_PDP_STRICT_INTERNAL_FIRST = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_PDP_STRICT_INTERNAL_FIRST || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_TEST_SEED_MAX_PER_RESPONSE = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_TEST_SEED_MAX_PER_RESPONSE || 1);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1;
  return Math.max(0, Math.min(4, v));
})();

const RECO_TEST_SEED_MIN_TOTAL = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_TEST_SEED_MIN_TOTAL || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(8, v));
})();

const RECO_DIVERSITY_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_RECO_DIVERSITY_ENABLED || 'true')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const RECO_DIVERSITY_MAX_REPEAT_PER_RESPONSE = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_DIVERSITY_MAX_REPEAT_PER_RESPONSE || 1);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1;
  return Math.max(0, Math.min(4, v));
})();

const RECO_DIVERSITY_MIN_TOTAL = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_DIVERSITY_MIN_TOTAL || 3);
  const v = Number.isFinite(n) ? Math.trunc(n) : 3;
  return Math.max(1, Math.min(8, v));
})();

const RECO_DIVERSITY_HISTORY_MAX_ITEMS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_DIVERSITY_HISTORY_MAX_ITEMS || 24);
  const v = Number.isFinite(n) ? Math.trunc(n) : 24;
  return Math.max(4, Math.min(64, v));
})();

const RECO_DIVERSITY_HISTORY_TTL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_RECO_DIVERSITY_HISTORY_TTL_MS || 45 * 60 * 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 45 * 60 * 1000;
  return Math.max(60 * 1000, Math.min(24 * 60 * 60 * 1000, v));
})();

const AURORA_BFF_PDP_CORE_PREFETCH_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_PDP_CORE_PREFETCH_ENABLED || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const AURORA_BFF_PDP_CORE_PREFETCH_MAX_ITEMS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_CORE_PREFETCH_MAX_ITEMS || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(8, v));
})();

const AURORA_BFF_PDP_CORE_PREFETCH_TIMEOUT_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_CORE_PREFETCH_TIMEOUT_MS || 1600);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1600;
  return Math.max(300, Math.min(6000, v));
})();

const AURORA_BFF_PDP_CORE_PREFETCH_DEDUP_TTL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_CORE_PREFETCH_DEDUP_TTL_MS || 120000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 120000;
  return Math.max(1000, Math.min(15 * 60 * 1000, v));
})();

const AURORA_BFF_PDP_CORE_PREFETCH_INCLUDE = (() => {
  const raw = String(process.env.AURORA_BFF_PDP_CORE_PREFETCH_INCLUDE || 'offers,reviews_preview,similar')
    .trim()
    .toLowerCase();
  const tokens = raw
    .split(',')
    .map((part) => part.trim())
    .filter(Boolean);
  const normalized = [];
  const seen = new Set();
  for (const token of tokens) {
    const mapped = token === 'recommendations' ? 'similar' : token;
    if (mapped !== 'offers' && mapped !== 'reviews_preview' && mapped !== 'similar') continue;
    if (seen.has(mapped)) continue;
    seen.add(mapped);
    normalized.push(mapped);
  }
  return normalized.length ? normalized : ['offers'];
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_ENABLED = (() => {
  const raw = String(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_ENABLED || 'false')
    .trim()
    .toLowerCase();
  return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_INTERVAL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_INTERVAL_MS || 10 * 60 * 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 10 * 60 * 1000;
  return Math.max(30 * 1000, Math.min(60 * 60 * 1000, v));
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_INITIAL_DELAY_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_INITIAL_DELAY_MS || 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1000;
  return Math.max(0, Math.min(5 * 60 * 1000, v));
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_CONCURRENCY = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_CONCURRENCY || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(8, v));
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_ROUNDS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_ROUNDS || 2);
  const v = Number.isFinite(n) ? Math.trunc(n) : 2;
  return Math.max(1, Math.min(8, v));
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_GAP_MS = (() => {
  const n = Number(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_GAP_MS || 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 1000;
  return Math.max(0, Math.min(5 * 60 * 1000, v));
})();

const AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY = String(
  process.env.AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY || '',
).trim();
const AURORA_BFF_RECO_PRELABEL_ADMIN_KEY = String(
  process.env.AURORA_BFF_RECO_PRELABEL_ADMIN_KEY || '',
).trim();

function parsePdpHotsetFromEnv(raw) {
  const text = String(raw || '').trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

function parsePdpHotsetCompactList(raw) {
  const text = String(raw || '').trim();
  if (!text) return [];
  return text
    .split(/[,\n]/)
    .map((part) => part.trim())
    .filter(Boolean)
    .map((entry) => {
      const [merchantIdRaw, productIdRaw] = entry.split(':');
      const merchantId = String(merchantIdRaw || '').trim();
      const productId = String(productIdRaw || '').trim();
      if (!merchantId || !productId) return null;
      return {
        product_ref: {
          merchant_id: merchantId,
          product_id: productId,
        },
      };
    })
    .filter(Boolean);
}

const AURORA_BFF_PDP_HOTSET_PREWARM_ITEMS = (() => {
  const fromEnv = parsePdpHotsetFromEnv(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_JSON);
  if (fromEnv.length) return fromEnv;
  const fromCompactList = parsePdpHotsetCompactList(process.env.AURORA_BFF_PDP_HOTSET_PREWARM_LIST);
  if (fromCompactList.length) return fromCompactList;
  return [
    {
      product_ref: {
        merchant_id: 'merch_efbc46b4619cfbdf',
        product_id: '9886500749640',
      },
    },
    {
      product_ref: {
        merchant_id: 'merch_efbc46b4619cfbdf',
        product_id: '9886500127048',
      },
    },
  ];
})();

const DUPE_DEEPSCAN_CACHE_MAX = (() => {
  const n = Number(process.env.AURORA_BFF_DUPE_DEEPSCAN_CACHE_MAX || 80);
  const v = Number.isFinite(n) ? Math.trunc(n) : 80;
  return Math.max(0, Math.min(300, v));
})();

const DUPE_DEEPSCAN_CACHE_TTL_MS = (() => {
  const n = Number(process.env.AURORA_BFF_DUPE_DEEPSCAN_CACHE_TTL_MS || 6 * 60 * 60 * 1000);
  const v = Number.isFinite(n) ? Math.trunc(n) : 6 * 60 * 60 * 1000;
  return Math.max(30 * 1000, Math.min(24 * 60 * 60 * 1000, v));
})();

const dupeDeepscanCache = new Map();
const photoBytesCache = new Map();
const pdpPrefetchRecentMap = new Map();
const recoRecentExposureState = new Map();
let pdpHotsetPrewarmStarted = false;
let pdpHotsetPrewarmInFlight = false;
const pdpPrefetchStats = {
  totals: {
    total: 0,
    ok: 0,
    non_200: 0,
    failed: 0,
  },
  by_reason: {},
  last_prefetch: null,
  hotset_runs: {
    started: 0,
    completed: 0,
    skipped_unavailable: 0,
    skipped_disabled: 0,
    skipped_no_hotset: 0,
    skipped_in_flight: 0,
    failed: 0,
  },
  hotset_last: null,
};

function getDupeDeepscanCache(key) {
  if (!key || DUPE_DEEPSCAN_CACHE_MAX <= 0) return null;
  const entry = dupeDeepscanCache.get(key);
  if (!entry) return null;
  if (!entry.expiresAt || entry.expiresAt <= Date.now()) {
    dupeDeepscanCache.delete(key);
    return null;
  }
  // Touch for LRU-ish behavior.
  dupeDeepscanCache.delete(key);
  dupeDeepscanCache.set(key, entry);
  return entry.value || null;
}

function setDupeDeepscanCache(key, value) {
  if (!key || DUPE_DEEPSCAN_CACHE_MAX <= 0) return;
  dupeDeepscanCache.set(key, { value, expiresAt: Date.now() + DUPE_DEEPSCAN_CACHE_TTL_MS });
  while (dupeDeepscanCache.size > DUPE_DEEPSCAN_CACHE_MAX) {
    const oldestKey = dupeDeepscanCache.keys().next().value;
    if (!oldestKey) break;
    dupeDeepscanCache.delete(oldestKey);
  }
}

function getAuroraUidFromReq(req) {
  if (!req || typeof req.get !== 'function') return '';
  return String(req.get('X-Aurora-UID') || req.get('x-aurora-uid') || '').trim();
}

function makePhotoCacheKey({ photoId, auroraUid } = {}) {
  const pid = String(photoId || '').trim();
  const uid = String(auroraUid || '').trim();
  if (!pid || !uid) return '';
  return `${uid}:${pid}`;
}

function setPhotoBytesCache({ photoId, auroraUid, buffer, contentType } = {}) {
  if (PHOTO_BYTES_CACHE_MAX_ITEMS <= 0) return;
  const key = makePhotoCacheKey({ photoId, auroraUid });
  if (!key || !buffer || !Buffer.isBuffer(buffer) || !buffer.length) return;
  photoBytesCache.set(key, {
    buffer,
    contentType: String(contentType || 'image/jpeg').trim() || 'image/jpeg',
    expiresAt: Date.now() + PHOTO_BYTES_CACHE_TTL_MS,
  });
  while (photoBytesCache.size > PHOTO_BYTES_CACHE_MAX_ITEMS) {
    const oldestKey = photoBytesCache.keys().next().value;
    if (!oldestKey) break;
    photoBytesCache.delete(oldestKey);
  }
}

function getPhotoBytesCache({ photoId, auroraUid } = {}) {
  const key = makePhotoCacheKey({ photoId, auroraUid });
  if (!key) return null;
  const entry = photoBytesCache.get(key);
  if (!entry) return null;
  if (!entry.expiresAt || entry.expiresAt <= Date.now()) {
    photoBytesCache.delete(key);
    return null;
  }
  photoBytesCache.delete(key);
  photoBytesCache.set(key, entry);
  return entry;
}

function getCheckoutToken(req) {
  const v = req.get('X-Checkout-Token') || req.get('x-checkout-token');
  return v ? String(v).trim() : '';
}

function buildPivotaBackendAuthHeaders(req) {
  const checkoutToken = getCheckoutToken(req);
  if (checkoutToken) return { 'X-Checkout-Token': checkoutToken };
  if (PIVOTA_BACKEND_AGENT_API_KEY) {
    return { 'X-API-Key': PIVOTA_BACKEND_AGENT_API_KEY, Authorization: `Bearer ${PIVOTA_BACKEND_AGENT_API_KEY}` };
  }
  return {};
}

function buildPivotaBackendAgentHeaders() {
  if (PIVOTA_BACKEND_AGENT_API_KEY) {
    return { 'X-API-Key': PIVOTA_BACKEND_AGENT_API_KEY, Authorization: `Bearer ${PIVOTA_BACKEND_AGENT_API_KEY}` };
  }
  return {};
}

function extractAgentProductsFromSearchResponse(raw) {
  if (!raw) return [];
  const obj = raw && typeof raw === 'object' ? raw : null;
  if (!obj) return [];
  if (Array.isArray(obj)) return obj;
  if (Array.isArray(obj.products)) return obj.products;
  if (Array.isArray(obj.items)) return obj.items;
  if (Array.isArray(obj.results)) return obj.results;
  const data = obj.data;
  if (data && typeof data === 'object') {
    if (Array.isArray(data.products)) return data.products;
    if (Array.isArray(data.items)) return data.items;
    if (Array.isArray(data.results)) return data.results;
  }
  return [];
}

function clamp01Score(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return 0;
  if (n <= 0) return 0;
  if (n >= 1) return 1;
  return n;
}

function normalizeMaybePercentScore(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  if (n <= 0) return 0;
  if (n > 100) return 1;
  if (n > 5) return clamp01Score(n / 100);
  if (n > 1) return clamp01Score(n / 5);
  return clamp01Score(n);
}

function readNestedValue(obj, path) {
  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return undefined;
  const parts = String(path || '')
    .split('.')
    .map((p) => p.trim())
    .filter(Boolean);
  if (!parts.length) return undefined;
  let cur = obj;
  for (const part of parts) {
    if (!cur || typeof cur !== 'object' || Array.isArray(cur)) return undefined;
    if (!(part in cur)) return undefined;
    cur = cur[part];
  }
  return cur;
}

function collectCatalogFieldValues(base, paths) {
  const out = [];
  for (const path of Array.isArray(paths) ? paths : []) {
    const v = readNestedValue(base, path);
    if (v == null) continue;
    out.push(v);
  }
  return out;
}

function flattenStringsFromValue(value, max = 30) {
  const out = [];
  const stack = [value];
  while (stack.length && out.length < max) {
    const cur = stack.pop();
    if (cur == null) continue;
    if (typeof cur === 'string' || typeof cur === 'number') {
      const s = String(cur).trim();
      if (s) out.push(s);
      continue;
    }
    if (Array.isArray(cur)) {
      for (let i = cur.length - 1; i >= 0; i -= 1) stack.push(cur[i]);
      continue;
    }
    if (cur && typeof cur === 'object') {
      for (const key of Object.keys(cur)) stack.push(cur[key]);
    }
  }
  return out;
}

function normalizeSkinTypeTag(raw) {
  const t = String(raw || '').trim().toLowerCase();
  if (!t) return '';
  if (/\b(oily|oil[-\s]?control|sebum)\b/.test(t) || //.test(t)) return 'oily';
  if (/\b(dry|dehydrated)\b/.test(t) || /|/.test(t)) return 'dry';
  if (/\b(combo|combination)\b/.test(t) || //.test(t)) return 'combination';
  if (/\b(normal)\b/.test(t) || //.test(t)) return 'normal';
  if (/\b(sensitive|reactive)\b/.test(t) || //.test(t)) return 'sensitive';
  if (/\b(acne|blemish|comedo|breakout)\b/.test(t) || //.test(t)) return 'acne_prone';
  if (/\b(barrier|impaired)\b/.test(t) || //.test(t)) return 'impaired_barrier';
  return '';
}

function collectCandidateSkinTypeTags(base) {
  const values = collectCatalogFieldValues(base, [
    'skin_types',
    'skinTypes',
    'skin_type',
    'skinType',
    'suitable_for',
    'suitableFor',
    'fit_skin_types',
    'fitSkinTypes',
    'suitability_tags',
    'target_skin',
    'targetSkin',
    'tags',
    'subject.skin_types',
    'subject.suitable_for',
    'metadata.skin_types',
    'attributes.skin_types',
  ]);
  const out = [];
  const seen = new Set();
  for (const value of values) {
    for (const text of flattenStringsFromValue(value, 30)) {
      const parts = String(text)
        .split(/[|,/;]+/g)
        .map((x) => x.trim())
        .filter(Boolean);
      for (const part of parts.length ? parts : [text]) {
        const tag = normalizeSkinTypeTag(part);
        if (!tag || seen.has(tag)) continue;
        seen.add(tag);
        out.push(tag);
      }
    }
  }
  return out.slice(0, 8);
}

function normalizeIngredientTokensFromStrings(values) {
  const out = [];
  const seen = new Set();
  const pushToken = (token) => {
    const t = String(token || '').trim().toLowerCase();
    if (!t || t.length < 3 || seen.has(t)) return;
    seen.add(t);
    out.push(t);
  };
  for (const raw of Array.isArray(values) ? values : []) {
    const text = String(raw || '').trim();
    if (!text) continue;
    const splitList = splitInciList(text);
    const segments = splitList.length ? splitList : [text];
    for (const segment of segments) {
      const tokens = tokenizeProductTextForSimilarity(segment);
      for (const token of tokens) pushToken(token);
    }
  }
  return out.slice(0, 36);
}

function collectCandidateIngredientTokens(base) {
  const values = collectCatalogFieldValues(base, [
    'key_ingredients',
    'keyIngredients',
    'active_ingredients',
    'activeIngredients',
    'hero_actives',
    'heroActives',
    'ingredients',
    'inci',
    'inci_list',
    'subject.key_ingredients',
    'subject.active_ingredients',
    'metadata.key_ingredients',
    'attributes.key_ingredients',
  ]);
  const flattened = [];
  for (const value of values) flattened.push(...flattenStringsFromValue(value, 40));
  return normalizeIngredientTokensFromStrings(flattened);
}

function normalizeSocialTopicKeyword(raw) {
  const text = String(raw == null ? '' : raw).trim();
  if (!text) return '';
  const token = text.replace(/^#/, '').trim();
  if (!token) return '';
  if (token.length < 2 || token.length > 40) return '';
  if (/https?:\/\//i.test(token)) return '';
  if (/@/.test(token)) return '';
  if (/^(?:route_|dedupe_|internal_|fallback_|ref_)/i.test(token)) return '';
  if (/^[0-9\-_:/.]+$/.test(token)) return '';
  if (/|100%\s*(?:||identical|same)|miracle\s+dupe|/i.test(token)) return '';
  return token;
}

function collectSocialTopicKeywords(base) {
  const values = collectCatalogFieldValues(base, [
    'topic_keywords',
    'topicKeywords',
    'top_keywords',
    'topKeywords',
    'keywords',
    'social.top_keywords',
    'social.topKeywords',
    'social_stats.top_keywords',
    'socialStats.topKeywords',
    'social_stats.topics',
    'socialStats.topics',
    'social.topics',
  ]);
  const out = [];
  const seen = new Set();
  for (const value of values) {
    for (const text of flattenStringsFromValue(value, 40)) {
      const segments = String(text)
        .split(/[|,/;]+/g)
        .map((x) => x.trim())
        .filter(Boolean);
      for (const segment of segments.length ? segments : [text]) {
        const keyword = normalizeSocialTopicKeyword(segment);
        if (!keyword) continue;
        const key = keyword.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(keyword);
        if (out.length >= 12) return out;
      }
    }
  }
  return out;
}

function normalizeSocialSentimentProxy(value) {
  if (value == null || value === '') return null;
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  if (n >= -1 && n <= 1) return clamp01Score((n + 1) / 2);
  return normalizeMaybePercentScore(n);
}

function extractCandidateSocialReference(base) {
  const values = collectCatalogFieldValues(base, [
    'social_score',
    'socialScore',
    'rating',
    'rating_value',
    'ratingValue',
    'aggregate_rating',
    'aggregateRating',
    'social_stats.platform_scores',
    'socialStats.platformScores',
  ]);
  const supportValues = collectCatalogFieldValues(base, [
    'review_count',
    'reviewCount',
    'social_stats.mention_count',
    'socialStats.mentionCount',
    'social_stats.sample_size',
    'socialStats.sampleSize',
  ]);
  const sentimentValues = collectCatalogFieldValues(base, [
    'sentiment_proxy',
    'sentimentProxy',
    'social.sentiment_proxy',
    'social.sentimentProxy',
    'social.sentiment',
    'social_stats.sentiment',
    'socialStats.sentiment',
  ]);
  const contextMatchValues = collectCatalogFieldValues(base, [
    'context_match',
    'contextMatch',
    'social.context_match',
    'social.contextMatch',
    'social_stats.context_match',
    'socialStats.contextMatch',
  ]);
  const channelValues = collectCatalogFieldValues(base, [
    'social_channels',
    'socialChannels',
    'platforms',
    'social.platforms',
    'social_stats.platforms',
    'socialStats.platforms',
  ]);
  const topicKeywords = collectSocialTopicKeywords(base);

  const scoreSamples = [];
  const platformScoreKeys = [];
  for (const value of values) {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      platformScoreKeys.push(...Object.keys(value));
      for (const v of Object.values(value)) {
        const score = normalizeMaybePercentScore(v);
        if (score != null) scoreSamples.push(score);
      }
      continue;
    }
    const score = normalizeMaybePercentScore(value);
    if (score != null) scoreSamples.push(score);
  }
  let score = null;
  if (scoreSamples.length) {
    score = clamp01Score(scoreSamples.reduce((sum, v) => sum + v, 0) / scoreSamples.length);
  }

  let supportCount = null;
  for (const value of supportValues) {
    const n = Number(value);
    if (!Number.isFinite(n) || n <= 0) continue;
    supportCount = supportCount == null ? n : Math.max(supportCount, n);
  }

  if (score != null && supportCount != null) {
    // Use sample size as a small confidence bump; cap to avoid overpowering.
    const supportBoost = Math.min(0.08, Math.log10(1 + supportCount) * 0.02);
    score = clamp01Score(score + supportBoost);
  }

  let sentimentProxy = null;
  for (const value of sentimentValues) {
    const normalized = normalizeSocialSentimentProxy(value);
    if (normalized == null) continue;
    sentimentProxy = sentimentProxy == null ? normalized : (sentimentProxy + normalized) / 2;
  }
  if (sentimentProxy != null) sentimentProxy = clamp01Score(sentimentProxy);

  let contextMatch = null;
  for (const value of contextMatchValues) {
    const normalized = normalizeMaybePercentScore(value);
    if (normalized == null) continue;
    contextMatch = contextMatch == null ? normalized : Math.max(contextMatch, normalized);
  }

  const channelHints = [
    ...platformScoreKeys,
    ...channelValues.flatMap((value) => flattenStringsFromValue(value, 20)),
  ];
  const channels = extractWhitelistedSocialChannels({
    channels: channelHints,
  });

  const socialRaw = {
    ...(score != null ? { co_mention_strength: Number(score.toFixed(3)) } : {}),
    ...(topicKeywords.length ? { topic_keywords: topicKeywords } : {}),
    ...(sentimentProxy != null ? { sentiment_proxy: Number(sentimentProxy.toFixed(3)) } : {}),
    ...(contextMatch != null ? { context_match: Number(contextMatch.toFixed(3)) } : {}),
    ...(channels.length ? { channels } : {}),
  };

  return {
    score,
    support_count: supportCount,
    social_raw: Object.keys(socialRaw).length ? socialRaw : null,
  };
}

function normalizeRecoCatalogProduct(raw) {
  const base = raw && typeof raw === 'object' && !Array.isArray(raw) ? raw : {};

  const productId =
    (typeof base.product_id === 'string' && base.product_id) ||
    (typeof base.productId === 'string' && base.productId) ||
    (typeof base.id === 'string' && base.id) ||
    '';

  const merchantId =
    (typeof base.merchant_id === 'string' && base.merchant_id) ||
    (typeof base.merchantId === 'string' && base.merchantId) ||
    (base.merchant && typeof base.merchant === 'object' && !Array.isArray(base.merchant) && typeof base.merchant.merchant_id === 'string'
      ? base.merchant.merchant_id
      : '') ||
    '';

  const brand =
    (typeof base.brand === 'string' && base.brand) ||
    (typeof base.brand_name === 'string' && base.brand_name) ||
    (typeof base.brandName === 'string' && base.brandName) ||
    '';

  const name =
    (typeof base.name === 'string' && base.name) ||
    (typeof base.title === 'string' && base.title) ||
    '';

  const displayName =
    (typeof base.display_name === 'string' && base.display_name) ||
    (typeof base.displayName === 'string' && base.displayName) ||
    name ||
    '';

  const skuId =
    (typeof base.sku_id === 'string' && base.sku_id) ||
    (typeof base.skuId === 'string' && base.skuId) ||
    '';

  const productGroupId =
    (typeof base.product_group_id === 'string' && base.product_group_id) ||
    (typeof base.productGroupId === 'string' && base.productGroupId) ||
    (base.subject &&
    typeof base.subject === 'object' &&
    !Array.isArray(base.subject) &&
    typeof base.subject.product_group_id === 'string'
      ? base.subject.product_group_id
      : '') ||
    '';

  const imageUrl =
    (typeof base.image_url === 'string' && base.image_url) ||
    (typeof base.imageUrl === 'string' && base.imageUrl) ||
    (typeof base.thumbnail_url === 'string' && base.thumbnail_url) ||
    (typeof base.thumbnailUrl === 'string' && base.thumbnailUrl) ||
    '';

  const category =
    (typeof base.category === 'string' && base.category) ||
    (typeof base.product_type === 'string' && base.product_type) ||
    (typeof base.productType === 'string' && base.productType) ||
    (base.subject &&
    typeof base.subject === 'object' &&
    !Array.isArray(base.subject) &&
    typeof base.subject.category === 'string'
      ? base.subject.category
      : '') ||
    '';

  const ingredientTokens = collectCandidateIngredientTokens(base);
  const skinTypeTags = collectCandidateSkinTypeTags(base);
  const socialRef = extractCandidateSocialReference(base);
  const price = extractCatalogCandidatePrice(base);

  const out = {
    product_id: String(productId || '').trim(),
    merchant_id: String(merchantId || '').trim() || null,
    ...(String(productGroupId || '').trim() ? { product_group_id: String(productGroupId).trim() } : {}),
    ...(String(skuId || '').trim() ? { sku_id: String(skuId).trim() } : {}),
    ...(String(brand || '').trim() ? { brand: String(brand).trim() } : {}),
    ...(String(name || '').trim() ? { name: String(name).trim() } : {}),
    ...(String(displayName || '').trim() ? { display_name: String(displayName).trim() } : {}),
    ...(String(imageUrl || '').trim() ? { image_url: String(imageUrl).trim() } : {}),
    ...(String(category || '').trim() ? { category: String(category).trim() } : {}),
    ...(price ? { price } : {}),
    ...(ingredientTokens.length ? { ingredient_tokens: ingredientTokens } : {}),
    ...(skinTypeTags.length ? { skin_type_tags: skinTypeTags } : {}),
    ...(socialRef.score != null ? { social_ref_score: Number(socialRef.score.toFixed(3)) } : {}),
    ...(socialRef.support_count != null ? { social_ref_support_count: Math.trunc(socialRef.support_count) } : {}),
    ...(socialRef.social_raw ? { social_raw: socialRef.social_raw } : {}),
  };

  const canonicalProductRef = normalizeCanonicalProductRef(
    {
      product_id: out.product_id,
      merchant_id: out.merchant_id,
    },
    { requireMerchant: true, allowOpaqueProductId: false },
  );
  if (canonicalProductRef) out.canonical_product_ref = canonicalProductRef;

  return out.product_id ? out : null;
}

const recoCatalogSearchSourceState = new Map();

function normalizeBaseUrlForRecoCatalogSearch(value) {
  const raw = String(value || '').trim();
  if (!raw) return '';
  return raw.replace(/\/+$/, '');
}

function buildRecoCatalogSearchBaseUrlCandidates({ includeLocalFallback = false } = {}) {
  const out = [];
  const seen = new Set();
  const add = (value) => {
    const normalized = normalizeBaseUrlForRecoCatalogSearch(value);
    if (!normalized) return;
    if (seen.has(normalized)) return;
    seen.add(normalized);
    out.push(normalized);
  };
  add(PIVOTA_BACKEND_BASE_URL);
  if (RECO_CATALOG_SEARCH_BASE_URLS) {
    const tokens = RECO_CATALOG_SEARCH_BASE_URLS
      .split(/[\s,;|]+/)
      .map((token) => token.trim())
      .filter(Boolean);
    for (const token of tokens) add(token);
  }
  if (includeLocalFallback) add(RECO_PDP_LOCAL_INVOKE_BASE_URL);
  return out;
}

function normalizeRecoCatalogSearchPath(value) {
  const raw = String(value || '').trim();
  if (!raw) return '';
  let path = raw;
  if (/^https?:\/\//i.test(path)) {
    try {
      const parsed = new URL(path);
      path = parsed.pathname || '';
    } catch (_) {
      return '';
    }
  }
  if (!path) return '';
  path = path.startsWith('/') ? path : `/${path}`;
  path = path.replace(/\/{2,}/g, '/');
  path = path.split('?')[0].split('#')[0];
  if (!path || path === '/') return '';
  return path.replace(/\/+$/, '') || '';
}

function buildRecoCatalogSearchPathCandidates() {
  const out = [];
  const seen = new Set();
  const genericPath = '/agent/v1/products/search';
  const beautyPath = '/agent/v1/beauty/products/search';
  const add = (value) => {
    const normalized = normalizeRecoCatalogSearchPath(value);
    if (!normalized) return;
    if (seen.has(normalized)) return;
    seen.add(normalized);
    out.push(normalized);
  };
  if (RECO_CATALOG_SEARCH_PATHS) {
    const tokens = RECO_CATALOG_SEARCH_PATHS
      .split(/[\s,;|]+/)
      .map((token) => token.trim())
      .filter(Boolean);
    for (const token of tokens) add(token);
  } else if (RECO_CATALOG_BEAUTY_ROUTE_FIRST_ENABLED) {
    add(beautyPath);
  }
  add(genericPath);
  if (RECO_CATALOG_BEAUTY_PATH_FALLBACK_ENABLED) add(beautyPath);

  if (RECO_CATALOG_BEAUTY_ROUTE_FIRST_ENABLED) {
    return [
      ...(out.includes(beautyPath) ? [beautyPath] : []),
      ...out.filter((item) => item !== beautyPath),
    ];
  }
  return [
    ...(out.includes(genericPath) ? [genericPath] : []),
    ...out.filter((item) => item !== genericPath),
  ];
}

function getRecoCatalogSearchSourceState(baseUrl) {
  const key = normalizeBaseUrlForRecoCatalogSearch(baseUrl);
  if (!key) return null;
  let state = recoCatalogSearchSourceState.get(key);
  if (!state) {
    state = {
      base_url: key,
      consecutive_empty: 0,
      consecutive_failures: 0,
      deprioritized_until_ms: 0,
      last_reason: null,
      last_success_at: 0,
      last_updated_at: 0,
    };
    recoCatalogSearchSourceState.set(key, state);
  }
  return state;
}

function markRecoCatalogSearchSourceSuccess(baseUrl, nowMs = Date.now()) {
  const state = getRecoCatalogSearchSourceState(baseUrl);
  if (!state) return;
  state.consecutive_empty = 0;
  state.consecutive_failures = 0;
  state.deprioritized_until_ms = 0;
  state.last_reason = null;
  state.last_success_at = nowMs;
  state.last_updated_at = nowMs;
}

function markRecoCatalogSearchSourceFailure(baseUrl, reason, nowMs = Date.now()) {
  const state = getRecoCatalogSearchSourceState(baseUrl);
  if (!state) return;
  const normalizedReason = String(reason || '').trim() || 'unknown';
  const isEmpty = normalizedReason === 'empty' || normalizedReason === 'not_found';
  if (isEmpty) {
    state.consecutive_empty = Number(state.consecutive_empty || 0) + 1;
    state.consecutive_failures = 0;
    if (state.consecutive_empty >= RECO_CATALOG_SOURCE_EMPTY_FAIL_THRESHOLD) {
      state.deprioritized_until_ms = nowMs + RECO_CATALOG_SOURCE_EMPTY_COOLDOWN_MS;
    }
  } else {
    state.consecutive_failures = Number(state.consecutive_failures || 0) + 1;
    state.consecutive_empty = 0;
  }
  state.last_reason = normalizedReason;
  state.last_updated_at = nowMs;
}

function getRecoCatalogSearchSourceHealthSnapshot(nowMs = Date.now()) {
  const out = [];
  for (const [baseUrl, raw] of recoCatalogSearchSourceState.entries()) {
    const state = raw && typeof raw === 'object' ? raw : {};
    const deprioritizedUntilMs = Number(state.deprioritized_until_ms || 0);
    out.push({
      base_url: baseUrl,
      consecutive_empty: Number(state.consecutive_empty || 0),
      consecutive_failures: Number(state.consecutive_failures || 0),
      deprioritized: deprioritizedUntilMs > nowMs,
      deprioritized_until_ms: deprioritizedUntilMs,
      last_reason: state.last_reason || null,
      last_success_at: Number(state.last_success_at || 0),
      last_updated_at: Number(state.last_updated_at || 0),
    });
  }
  out.sort((a, b) => String(a.base_url || '').localeCompare(String(b.base_url || '')));
  return out;
}

function rankRecoCatalogSearchBaseUrls(baseUrls, nowMs = Date.now()) {
  const normalized = Array.isArray(baseUrls) ? baseUrls.map((item) => normalizeBaseUrlForRecoCatalogSearch(item)).filter(Boolean) : [];
  if (!normalized.length) return [];
  return normalized
    .map((baseUrl, idx) => {
      const state = getRecoCatalogSearchSourceState(baseUrl) || {};
      const deprioritizedUntilMs = Number(state.deprioritized_until_ms || 0);
      const deprioritized = deprioritizedUntilMs > nowMs;
      const lastSuccessAt = Number(state.last_success_at || 0);
      return {
        base_url: baseUrl,
        idx,
        deprioritized,
        last_success_at: lastSuccessAt,
      };
    })
    .sort((a, b) => {
      if (a.deprioritized !== b.deprioritized) return a.deprioritized ? 1 : -1;
      if (a.last_success_at !== b.last_success_at) return b.last_success_at - a.last_success_at;
      return a.idx - b.idx;
    })
    .map((item) => item.base_url);
}

const recoCatalogFailFastState = {
  consecutive_failures: 0,
  open_until_ms: 0,
  last_reason: null,
  last_failed_at: 0,
  last_probe_started_at: 0,
};

const recoGuardrailCircuitStateByMode = new Map();

function normalizeRecoGuardMode(mode) {
  const token = String(mode || '').trim().toLowerCase();
  if (token === 'main_path' || token === 'sync_repair' || token === 'async_backfill') return token;
  return AURORA_BFF_RECO_GUARD_STRICT_DEFAULT_MODE ? 'main_path' : 'unknown';
}

function getRecoGuardrailCircuitState(mode) {
  const modeKey = normalizeRecoGuardMode(mode);
  let state = recoGuardrailCircuitStateByMode.get(modeKey);
  if (!state) {
    state = {
      mode: modeKey,
      consecutive_violations: 0,
      open_until_ms: 0,
      last_opened_at: 0,
      last_violation_at: 0,
      last_violations: [],
    };
    recoGuardrailCircuitStateByMode.set(modeKey, state);
  }
  return state;
}

function getRecoGuardrailCircuitSnapshot(mode, nowMs = Date.now()) {
  const state = getRecoGuardrailCircuitState(mode);
  const openUntil = Number(state.open_until_ms || 0);
  const open = Boolean(AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED && openUntil > nowMs);
  return {
    mode: state.mode,
    open,
    open_until_ms: open ? openUntil : 0,
    consecutive_violations: Number(state.consecutive_violations || 0),
    threshold: AURORA_BFF_RECO_GUARD_CIRCUIT_THRESHOLD,
    cooldown_ms: AURORA_BFF_RECO_GUARD_CIRCUIT_COOLDOWN_MS,
    last_opened_at: Number(state.last_opened_at || 0),
    last_violation_at: Number(state.last_violation_at || 0),
    last_violations: Array.isArray(state.last_violations) ? state.last_violations.slice(0, 8) : [],
  };
}

function markRecoGuardrailCircuitSuccess(mode) {
  const state = getRecoGuardrailCircuitState(mode);
  const nowMs = Date.now();
  if (Number(state.open_until_ms || 0) > nowMs) return;
  state.consecutive_violations = 0;
  state.last_violations = [];
}

function markRecoGuardrailCircuitViolation(mode, violations = [], nowMs = Date.now()) {
  const state = getRecoGuardrailCircuitState(mode);
  state.consecutive_violations = Number(state.consecutive_violations || 0) + 1;
  state.last_violation_at = nowMs;
  state.last_violations = uniqCaseInsensitiveStrings(
    Array.isArray(violations) ? violations : [],
    8,
  );
  let opened = false;
  if (
    AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED &&
    state.consecutive_violations >= AURORA_BFF_RECO_GUARD_CIRCUIT_THRESHOLD
  ) {
    state.open_until_ms = nowMs + AURORA_BFF_RECO_GUARD_CIRCUIT_COOLDOWN_MS;
    state.last_opened_at = nowMs;
    state.consecutive_violations = 0;
    opened = true;
  }
  return {
    opened,
    snapshot: getRecoGuardrailCircuitSnapshot(mode, nowMs),
  };
}

function getRecoCatalogFailFastSnapshot(nowMs = Date.now()) {
  const openUntilMs = Number(recoCatalogFailFastState.open_until_ms || 0);
  const open = RECO_CATALOG_FAIL_FAST_ENABLED && nowMs < openUntilMs;
  const lastProbeStartedAt = Number(recoCatalogFailFastState.last_probe_started_at || 0);
  const probeElapsedMs = Math.max(0, nowMs - lastProbeStartedAt);
  const nextProbeInMs = open ? Math.max(0, RECO_CATALOG_FAIL_FAST_PROBE_INTERVAL_MS - probeElapsedMs) : 0;
  const canProbeWhileOpen = open && nextProbeInMs <= 0;
  return {
    enabled: RECO_CATALOG_FAIL_FAST_ENABLED,
    open,
    open_until_ms: open ? openUntilMs : 0,
    consecutive_failures: Number(recoCatalogFailFastState.consecutive_failures || 0),
    last_reason: recoCatalogFailFastState.last_reason || null,
    cooldown_ms: RECO_CATALOG_FAIL_FAST_COOLDOWN_MS,
    threshold: RECO_CATALOG_FAIL_FAST_THRESHOLD,
    probe_interval_ms: RECO_CATALOG_FAIL_FAST_PROBE_INTERVAL_MS,
    last_probe_started_at: lastProbeStartedAt || 0,
    can_probe_while_open: canProbeWhileOpen,
    next_probe_in_ms: nextProbeInMs,
  };
}

function markRecoCatalogFailFastSuccess() {
  recoCatalogFailFastState.consecutive_failures = 0;
  recoCatalogFailFastState.open_until_ms = 0;
  recoCatalogFailFastState.last_reason = null;
  recoCatalogFailFastState.last_failed_at = 0;
  recoCatalogFailFastState.last_probe_started_at = 0;
}

function markRecoCatalogFailFastFailure(reason, nowMs = Date.now()) {
  if (!RECO_CATALOG_FAIL_FAST_ENABLED) return;
  recoCatalogFailFastState.consecutive_failures = Number(recoCatalogFailFastState.consecutive_failures || 0) + 1;
  recoCatalogFailFastState.last_reason = reason || 'unknown';
  recoCatalogFailFastState.last_failed_at = nowMs;
  if (recoCatalogFailFastState.consecutive_failures >= RECO_CATALOG_FAIL_FAST_THRESHOLD) {
    recoCatalogFailFastState.open_until_ms = nowMs + RECO_CATALOG_FAIL_FAST_COOLDOWN_MS;
    recoCatalogFailFastState.last_probe_started_at = nowMs;
  }
}

function beginRecoCatalogFailFastProbe(nowMs = Date.now()) {
  if (!RECO_CATALOG_FAIL_FAST_ENABLED) return false;
  const snapshot = getRecoCatalogFailFastSnapshot(nowMs);
  if (!snapshot.open || !snapshot.can_probe_while_open) return false;
  recoCatalogFailFastState.last_probe_started_at = nowMs;
  return true;
}

async function searchPivotaBackendProducts({
  query,
  limit = 6,
  logger,
  timeoutMs = RECO_CATALOG_SEARCH_TIMEOUT_MS,
  searchAllMerchants = true,
  deadlineMs = 0,
  forceLocalSearchFallback = false,
} = {}) {
  const startedAt = Date.now();
  const q = String(query || '').trim();
  if (!q) return { ok: false, products: [], reason: 'query_missing', latency_ms: 0 };
  const normalizedLimit = Math.max(1, Math.min(12, Number.isFinite(Number(limit)) ? Math.trunc(Number(limit)) : 6));
  const normalizedTimeout = Math.max(300, Math.min(12000, Number.isFinite(Number(timeoutMs)) ? Math.trunc(Number(timeoutMs)) : RECO_CATALOG_SEARCH_TIMEOUT_MS));
  const normalizedDeadlineMs = Number.isFinite(Number(deadlineMs)) ? Math.trunc(Number(deadlineMs)) : 0;
  const deadlineReserveMs = normalizedDeadlineMs > 0 ? 20 : 0;
  const effectiveDeadlineMs = normalizedDeadlineMs > 0 ? normalizedDeadlineMs : startedAt + normalizedTimeout;
  const getRemainingOverallMs = () => Math.max(0, effectiveDeadlineMs - Date.now());
  const hasOverallBudget = (minMs = 220) => getRemainingOverallMs() >= Math.max(40, Number(minMs) || 220);
  const useAllMerchants = searchAllMerchants === true;
  const params = {
    query: q,
    search_all_merchants: useAllMerchants,
    in_stock_only: false,
    limit: normalizedLimit,
    offset: 0,
    source: RECO_CATALOG_SEARCH_SOURCE,
  };
  const primaryBaseUrl = normalizeBaseUrlForRecoCatalogSearch(PIVOTA_BACKEND_BASE_URL);
  const localBaseUrl = normalizeBaseUrlForRecoCatalogSearch(RECO_PDP_LOCAL_INVOKE_BASE_URL);
  const forceLocalFallbackEnabled = forceLocalSearchFallback === true;
  const localSearchFallbackConfigured =
    (
      forceLocalFallbackEnabled ||
      (
        RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
        RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED
      )
    ) &&
    localBaseUrl &&
    localBaseUrl !== primaryBaseUrl;
  const shouldAttemptLocalSearchFallback =
    localSearchFallbackConfigured &&
    (forceLocalFallbackEnabled || RECO_PDP_LOCAL_SEARCH_FALLBACK_ON_TRANSIENT);
  const baseUrlCandidates = buildRecoCatalogSearchBaseUrlCandidates({
    includeLocalFallback: shouldAttemptLocalSearchFallback,
  });
  const pathCandidates = buildRecoCatalogSearchPathCandidates();
  if (!baseUrlCandidates.length) {
    return { ok: false, products: [], reason: 'pivota_backend_not_configured', latency_ms: 0 };
  }
  const mapSearchFailureReason = ({ statusCode, errCode, errMessage } = {}) => {
    const code = typeof errCode === 'string' ? errCode.trim().toUpperCase() : '';
    const msg = typeof errMessage === 'string' ? errMessage : '';
    const timeoutHit = code === 'ECONNABORTED' || /timeout/i.test(msg);
    let reason = 'upstream_error';
    if (timeoutHit || statusCode === 504 || statusCode === 408) reason = 'upstream_timeout';
    else if (statusCode === 404) reason = 'not_found';
    else if (statusCode === 429) reason = 'rate_limited';
    return reason;
  };
  const mapProxySearchFallbackReason = (raw) => {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) return null;
    if (
      token === 'upstream_timeout' ||
      token === 'timeout' ||
      token === 'primary_timeout' ||
      token === 'invoke_timeout'
    ) {
      return 'upstream_timeout';
    }
    if (token === 'rate_limited' || token === 'too_many_requests' || token === 'throttled') {
      return 'rate_limited';
    }
    if (
      token === 'upstream_error' ||
      token === 'primary_exception' ||
      token === 'primary_request_failed' ||
      token === 'primary_status_5xx' ||
      token === 'error_soft_fallback' ||
      token === 'db_timeout' ||
      token === 'db_error'
    ) {
      return 'upstream_error';
    }
    if (token === 'not_found' || token === 'no_candidates' || token === 'no_results') {
      return 'not_found';
    }
    return null;
  };
  const inferSearchFailureReasonFromBody = ({ data, statusCode } = {}) => {
    const body = data && typeof data === 'object' && !Array.isArray(data) ? data : null;
    if (!body) return null;
    const metadata =
      body.metadata && typeof body.metadata === 'object' && !Array.isArray(body.metadata) ? body.metadata : null;
    const proxyFallback =
      metadata &&
      metadata.proxy_search_fallback &&
      typeof metadata.proxy_search_fallback === 'object' &&
      !Array.isArray(metadata.proxy_search_fallback)
        ? metadata.proxy_search_fallback
        : null;

    const fallbackReason = mapProxySearchFallbackReason(proxyFallback && proxyFallback.reason);
    if (fallbackReason === 'upstream_timeout' || fallbackReason === 'upstream_error' || fallbackReason === 'rate_limited') {
      return fallbackReason;
    }

    const resolveReason = mapProxySearchFallbackReason(
      body.reason_code ||
      body.reasonCode ||
      metadata?.reason_code ||
      metadata?.reasonCode ||
      metadata?.resolve_reason_code ||
      metadata?.resolveReasonCode,
    );
    if (resolveReason === 'upstream_timeout' || resolveReason === 'upstream_error' || resolveReason === 'rate_limited') {
      return resolveReason;
    }
    if (resolveReason === 'not_found') return 'not_found';

    const upstreamStatus = Number(
      proxyFallback?.upstream_status ??
      proxyFallback?.upstreamStatus ??
      metadata?.upstream_status ??
      metadata?.upstreamStatus ??
      statusCode ??
      0,
    );
    if (Number.isFinite(upstreamStatus)) {
      if (upstreamStatus === 429) return 'rate_limited';
      if (upstreamStatus === 408 || upstreamStatus === 504) return 'upstream_timeout';
      if (upstreamStatus >= 500) return 'upstream_error';
    }

    const upstreamErrorCode = String(
      proxyFallback?.upstream_error_code ||
      proxyFallback?.upstreamErrorCode ||
      metadata?.upstream_error_code ||
      metadata?.upstreamErrorCode ||
      '',
    )
      .trim()
      .toUpperCase();
    if (upstreamErrorCode === 'ECONNABORTED' || upstreamErrorCode === 'ETIMEDOUT') {
      return 'upstream_timeout';
    }

    const upstreamErrorMessage = String(
      proxyFallback?.upstream_error_message ||
      proxyFallback?.upstreamErrorMessage ||
      metadata?.upstream_error_message ||
      metadata?.upstreamErrorMessage ||
      '',
    ).trim();
    if (/timeout/i.test(upstreamErrorMessage)) return 'upstream_timeout';
    return null;
  };
  const normalizeProductsFromSearchData = (data) => {
    const rawList = extractAgentProductsFromSearchResponse(data);
    return rawList.map((p) => normalizeRecoCatalogProduct(p)).filter(Boolean);
  };
  const normalizeAttemptTimeout = (index) => {
    const baseTimeout = index <= 0 || !RECO_CATALOG_MULTI_SOURCE_ENABLED
      ? normalizedTimeout
      : Math.max(260, Math.min(normalizedTimeout, Math.trunc(normalizedTimeout * 0.66)));
    const remaining = getRemainingOverallMs();
    const capped = Math.min(baseTimeout, Math.max(0, remaining - deadlineReserveMs));
    return Math.max(0, capped);
  };
  const shouldTrySecondaryReason = (reason) => {
    const token = String(reason || '').trim().toLowerCase();
    if (!token) return false;
    if (token === 'upstream_timeout' || token === 'upstream_error' || token === 'rate_limited') {
      return RECO_CATALOG_MULTI_SOURCE_ENABLED && (
        !shouldAttemptLocalSearchFallback ||
        RECO_PDP_LOCAL_SEARCH_FALLBACK_ON_TRANSIENT ||
        baseUrlCandidates.length > 1
      );
    }
    if (token === 'empty' || token === 'not_found') {
      return RECO_CATALOG_MULTI_SOURCE_ENABLED && RECO_CATALOG_MULTI_SOURCE_ON_EMPTY;
    }
    return false;
  };
  const shouldTrySecondaryPathReason = (reason) => {
    const token = String(reason || '').trim().toLowerCase();
    if (!token) return false;
    if (token === 'not_found') return true;
    if (token === 'upstream_timeout' || token === 'upstream_error' || token === 'rate_limited') return false;
    if (token === 'empty') return RECO_CATALOG_MULTI_SOURCE_ON_EMPTY;
    return false;
  };
  const runSearchAttemptByBase = async (baseUrl, timeoutForAttemptMs) => {
    const normalizedBase = normalizeBaseUrlForRecoCatalogSearch(baseUrl);
    const normalizedPaths = Array.isArray(pathCandidates) && pathCandidates.length
      ? pathCandidates
      : ['/agent/v1/products/search'];
    const pathAttempts = [];
    let lastFailure = null;
    let lastEmpty = null;
    if (!hasOverallBudget(180) || timeoutForAttemptMs < 180) {
      return {
        ok: false,
        products: [],
        reason: 'budget_exhausted',
        source_base_url: normalizedBase,
        source_endpoint: `${normalizedBase}${normalizedPaths[0] || '/agent/v1/products/search'}`,
        source_path: normalizedPaths[0] || '/agent/v1/products/search',
        attempted_endpoints: [],
        source_path_failover: false,
        latency_ms: Date.now() - startedAt,
      };
    }
    const perBaseStartedAt = Date.now();
    for (let pathIdx = 0; pathIdx < normalizedPaths.length; pathIdx += 1) {
      const pathToken = normalizeRecoCatalogSearchPath(normalizedPaths[pathIdx]) || '/agent/v1/products/search';
      const endpoint = `${normalizedBase}${pathToken}`;
      const isLocalInvokeBase = localBaseUrl && normalizedBase === localBaseUrl;
      if (!hasOverallBudget(150)) {
        const exhausted = {
          ok: false,
          products: [],
          reason: 'budget_exhausted',
          source_base_url: normalizedBase,
          source_endpoint: endpoint,
          source_path: pathToken,
          latency_ms: Date.now() - startedAt,
        };
        return {
          ...exhausted,
          attempted_endpoints: pathAttempts.map((item) => item.endpoint),
          source_path_failover: pathAttempts.length > 1,
        };
      }
      const elapsedMs = Date.now() - perBaseStartedAt;
      const remainingBudgetMs = Math.max(0, timeoutForAttemptMs - elapsedMs);
      const remainingOverallMs = getRemainingOverallMs();
      const requestBudgetMs = Math.max(
        0,
        Math.min(
          remainingBudgetMs,
          Math.max(0, remainingOverallMs - deadlineReserveMs),
        ),
      );
      if (requestBudgetMs < 120) {
        const exhausted = {
          ok: false,
          products: [],
          reason: 'budget_exhausted',
          source_base_url: normalizedBase,
          source_endpoint: endpoint,
          source_path: pathToken,
          latency_ms: Date.now() - startedAt,
        };
        return {
          ...exhausted,
          attempted_endpoints: pathAttempts.map((item) => item.endpoint),
          source_path_failover: pathAttempts.length > 1,
        };
      }
      try {
        const resp = await axios.get(endpoint, {
          params,
          headers: isLocalInvokeBase ? { 'Content-Type': 'application/json' } : buildPivotaBackendAgentHeaders(),
          timeout: isLocalInvokeBase
            ? Math.max(120, Math.min(RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS, requestBudgetMs))
            : Math.max(120, requestBudgetMs),
          validateStatus: () => true,
        });
        const statusCode = Number.isFinite(Number(resp?.status)) ? Math.trunc(Number(resp.status)) : null;
        if (!statusCode || statusCode < 200 || statusCode >= 300) {
          const reason = mapSearchFailureReason({ statusCode, errCode: null, errMessage: null });
          const failed = {
            ok: false,
            products: [],
            reason,
            status_code: statusCode,
            source_base_url: normalizedBase,
            source_endpoint: endpoint,
            source_path: pathToken,
            latency_ms: Date.now() - startedAt,
          };
          pathAttempts.push({
            endpoint,
            path: pathToken,
            ok: false,
            reason,
            status_code: statusCode,
            products: 0,
          });
          lastFailure = failed;
          const shouldTryNextPath =
            pathIdx < normalizedPaths.length - 1 &&
            shouldTrySecondaryPathReason(reason) &&
            hasOverallBudget(150);
          if (shouldTryNextPath) continue;
          return {
            ...failed,
            attempted_endpoints: pathAttempts.map((item) => item.endpoint),
            source_path_failover: pathAttempts.length > 1,
          };
        }

        const body = resp && resp.data ? resp.data : null;
        const products = normalizeProductsFromSearchData(body);
        const bodyReason = products.length
          ? null
          : inferSearchFailureReasonFromBody({ data: body, statusCode });
        if (bodyReason && bodyReason !== 'not_found') {
          const failed = {
            ok: false,
            products: [],
            reason: bodyReason,
            status_code: statusCode,
            source_base_url: normalizedBase,
            source_endpoint: endpoint,
            source_path: pathToken,
            latency_ms: Date.now() - startedAt,
          };
          pathAttempts.push({
            endpoint,
            path: pathToken,
            ok: false,
            reason: bodyReason,
            status_code: statusCode,
            products: 0,
          });
          lastFailure = failed;
          const shouldTryNextPath =
            pathIdx < normalizedPaths.length - 1 &&
            shouldTrySecondaryPathReason(bodyReason) &&
            hasOverallBudget(150);
          if (shouldTryNextPath) continue;
          return {
            ...failed,
            attempted_endpoints: pathAttempts.map((item) => item.endpoint),
            source_path_failover: pathAttempts.length > 1,
          };
        }
        const result = {
          ok: true,
          products,
          reason: products.length ? null : bodyReason || 'empty',
          status_code: statusCode,
          source_base_url: normalizedBase,
          source_endpoint: endpoint,
          source_path: pathToken,
          latency_ms: Date.now() - startedAt,
        };
        pathAttempts.push({
          endpoint,
          path: pathToken,
          ok: true,
          reason: result.reason || null,
          status_code: statusCode,
          products: products.length,
        });
        if (products.length > 0) {
          return {
            ...result,
            attempted_endpoints: pathAttempts.map((item) => item.endpoint),
            source_path_failover: pathAttempts.length > 1,
          };
        }
        lastEmpty = result;
        const shouldTryNextPath =
          pathIdx < normalizedPaths.length - 1 &&
          shouldTrySecondaryPathReason(result.reason || 'empty') &&
          hasOverallBudget(150);
        if (shouldTryNextPath) continue;
        return {
          ...result,
          attempted_endpoints: pathAttempts.map((item) => item.endpoint),
          source_path_failover: pathAttempts.length > 1,
        };
      } catch (err) {
        const statusCode = Number.isFinite(Number(err?.response?.status)) ? Math.trunc(Number(err.response.status)) : null;
        const errCode = typeof err?.code === 'string' ? err.code.trim().toUpperCase() : '';
        const errMessage = err && err.message ? err.message : String(err);
        const reason = mapSearchFailureReason({ statusCode, errCode, errMessage });
        const failed = {
          ok: false,
          products: [],
          reason,
          status_code: statusCode,
          error_code: errCode || null,
          source_base_url: normalizedBase,
          source_endpoint: endpoint,
          source_path: pathToken,
          latency_ms: Date.now() - startedAt,
          err: errMessage,
        };
        pathAttempts.push({
          endpoint,
          path: pathToken,
          ok: false,
          reason,
          status_code: statusCode,
          products: 0,
        });
        lastFailure = failed;
        const shouldTryNextPath =
          pathIdx < normalizedPaths.length - 1 &&
          shouldTrySecondaryPathReason(reason) &&
          hasOverallBudget(150);
        if (shouldTryNextPath) continue;
        return {
          ...failed,
          attempted_endpoints: pathAttempts.map((item) => item.endpoint),
          source_path_failover: pathAttempts.length > 1,
        };
      }
    }
    if (lastEmpty) {
      return {
        ...lastEmpty,
        attempted_endpoints: pathAttempts.map((item) => item.endpoint),
        source_path_failover: pathAttempts.length > 1,
      };
    }
    if (lastFailure) {
      return {
        ...lastFailure,
        attempted_endpoints: pathAttempts.map((item) => item.endpoint),
        source_path_failover: pathAttempts.length > 1,
      };
    }
    return {
      ok: false,
      products: [],
      reason: 'upstream_error',
      source_base_url: normalizedBase,
      source_endpoint: `${normalizedBase}${normalizedPaths[0] || '/agent/v1/products/search'}`,
      source_path: normalizedPaths[0] || '/agent/v1/products/search',
      attempted_endpoints: pathAttempts.map((item) => item.endpoint),
      source_path_failover: pathAttempts.length > 1,
      latency_ms: Date.now() - startedAt,
    };
  };

  const nowMs = Date.now();
  const orderedBaseUrls = RECO_CATALOG_MULTI_SOURCE_ENABLED
    ? rankRecoCatalogSearchBaseUrls(baseUrlCandidates, nowMs)
    : baseUrlCandidates.slice(0, 1);
  const attempts = [];
  let finalFailure = null;
  let finalEmpty = null;
  const collectAttemptedEndpoints = () =>
    attempts.flatMap((item) => {
      if (Array.isArray(item.attempted_endpoints) && item.attempted_endpoints.length) {
        return item.attempted_endpoints;
      }
      return item.endpoint ? [item.endpoint] : [];
    });

  for (let idx = 0; idx < orderedBaseUrls.length; idx += 1) {
    if (!hasOverallBudget(180)) {
      finalFailure = {
        ok: false,
        products: [],
        reason: 'budget_exhausted',
        latency_ms: Date.now() - startedAt,
      };
      break;
    }
    const baseUrl = orderedBaseUrls[idx];
    const timeoutForAttemptMs = normalizeAttemptTimeout(idx);
    if (timeoutForAttemptMs < 120) {
      finalFailure = {
        ok: false,
        products: [],
        reason: 'budget_exhausted',
        source_base_url: baseUrl,
        latency_ms: Date.now() - startedAt,
      };
      break;
    }
    const attempt = await runSearchAttemptByBase(baseUrl, timeoutForAttemptMs);
    attempts.push({
      base_url: baseUrl,
      endpoint: attempt.source_endpoint || null,
      path: attempt.source_path || null,
      attempted_endpoints: Array.isArray(attempt.attempted_endpoints)
        ? attempt.attempted_endpoints.slice()
        : [],
      reason: attempt.reason || null,
      ok: Boolean(attempt.ok),
      products: Array.isArray(attempt.products) ? attempt.products.length : 0,
      status_code: Number.isFinite(Number(attempt.status_code)) ? Math.trunc(Number(attempt.status_code)) : null,
    });

    if (attempt.ok && Array.isArray(attempt.products) && attempt.products.length > 0) {
      markRecoCatalogSearchSourceSuccess(baseUrl, Date.now());
      if (idx > 0) {
        logger?.warn(
              {
                query: q.slice(0, 120),
                source_base_url: baseUrl,
                attempted_sources: attempts.map((item) => item.base_url),
                attempted_endpoints: collectAttemptedEndpoints(),
                source_failover: true,
              },
              'aurora bff: reco catalog search source failover hit',
            );
      }
      return {
        ...attempt,
        attempted_sources: attempts.map((item) => item.base_url),
        attempted_endpoints: collectAttemptedEndpoints(),
        source_failover: idx > 0,
      };
    }

    const failureReason = String(attempt.reason || '').trim().toLowerCase() || 'unknown';
    markRecoCatalogSearchSourceFailure(baseUrl, failureReason, Date.now());

    if (attempt.ok) {
      finalEmpty = attempt;
    } else {
      finalFailure = attempt;
      logger?.warn(
        {
          query: q.slice(0, 120),
          source_base_url: baseUrl,
          source_endpoint: attempt.source_endpoint || null,
          source_path: attempt.source_path || null,
          reason: failureReason,
          status_code: attempt.status_code || null,
          code: attempt.error_code || null,
          err: attempt.err || null,
        },
        'aurora bff: reco catalog source search failed',
      );
    }

    const shouldTryNext =
      idx < orderedBaseUrls.length - 1 &&
      shouldTrySecondaryReason(failureReason) &&
      hasOverallBudget(150);
    if (!shouldTryNext) break;
  }

  if (finalEmpty) {
    return {
      ok: true,
      products: [],
      reason: String(finalEmpty.reason || 'empty'),
      status_code: finalEmpty.status_code || null,
      source_base_url: finalEmpty.source_base_url || null,
      source_endpoint: finalEmpty.source_endpoint || null,
      attempted_sources: attempts.map((item) => item.base_url),
      attempted_endpoints: collectAttemptedEndpoints(),
      source_failover: attempts.length > 1,
      latency_ms: Date.now() - startedAt,
    };
  }

  if (finalFailure) {
    return {
      ok: false,
      products: [],
      reason: String(finalFailure.reason || 'upstream_error'),
      status_code: finalFailure.status_code || null,
      error_code: finalFailure.error_code || null,
      source_base_url: finalFailure.source_base_url || null,
      source_endpoint: finalFailure.source_endpoint || null,
      attempted_sources: attempts.map((item) => item.base_url),
      attempted_endpoints: collectAttemptedEndpoints(),
      source_failover: attempts.length > 1,
      latency_ms: Date.now() - startedAt,
    };
  }

  return {
    ok: false,
    products: [],
    reason: 'upstream_error',
    attempted_sources: attempts.map((item) => item.base_url),
    attempted_endpoints: collectAttemptedEndpoints(),
    source_failover: attempts.length > 1,
    latency_ms: Date.now() - startedAt,
  };
}

const CATALOG_BRANDS = {
  brand_winona: {
    brand_id: 'brand_winona',
    aliases: ['', 'winona', 'wei nuo na'],
    name: { CN: '', EN: 'Winona' },
  },
  brand_ipsa: {
    brand_id: 'brand_ipsa',
    aliases: ['', 'ipsa', 'i p s a'],
    name: { CN: '', EN: 'IPSA' },
  },
};

const recoPdpFallbackMetrics = {
  external_fallback_blocked_total: 0,
  pdp_internal_retry_attempt_total: 0,
  pdp_external_fallback_total_by_reason: Object.create(null),
};

function recordRecoPdpExternalFallbackBlocked(delta = 1) {
  const n = Number.isFinite(Number(delta)) ? Math.max(0, Math.trunc(Number(delta))) : 0;
  if (!n) return;
  recoPdpFallbackMetrics.external_fallback_blocked_total += n;
}

function recordRecoPdpInternalRetryAttempt(delta = 1) {
  const n = Number.isFinite(Number(delta)) ? Math.max(0, Math.trunc(Number(delta))) : 0;
  if (!n) return;
  recoPdpFallbackMetrics.pdp_internal_retry_attempt_total += n;
}

function recordRecoPdpExternalFallback(reasonCode, delta = 1) {
  const n = Number.isFinite(Number(delta)) ? Math.max(0, Math.trunc(Number(delta))) : 0;
  if (!n) return;
  const reason = normalizeResolveReasonCode(reasonCode || '', 'no_candidates');
  recoPdpFallbackMetrics.pdp_external_fallback_total_by_reason[reason] =
    Number(recoPdpFallbackMetrics.pdp_external_fallback_total_by_reason[reason] || 0) + n;
}

function renderRecoPdpFallbackMetricsPrometheus() {
  const lines = [
    '# HELP external_fallback_blocked_total Number of fast external fallback attempts blocked by policy.',
    '# TYPE external_fallback_blocked_total counter',
    `external_fallback_blocked_total ${Number(recoPdpFallbackMetrics.external_fallback_blocked_total || 0)}`,
    '# HELP pdp_internal_retry_attempt_total Number of internal resolve retry attempts for PDP open.',
    '# TYPE pdp_internal_retry_attempt_total counter',
    `pdp_internal_retry_attempt_total ${Number(recoPdpFallbackMetrics.pdp_internal_retry_attempt_total || 0)}`,
    '# HELP pdp_external_fallback_total Number of PDP external fallbacks by reason code.',
    '# TYPE pdp_external_fallback_total counter',
  ];
  const reasonCounts = recoPdpFallbackMetrics.pdp_external_fallback_total_by_reason || {};
  const reasonCodes = Object.keys(reasonCounts).sort();
  if (!reasonCodes.length) {
    lines.push('pdp_external_fallback_total{reason_code="none"} 0');
  } else {
    for (const reasonCode of reasonCodes) {
      const count = Number(reasonCounts[reasonCode] || 0);
      lines.push(`pdp_external_fallback_total{reason_code="${String(reasonCode)}"} ${count}`);
    }
  }
  return `${lines.join('\n')}\n`;
}

function escapeRegExp(text) {
  return String(text || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function buildLooseAsciiAliasRegex(alias) {
  const tokens = String(alias || '')
    .trim()
    .toLowerCase()
    .split(/\s+/)
    .map((t) => t.trim())
    .filter(Boolean)
    .slice(0, 6);
  if (!tokens.length) return null;
  const sep = '(?:[\\s\\p{P}_-])*';
  const body = tokens.map((t) => escapeRegExp(t)).join(sep);
  return new RegExp(`(?<![a-z0-9])${body}(?![a-z0-9])`, 'iu');
}

function messageHasAvailabilityHint(text) {
  const raw = String(text || '').trim();
  if (!raw) return false;
  return (
    /(|||||||||||||||||||\?)/.test(raw) ||
    /\b(in stock|available|availability|where (can i|to) buy|do you have|have any|buy|purchase|link)\b/i.test(raw) ||
    /^[^\n]{1,80}(|||[a-z0-9%+\-/]{2,})[^\n]{0,12}(||||\?)$/iu.test(raw)
  );
}

function stripGenericAvailabilityTokens(value) {
  return String(value || '')
    .replace(
      /(||||||||||||||||||||||)/gi,
      ' ',
    )
    .replace(/\b(do you have|have any|where can i buy|where to buy|in stock|available|availability|buy|purchase|link|products?|items?|catalog|store|shop)\b/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function detectBrandAvailabilityIntent(message, lang) {
  const raw = String(message || '').trim();
  if (!raw) return null;

  // Exclude obvious non-commerce asks.
  if (looksLikeDiagnosisStart(raw)) return null;
  if (looksLikeSuitabilityRequest(raw)) return null;
  if (looksLikeRecommendationRequest(raw)) return null;
  if (looksLikeRoutineRequest(raw, null)) return null;
  if (looksLikeCompatibilityOrConflictQuestion(raw)) return null;
  if (looksLikeWeatherOrEnvironmentQuestion(raw)) return null;

  const text = raw.normalize('NFKC');
  const lowered = text.toLowerCase();

  const availabilityHint = messageHasAvailabilityHint(text);

  for (const brand of Object.values(CATALOG_BRANDS)) {
    const aliases = Array.isArray(brand.aliases) ? brand.aliases : [];
    let matchedAlias = '';
    for (const alias of aliases) {
      const a = String(alias || '').trim();
      if (!a) continue;
      if (/[\u4e00-\u9fff]/.test(a)) {
        if (text.includes(a)) {
          matchedAlias = a;
          break;
        }
        continue;
      }

      const re = buildLooseAsciiAliasRegex(a);
      if (re && re.test(lowered)) {
        matchedAlias = a;
        break;
      }
    }

    if (!matchedAlias) continue;

    const compact = (value) =>
      String(value || '')
        .toLowerCase()
        .replace(/[\s\p{P}_-]+/gu, '');
    const compactAlias = compact(matchedAlias);
    const compactText = compact(text);
    const bareBrandQuery =
      compactText === compactAlias ||
      compactText === `${compactAlias}` ||
      compactText === `${compactAlias}brand` ||
      compactText === `${compactAlias}${compactAlias}`;
    if (!availabilityHint && !bareBrandQuery) continue;

    const brandName = lang === 'CN' ? brand?.name?.CN || '' : brand?.name?.EN || '';
    return {
      intent: 'availability',
      brand_id: brand.brand_id,
      brand_name: brandName || String(matchedAlias || '').trim(),
      matched_alias: matchedAlias,
      reason: availabilityHint ? 'availability_hint' : 'bare_brand_query',
    };
  }

  return null;
}

function detectCatalogAvailabilityIntent(message, lang) {
  const knownBrandIntent = detectBrandAvailabilityIntent(message, lang);
  if (knownBrandIntent) return knownBrandIntent;

  const raw = String(message || '').trim();
  if (!raw) return null;

  if (looksLikeDiagnosisStart(raw)) return null;
  if (looksLikeSuitabilityRequest(raw)) return null;
  if (looksLikeRecommendationRequest(raw)) return null;
  if (looksLikeRoutineRequest(raw, null)) return null;
  if (looksLikeCompatibilityOrConflictQuestion(raw)) return null;
  if (looksLikeWeatherOrEnvironmentQuestion(raw)) return null;

  if (!messageHasAvailabilityHint(raw)) return null;

  const availabilityQuery = buildAvailabilityCatalogQuery(raw, null);
  const genericTarget = stripGenericAvailabilityTokens(availabilityQuery);
  const compactTarget = genericTarget.toLowerCase().replace(/[\s\p{P}_-]+/gu, '');
  if (!compactTarget || compactTarget.length < 3) return null;

  const isLangCn = String(lang || '').toUpperCase() === 'CN';
  const displayName = genericTarget || availabilityQuery || (isLangCn ? '' : 'Target product');
  return {
    intent: 'availability',
    brand_id: 'brand_generic',
    brand_name: displayName.slice(0, 120),
    matched_alias: '',
    reason: 'availability_hint_generic',
    query_hint: availabilityQuery || displayName,
  };
}

function buildAvailabilityCatalogQuery(message, availabilityIntent) {
  const raw = String(message || '')
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/[!?]+$/g, '');
  const brand = String(
    availabilityIntent?.brand_name || availabilityIntent?.matched_alias || availabilityIntent?.brand_id || '',
  ).trim();
  if (!raw) return brand;

  let cleaned = raw
    .replace(/^(|||||could you|can you|do you|i want to know)\s*/i, '')
    .replace(/\b(in stock|available|availability|where can i buy|where to buy|do you have|have any|buy|purchase|link|have|has)\b/gi, ' ')
    .replace(/(|||||||||||||||||)/g, ' ')
    .replace(/[(]\s*(|brand|official)\s*[)]/gi, ' ')
    .replace(/\bbrand\b/gi, ' ')
    .replace(//g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/[!?]+$/g, '');

  if (!cleaned) cleaned = raw;
  cleaned = cleaned
    .split(/\s+/)
    .filter((token, idx, arr) => idx === 0 || token.toLowerCase() !== arr[idx - 1].toLowerCase())
    .join(' ')
    .trim();
  cleaned = cleaned.replace(/[]+$/g, '').trim();

  if (brand) {
    const compact = (value) =>
      String(value || '')
        .toLowerCase()
        .replace(/[\s\p{P}_-]+/gu, '');
    const compactBrand = compact(brand);
    const compactCleaned = compact(cleaned);
    if (compactBrand && compactCleaned && compactCleaned === compactBrand.repeat(2)) cleaned = brand;
  }

  if (cleaned.length > 120) cleaned = cleaned.slice(0, 120).trim();

  if (!cleaned) return brand;
  if (brand && cleaned.toLowerCase() === brand.toLowerCase()) return brand;
  return cleaned;
}

function isSpecificAvailabilityQuery(queryText, availabilityIntent) {
  const q = String(queryText || '').trim().toLowerCase();
  if (!q) return false;
  const brandId = String(availabilityIntent?.brand_id || '').trim().toLowerCase();
  const brand = String(
    availabilityIntent?.brand_name || availabilityIntent?.matched_alias || availabilityIntent?.brand_id || '',
  )
    .trim()
    .toLowerCase();
  const compact = (value) =>
    String(value || '')
      .toLowerCase()
      .replace(/[\s\p{P}_-]+/gu, '');

  if (brandId === 'brand_generic') {
    const genericOnly = compact(
      q
        .replace(
          /(|||||||||||||||||||||products?|items?|catalog|store|shop|buy|available|availability|in\s*stock)/gi,
          ' ',
        )
        .replace(/\b(do you have|have any|where can i buy|where to buy)\b/gi, ' '),
    );
    if (!genericOnly) return false;
    const tokenCount = String(q)
      .split(/\s+/)
      .map((t) => t.trim())
      .filter(Boolean).length;
    // For generic-intent routing, keep multi-token/product-pattern queries on the specific path.
    if (/[0-9%+]/.test(q) && genericOnly.length >= 5) return true;
    if (tokenCount >= 3 && genericOnly.length >= 8) return true;
    return genericOnly.length >= 12;
  }

  if (!brand) return compact(q).length >= 8;
  const qCompact = compact(q);
  const brandCompact = compact(brand);
  if (!qCompact || !brandCompact) return false;
  if (qCompact === brandCompact) return false;

  const genericOnly = compact(
    q
      .replace(
        /(|||||||||||||||||||||products?|items?|catalog|store|shop|buy|available|availability|in\s*stock)/gi,
        ' ',
      )
      .replace(/\b(do you have|have any|where can i buy|where to buy)\b/gi, ' '),
  );
  if (!genericOnly) return false;
  if (genericOnly === brandCompact) return false;
  return genericOnly.length > brandCompact.length + 2;
}

function buildAvailabilityResolvedProduct({
  resolvedRef,
  resolveBody,
  fallbackQuery = '',
  fallbackBrand = '',
} = {}) {
  const normalizedRef = normalizeCanonicalProductRef(resolvedRef, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (!normalizedRef) return null;

  const firstCandidate =
    Array.isArray(resolveBody?.candidates) &&
    resolveBody.candidates.length &&
    resolveBody.candidates[0] &&
    typeof resolveBody.candidates[0] === 'object'
      ? resolveBody.candidates[0]
      : null;
  const normalizedCandidate = normalizeRecoCatalogProduct(firstCandidate);
  const displayName = pickFirstTrimmed(
    normalizedCandidate?.display_name,
    normalizedCandidate?.name,
    firstCandidate?.title,
    firstCandidate?.name,
    fallbackQuery,
  );
  const name = pickFirstTrimmed(normalizedCandidate?.name, firstCandidate?.title, displayName);
  const brand = pickFirstTrimmed(
    normalizedCandidate?.brand,
    firstCandidate?.vendor,
    firstCandidate?.brand,
    fallbackBrand,
  );
  const imageUrl = pickFirstTrimmed(
    normalizedCandidate?.image_url,
    firstCandidate?.image_url,
    firstCandidate?.thumbnail_url,
  );
  return {
    ...(normalizedCandidate && typeof normalizedCandidate === 'object' ? normalizedCandidate : {}),
    product_id: normalizedRef.product_id,
    merchant_id: normalizedRef.merchant_id,
    canonical_product_ref: normalizedRef,
    ...(brand ? { brand } : {}),
    ...(name ? { name } : {}),
    ...(displayName ? { display_name: displayName } : {}),
    ...(imageUrl ? { image_url: imageUrl } : {}),
  };
}

async function resolveAvailabilityProductByQuery({
  query,
  lang = 'en',
  hints = null,
  logger,
  timeoutMs = CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
} = {}) {
  const q = String(query || '').trim();
  if (!q) return { ok: false, reason: 'query_missing', product: null, resolve_reason_code: 'no_candidates', latency_ms: 0 };
  if (!PIVOTA_BACKEND_BASE_URL) {
    return { ok: false, reason: 'pivota_backend_not_configured', product: null, resolve_reason_code: 'db_error', latency_ms: 0 };
  }

  const startedAt = Date.now();
  const resolveTimeoutMs = Math.max(
    250,
    Math.min(
      CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
      Number.isFinite(Number(timeoutMs)) ? Math.trunc(Number(timeoutMs)) : CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
    ),
  );
  const url = `${PIVOTA_BACKEND_BASE_URL}/agent/v1/products/resolve`;
  const payload = {
    query: q,
    lang: String(lang || 'en').toLowerCase() === 'cn' ? 'zh' : 'en',
    options: {
      search_all_merchants: true,
      timeout_ms: resolveTimeoutMs,
      upstream_retries: 0,
      stable_alias_short_circuit: true,
      allow_stable_alias_for_uuid: true,
    },
    ...(hints && typeof hints === 'object' && !Array.isArray(hints) ? { hints } : {}),
    caller: 'aurora_chatbox',
  };

  let resp = null;
  let err = null;
  try {
    resp = await axios.post(url, payload, {
      headers: buildPivotaBackendAgentHeaders(),
      timeout: resolveTimeoutMs,
      validateStatus: () => true,
    });
  } catch (e) {
    err = e;
  }

  const body = resp && typeof resp.data === 'object' ? resp.data : null;
  const statusCode = Number.isFinite(Number(resp?.status)) ? Math.trunc(Number(resp.status)) : 0;
  const resolvedRef = normalizeCanonicalProductRef(body?.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (statusCode === 200 && body?.resolved === true && resolvedRef) {
    const product = buildAvailabilityResolvedProduct({
      resolvedRef,
      resolveBody: body,
      fallbackQuery: q,
      fallbackBrand: hints && typeof hints === 'object' ? hints.brand : '',
    });
    return {
      ok: true,
      reason: null,
      product,
      resolve_reason_code: null,
      status_code: statusCode,
      latency_ms: Date.now() - startedAt,
    };
  }

  const reasonCode = mapResolveFailureCode({
    resolveBody: body,
    statusCode,
    error: err,
  });
  const localResolveUrl = `${String(RECO_PDP_LOCAL_INVOKE_BASE_URL || '').replace(/\/+$/, '')}/agent/v1/products/resolve`;
  const shouldAttemptLocalResolveFallback =
    RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
    RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED &&
    localResolveUrl &&
    localResolveUrl !== url &&
    shouldAttemptLocalRecoFallback(reasonCode, err);
  let finalReasonCode = reasonCode;
  if (shouldAttemptLocalResolveFallback) {
    let localResp = null;
    let localErr = null;
    try {
      localResp = await axios.post(localResolveUrl, payload, {
        headers: { 'Content-Type': 'application/json' },
        timeout: Math.max(250, Math.min(RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS, resolveTimeoutMs)),
        validateStatus: () => true,
      });
    } catch (e) {
      localErr = e;
    }

    const localBody = localResp && typeof localResp.data === 'object' ? localResp.data : null;
    const localStatusCode = Number.isFinite(Number(localResp?.status)) ? Math.trunc(Number(localResp.status)) : 0;
    const localResolvedRef = normalizeCanonicalProductRef(localBody?.product_ref, {
      requireMerchant: true,
      allowOpaqueProductId: false,
    });
    if (localStatusCode === 200 && localBody?.resolved === true && localResolvedRef) {
      return {
        ok: true,
        reason: null,
        product: buildAvailabilityResolvedProduct({
          resolvedRef: localResolvedRef,
          resolveBody: localBody,
          fallbackQuery: q,
          fallbackBrand: hints && typeof hints === 'object' ? hints.brand : '',
        }),
        resolve_reason_code: null,
        status_code: localStatusCode,
        latency_ms: Date.now() - startedAt,
      };
    }
    const localReasonCode = mapResolveFailureCode({
      resolveBody: localBody,
      statusCode: localStatusCode,
      error: localErr,
    });
    if (
      (finalReasonCode === 'no_candidates' || finalReasonCode === 'upstream_timeout') &&
      localReasonCode &&
      localReasonCode !== 'no_candidates'
    ) {
      finalReasonCode = localReasonCode;
    }
    if (localErr || localReasonCode !== 'no_candidates') {
      logger?.warn(
        {
          query: q.slice(0, 120),
          primary_status_code: statusCode || null,
          primary_resolve_reason_code: reasonCode,
          local_status_code: localStatusCode || null,
          local_resolve_reason_code: localReasonCode,
          local_err: localErr ? localErr.message || String(localErr) : null,
        },
        'aurora bff: availability local resolve fallback unresolved',
      );
    }
  }
  if (err || reasonCode !== 'no_candidates') {
    logger?.warn(
      {
        query: q.slice(0, 120),
        status_code: statusCode || null,
        resolve_reason_code: finalReasonCode,
        err: err ? err.message || String(err) : null,
      },
      'aurora bff: availability resolve fallback failed',
    );
  }
  return {
    ok: false,
    reason: 'unresolved',
    product: null,
    resolve_reason_code: finalReasonCode,
    status_code: statusCode || null,
    latency_ms: Date.now() - startedAt,
  };
}

async function resolveAvailabilityProductByLocalResolver({
  query,
  lang = 'en',
  hints = null,
  logger,
  timeoutMs = CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
} = {}) {
  const q = String(query || '').trim();
  if (!q) return { ok: false, reason: 'query_missing', product: null, resolve_reason_code: 'no_candidates', latency_ms: 0 };
  if (typeof resolveProductRefDirectImpl !== 'function') {
    return { ok: false, reason: 'local_resolver_unavailable', product: null, resolve_reason_code: 'db_error', latency_ms: 0 };
  }

  const startedAt = Date.now();
  const resolveTimeoutMs = Math.max(
    250,
    Math.min(
      CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
      Number.isFinite(Number(timeoutMs)) ? Math.trunc(Number(timeoutMs)) : CATALOG_AVAIL_RESOLVE_TIMEOUT_MS,
    ),
  );

  let responseBody = null;
  let responseError = null;
  try {
    responseBody = await resolveProductRefDirectImpl({
      query: q,
      lang: String(lang || 'en').toLowerCase() === 'cn' ? 'cn' : 'en',
      ...(hints && typeof hints === 'object' && !Array.isArray(hints) ? { hints } : {}),
      options: {
        search_all_merchants: true,
        timeout_ms: resolveTimeoutMs,
        upstream_retries: 0,
        stable_alias_short_circuit: true,
        allow_stable_alias_for_uuid: true,
      },
      caller: 'aurora_chatbox',
    });
  } catch (err) {
    responseError = err;
  }

  const resolvedRef = normalizeCanonicalProductRef(responseBody?.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (responseBody?.resolved === true && resolvedRef) {
    return {
      ok: true,
      reason: null,
      product: buildAvailabilityResolvedProduct({
        resolvedRef,
        resolveBody: responseBody,
        fallbackQuery: q,
        fallbackBrand: hints && typeof hints === 'object' ? hints.brand : '',
      }),
      resolve_reason_code: null,
      status_code: null,
      latency_ms: Date.now() - startedAt,
    };
  }

  const reasonCode = mapResolveFailureCode({
    resolveBody: responseBody,
    statusCode: null,
    error: responseError,
  });
  if (responseError || reasonCode !== 'no_candidates') {
    logger?.warn(
      {
        query: q.slice(0, 120),
        resolve_reason_code: reasonCode,
        err: responseError ? responseError.message || String(responseError) : null,
      },
      'aurora bff: availability local resolver failed',
    );
  }
  return {
    ok: false,
    reason: 'unresolved',
    product: null,
    resolve_reason_code: reasonCode,
    status_code: null,
    latency_ms: Date.now() - startedAt,
  };
}

function buildBrandPlaceholderProduct({ brandId, brandName, lang } = {}) {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const brand = String(brandName || '').trim() || (isCn ? '' : 'Unknown brand');
  const skuId = String(brandId || '').trim() || `brand_${stableHashBase36(brand).slice(0, 10)}`;
  const name = isCn ? `${brand}` : `${brand} (brand)`;
  return {
    product_id: `brand:${skuId}`,
    sku_id: skuId,
    brand,
    name,
    display_name: name,
    image_url: '',
    category: isCn ? '' : 'Brand',
  };
}

function normalizeProductCatalogQuery(raw) {
  let s = String(raw || '').trim();
  if (!s) return '';
  try {
    s = decodeURIComponent(s);
  } catch {
    // ignore malformed URI fragments
  }
  s = s
    .replace(/\+/g, ' ')
    .replace(/[_]+/g, ' ')
    .replace(/[|]+/g, ' ')
    .replace(/\.(html?|php|aspx?)$/i, ' ')
    .replace(/\b(en|cn|zh|us|uk|jp|kr|fr|de|es|pt|it|ca|au)\b/gi, ' ')
    .replace(/\b(product|products|item|items)\b/gi, ' ')
    .replace(/[-]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  if (s.length > 160) s = s.slice(0, 160).trim();
  return s;
}

function extractProductCatalogQueryFromUrl(rawUrl) {
  const urlText = String(rawUrl || '').trim();
  if (!urlText) return null;
  let parsed = null;
  try {
    parsed = new URL(urlText);
  } catch {
    return null;
  }

  const hostLabels = String(parsed.hostname || '')
    .trim()
    .toLowerCase()
    .replace(/^www\./, '')
    .split('.')
    .map((x) => x.trim())
    .filter(Boolean);
  const hostStop = new Set(['com', 'net', 'org', 'co', 'io', 'ai', 'shop', 'store', 'www', 'cn', 'cc', 'us', 'uk']);
  const hostToken = normalizeProductCatalogQuery(hostLabels.filter((x) => !hostStop.has(x)).join(' '));

  const pathTokens = String(parsed.pathname || '')
    .split('/')
    .map((x) => normalizeProductCatalogQuery(x))
    .filter(Boolean);
  const tailToken = normalizeProductCatalogQuery(pathTokens.slice(-2).join(' '));

  const queryToken = normalizeProductCatalogQuery(
    parsed.searchParams.get('product') ||
      parsed.searchParams.get('name') ||
      parsed.searchParams.get('title') ||
      parsed.searchParams.get('sku') ||
      '',
  );

  return {
    raw_url: urlText,
    host_token: hostToken,
    tail_token: tailToken,
    query_token: queryToken,
  };
}

function buildProductCatalogQueryCandidates({ inputText, inputUrl, parsedProduct } = {}) {
  const out = [];
  const seen = new Set();
  const add = (value, { normalize = true } = {}) => {
    let s = String(value || '').trim();
    if (!s) return;
    if (normalize) s = normalizeProductCatalogQuery(s);
    if (!s) return;
    const key = s.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    out.push(s);
  };

  const productObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  if (productObj) {
    add(joinBrandAndName(productObj.brand, productObj.name || productObj.display_name || productObj.displayName || ''));
    add(productObj.display_name || productObj.displayName || productObj.name || '');
    add(productObj.sku_id || productObj.product_id || '');
  }

  const urlCandidate =
    String(inputUrl || '').trim() ||
    (/^https?:\/\//i.test(String(inputText || '').trim()) ? String(inputText || '').trim() : '');
  const fromUrl = extractProductCatalogQueryFromUrl(urlCandidate);
  if (fromUrl) {
    add(fromUrl.raw_url, { normalize: false });
    if (fromUrl.host_token && fromUrl.tail_token) add(`${fromUrl.host_token} ${fromUrl.tail_token}`);
    add(fromUrl.tail_token);
    add(fromUrl.query_token);
    add(fromUrl.host_token);
  }

  add(inputText);

  return out.slice(0, Math.max(1, PRODUCT_INTEL_CATALOG_FALLBACK_MAX_QUERIES));
}

function buildActiveIntentRecallQuery({ keyIngredients = [], parsedProduct = null, categoryToken = '' } = {}) {
  const normalizedCategory = normalizeProductCatalogQuery(categoryToken);
  const productObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  const ingredientText = Array.isArray(keyIngredients) ? keyIngredients.join(' | ') : '';
  const text = `${ingredientText} ${String(productObj?.name || '')} ${String(productObj?.display_name || '')}`.toLowerCase();
  if (!text.trim()) return '';

  let keyword = '';
  if (/\bcopper\b/.test(text) && /\b(peptide|tripeptide|tetrapeptide|hexapeptide|pentapeptide)\b/.test(text)) keyword = 'copper peptide';
  else if (/\b(peptide|tripeptide|tetrapeptide|hexapeptide|pentapeptide)\b/.test(text)) keyword = 'peptide';
  else if (/\bretinol|retinal|retinoid|retinoate\b/.test(text)) keyword = 'retinol';
  else if (/\bniacinamide\b/.test(text)) keyword = 'niacinamide';
  else if (/\bsalicylic\b/.test(text)) keyword = 'salicylic acid';
  else if (/\bglycolic\b/.test(text)) keyword = 'glycolic acid';
  else if (/\blactic\b/.test(text)) keyword = 'lactic acid';
  else if (/\bhyaluron|hyaluronic|hyaluronate\b/.test(text)) keyword = 'hyaluronic acid';
  else if (/\bceramide\b/.test(text)) keyword = 'ceramide';

  if (!keyword) return '';
  return normalizeProductCatalogQuery(`${keyword} ${normalizedCategory}`.trim());
}

function buildRealtimeCompetitorQueryPlan({
  fromCatalogQueries = [],
  keyIngredients = [],
  parsedProduct = null,
  categoryToken = '',
  maxQueries = 2,
} = {}) {
  const limit = Math.max(1, Math.min(6, Number.isFinite(Number(maxQueries)) ? Math.trunc(Number(maxQueries)) : 2));
  const productObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  const anchorBrand = String(productObj?.brand || '').trim();
  const anchorName = String(productObj?.name || productObj?.display_name || '').trim();
  const nameWithoutBrand = (() => {
    if (!anchorName) return '';
    if (!anchorBrand) return anchorName;
    const escaped = escapeRegExp(anchorBrand);
    const removed = anchorName.replace(new RegExp(`^${escaped}\\s+`, 'i'), '').trim();
    return removed || anchorName;
  })();
  const activeIntentQuery = buildActiveIntentRecallQuery({
    keyIngredients,
    parsedProduct: productObj,
    categoryToken,
  });
  const ingredientQuery = normalizeProductCatalogQuery(
    `${(Array.isArray(keyIngredients) ? keyIngredients : []).slice(0, 2).join(' ')} ${categoryToken}`.trim(),
  );
  const categoryOnlyQuery = normalizeProductCatalogQuery(categoryToken);
  const genericNameQuery = normalizeProductCatalogQuery(nameWithoutBrand);

  const specific = [];
  const diversified = [];
  const pushUnique = (list, value) => {
    const q = normalizeProductCatalogQuery(value);
    if (!q || /^https?:\/\//i.test(q)) return;
    if (list.includes(q)) return;
    list.push(q);
  };

  for (const query of Array.isArray(fromCatalogQueries) ? fromCatalogQueries : []) {
    pushUnique(specific, query);
  }
  pushUnique(diversified, activeIntentQuery);
  pushUnique(diversified, ingredientQuery);
  pushUnique(diversified, categoryOnlyQuery);
  pushUnique(diversified, genericNameQuery);

  const out = [];
  const seen = new Set();
  const add = (value) => {
    const q = normalizeProductCatalogQuery(value);
    if (!q || /^https?:\/\//i.test(q)) return;
    const key = q.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    out.push(q);
  };

  if (specific.length) add(specific[0]);
  if (diversified.length) add(diversified[0]);
  for (const q of diversified.slice(1)) {
    if (out.length >= limit) break;
    add(q);
  }
  for (const q of specific.slice(1)) {
    if (out.length >= limit) break;
    add(q);
  }

  return out.slice(0, limit);
}

function mapCatalogProductToAnchorProduct(rawProduct, { fallbackName = '' } = {}) {
  const normalized = normalizeRecoCatalogProduct(rawProduct);
  if (!normalized || typeof normalized !== 'object') return null;
  const productId = pickFirstTrimmed(normalized.product_id, normalized.sku_id);
  if (!productId) return null;
  const brand = pickFirstTrimmed(normalized.brand);
  const name = pickFirstTrimmed(normalized.name, normalized.display_name, fallbackName);
  const displayName = pickFirstTrimmed(normalized.display_name, joinBrandAndName(brand, name), name);
  return {
    product_id: productId,
    ...(normalized.sku_id ? { sku_id: normalized.sku_id } : {}),
    ...(brand ? { brand } : {}),
    ...(name ? { name } : {}),
    ...(displayName ? { display_name: displayName } : {}),
    ...(normalized.image_url ? { image_url: normalized.image_url } : {}),
    ...(normalized.product_group_id ? { product_group_id: normalized.product_group_id } : {}),
    ...(normalized.merchant_id ? { merchant_id: normalized.merchant_id } : {}),
    ...(normalized.canonical_product_ref ? { canonical_product_ref: normalized.canonical_product_ref } : {}),
    category: 'product',
  };
}

async function resolveCatalogProductForProductInput({ inputText, inputUrl, parsedProduct, lang = 'EN', logger } = {}) {
  if (!PRODUCT_INTEL_CATALOG_FALLBACK_ENABLED) {
    return {
      ok: false,
      reason: 'catalog_fallback_disabled',
      source: null,
      query_used: null,
      product: null,
      attempts: [],
    };
  }

  const queries = buildProductCatalogQueryCandidates({ inputText, inputUrl, parsedProduct });
  if (!queries.length) {
    return {
      ok: false,
      reason: 'query_missing',
      source: null,
      query_used: null,
      product: null,
      attempts: [],
    };
  }

  const attempts = [];

  for (const query of queries) {
    const resolved = await resolveAvailabilityProductByQuery({ query, lang, logger });
    attempts.push({
      mode: 'resolve',
      query,
      ok: Boolean(resolved && resolved.ok && resolved.product),
      reason: resolved && resolved.resolve_reason_code ? resolved.resolve_reason_code : resolved && resolved.reason ? resolved.reason : null,
      latency_ms: Number.isFinite(Number(resolved && resolved.latency_ms)) ? Math.trunc(Number(resolved.latency_ms)) : null,
    });
    if (resolved && resolved.ok && resolved.product) {
      return {
        ok: true,
        reason: null,
        source: 'resolve',
        query_used: query,
        product: resolved.product,
        attempts,
      };
    }
  }

  for (const query of queries) {
    const searched = await searchPivotaBackendProducts({
      query,
      limit: 3,
      logger,
      timeoutMs: CATALOG_AVAIL_SEARCH_TIMEOUT_MS,
    });
    const first = Array.isArray(searched && searched.products)
      ? searched.products.find((p) => p && typeof p === 'object' && String(p.product_id || '').trim())
      : null;
    attempts.push({
      mode: 'search',
      query,
      ok: Boolean(first),
      reason: searched && searched.reason ? String(searched.reason) : null,
      latency_ms: Number.isFinite(Number(searched && searched.latency_ms)) ? Math.trunc(Number(searched.latency_ms)) : null,
    });
    if (first) {
      return {
        ok: true,
        reason: null,
        source: 'search',
        query_used: query,
        product: first,
        attempts,
      };
    }
  }

  return {
    ok: false,
    reason: 'catalog_no_match',
    source: null,
    query_used: queries[0] || null,
    product: null,
    attempts,
  };
}

async function resolvePrimaryAnalyzeAnchorForProductInput({ inputText, inputUrl, parsedProduct, lang = 'EN', logger } = {}) {
  const queries = buildProductCatalogQueryCandidates({ inputText, inputUrl, parsedProduct }).slice(0, 2);
  if (!queries.length) {
    return {
      ok: false,
      reason: 'query_missing',
      source: null,
      query_used: null,
      product: null,
      attempts: [],
    };
  }

  const attempts = [];
  for (const query of queries) {
    const resolved = await resolveAvailabilityProductByQuery({ query, lang, logger });
    const reasonCode =
      resolved && resolved.resolve_reason_code
        ? String(resolved.resolve_reason_code)
        : resolved && resolved.reason
          ? String(resolved.reason)
          : null;
    attempts.push({
      mode: 'resolve',
      query,
      ok: Boolean(resolved && resolved.ok && resolved.product),
      reason: reasonCode,
      latency_ms: Number.isFinite(Number(resolved && resolved.latency_ms)) ? Math.trunc(Number(resolved.latency_ms)) : null,
    });
    if (resolved && resolved.ok && resolved.product) {
      return {
        ok: true,
        reason: null,
        source: 'resolve',
        query_used: query,
        product: resolved.product,
        attempts,
      };
    }
  }

  return {
    ok: false,
    reason: attempts.length ? String(attempts[attempts.length - 1].reason || 'catalog_no_match') : 'catalog_no_match',
    source: null,
    query_used: queries[0] || null,
    product: null,
    attempts,
  };
}

function decodeHtmlEntitiesBasic(value) {
  const text = String(value || '');
  if (!text) return '';
  const base = text
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>');
  return base.replace(/&#(\d+);/g, (_, code) => {
    const n = Number(code);
    if (!Number.isFinite(n) || n <= 0) return _;
    try {
      return String.fromCodePoint(n);
    } catch {
      return _;
    }
  });
}

function stripHtmlToText(value) {
  return decodeHtmlEntitiesBasic(String(value || ''))
    .replace(/<script[\s\S]*?<\/script>/gi, ' ')
    .replace(/<style[\s\S]*?<\/style>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function uniqCaseInsensitiveStrings(items, max = 80) {
  const out = [];
  const seen = new Set();
  for (const raw of Array.isArray(items) ? items : []) {
    const s = String(raw || '').trim();
    if (!s) continue;
    const key = s.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(s);
    if (out.length >= max) break;
  }
  return out;
}

function splitInciList(raw) {
  const text = stripHtmlToText(raw)
    .replace(/\b(ingredients?|inci)\s*[:]\s*/gi, '')
    .replace(/\s*\|\s*/g, ', ')
    .trim();
  if (!text) return [];
  const rows = text
    .split(/[,;]\s*/)
    .map((item) =>
      String(item || '')
        .replace(/\.\s*(overview|discover|build|shop|how to use|can i use|faq)\b[\s\S]*$/i, '')
        .replace(/\s+/g, ' ')
        .trim(),
    )
    .filter((item) => item.length >= 2 && item.length <= 120)
    .filter((item) => !/[?!:]/.test(item))
    .filter((item) => !/\b(overview|discover|regimen|build my regimen|shop now|add to cart|how to use|faq)\b/i.test(item))
    .filter((item) => item.split(/\s+/).length <= 8);
  return uniqCaseInsensitiveStrings(rows, 120);
}

function extractInciListFromHtml(html) {
  const text = String(html || '');
  if (!text) return [];

  const patterns = [
    /data-original-ingredients\s*=\s*"([^"]{40,8000})"/i,
    /data-original-ingredients\s*=\s*'([^']{40,8000})'/i,
    /class="[^"]*ingredients[^"]*"[^>]*>\s*([\s\S]{40,6000}?)\s*<\/p>/i,
    />\s*Ingredients\s*<\/[^>]+>\s*<[^>]*>\s*([\s\S]{40,6000}?)\s*<\/(?:p|div)>/i,
    /"ingredients"\s*:\s*"([^"]{40,8000})"/i,
  ];
  for (const re of patterns) {
    const m = text.match(re);
    const list = splitInciList(m && m[1] ? m[1] : '');
    if (list.length >= 5) return list;
  }
  return [];
}

function extractKeyIngredientsFromHtml(html) {
  const text = String(html || '');
  if (!text) return [];
  const patterns = [
    />\s*Key ingredients\s*<\/[^>]+>\s*<[^>]*class="[^"]*list[^"]*"[^>]*>([\s\S]{10,3000})<\/div>/i,
    /"key_ingredients"\s*:\s*"([^"]{10,3000})"/i,
    /"hero_actives"\s*:\s*\[([^\]]{10,3000})\]/i,
  ];
  for (const re of patterns) {
    const m = text.match(re);
    const list = splitInciList(m && m[1] ? m[1] : '');
    if (list.length) return list.slice(0, 20);
  }
  return [];
}

function extractPageTitleFromHtml(html) {
  const text = String(html || '');
  if (!text) return '';
  const m = text.match(/<title[^>]*>([^<]{3,300})<\/title>/i);
  if (!m || !m[1]) return '';
  return stripHtmlToText(m[1]);
}

const CONCENTRATION_PERCENT_RE = /\b(\d{1,2}(?:\.\d{1,2})?)\s*%/gi;
const CONCENTRATION_CONTEXT_RE = /\b(acid|retinol|retinal|retinoid|niacinamide|vitamin\s*c|ascorb|peptide|copper|zinc|benzoyl|salicylic|glycolic|lactic|mandelic|serum|solution)\b/i;

function extractConcentrationSignalsFromText(rawText, max = 4) {
  const text = stripHtmlToText(rawText);
  if (!text) return [];
  const out = [];
  const seen = new Set();
  let m;
  CONCENTRATION_PERCENT_RE.lastIndex = 0;
  while ((m = CONCENTRATION_PERCENT_RE.exec(text))) {
    const valueToken = `${String(m[1] || '').trim()}%`;
    if (!valueToken || seen.has(valueToken.toLowerCase())) continue;
    const start = Math.max(0, m.index - 42);
    const end = Math.min(text.length, m.index + String(m[0] || '').length + 42);
    const windowText = text.slice(start, end);
    if (!CONCENTRATION_CONTEXT_RE.test(windowText)) continue;
    seen.add(valueToken.toLowerCase());
    out.push(valueToken);
    if (out.length >= max) break;
  }
  return out;
}

function extractConcentrationSignals({
  pageTitle = '',
  anchorName = '',
  anchorDisplayName = '',
  keyIngredients = [],
} = {}) {
  return uniqCaseInsensitiveStrings(
    [
      ...extractConcentrationSignalsFromText(pageTitle, 2),
      ...extractConcentrationSignalsFromText(anchorName, 2),
      ...extractConcentrationSignalsFromText(anchorDisplayName, 2),
      ...((Array.isArray(keyIngredients) ? keyIngredients : []).flatMap((item) =>
        extractConcentrationSignalsFromText(String(item || ''), 1)
      )),
    ],
    6,
  );
}

function normalizeCurrencyCode(value, fallback = '') {
  const token = String(value || '').trim().toUpperCase().replace(/[^A-Z]/g, '');
  if (token.length === 3) return token;
  const fb = String(fallback || '').trim().toUpperCase().replace(/[^A-Z]/g, '');
  return fb.length === 3 ? fb : '';
}

function inferCurrencyFromPriceText(value, fallback = '') {
  const text = String(value || '').trim();
  if (!text) return normalizeCurrencyCode(fallback, '');
  if (/[$]|usd|us\$/i.test(text)) return 'USD';
  if (/[]|eur/i.test(text)) return 'EUR';
  if (/[]|gbp/i.test(text)) return 'GBP';
  if (/[]|cny|rmb/i.test(text)) return 'CNY';
  if (/jpy|/i.test(text)) return 'JPY';
  return normalizeCurrencyCode(fallback, '');
}

function toPositiveNumberOrNull(value) {
  if (value == null) return null;
  if (typeof value === 'string') {
    const text = String(value).trim();
    if (!text) return null;
    const compact = text.replace(/\s+/g, '');
    const direct = Number(compact.replace(/,/g, ''));
    if (Number.isFinite(direct) && direct > 0) return Number(direct.toFixed(2));
    const numeric = compact.replace(/[^0-9.,-]/g, '');
    if (!numeric) return null;
    let normalized = numeric;
    const commaCount = (numeric.match(/,/g) || []).length;
    const dotCount = (numeric.match(/\./g) || []).length;
    if (commaCount && !dotCount) normalized = numeric.replace(',', '.');
    normalized = normalized.replace(/,(?=\d{3}\b)/g, '');
    const parsed = Number(normalized);
    if (!Number.isFinite(parsed) || parsed <= 0) return null;
    return Number(parsed.toFixed(2));
  }
  const n = Number(value);
  if (!Number.isFinite(n) || n <= 0) return null;
  return Number(n.toFixed(2));
}

function normalizePriceObject(rawPrice, { fallbackCurrency = 'USD' } = {}) {
  if (rawPrice == null) return null;
  if (typeof rawPrice === 'number' || typeof rawPrice === 'string') {
    const amount = toPositiveNumberOrNull(rawPrice);
    if (amount == null) return null;
    const inferredCurrency = inferCurrencyFromPriceText(rawPrice, fallbackCurrency);
    return { amount, currency: inferredCurrency || normalizeCurrencyCode(fallbackCurrency, 'USD') || 'USD', unknown: false };
  }
  if (typeof rawPrice !== 'object' || Array.isArray(rawPrice)) return null;

  if (rawPrice.unknown === true) return null;

  const nestedPrice = rawPrice.price && typeof rawPrice.price === 'object' && !Array.isArray(rawPrice.price)
    ? rawPrice.price
    : null;

  const directAmount = toPositiveNumberOrNull(
    rawPrice.amount ??
      rawPrice.price_amount ??
      rawPrice.priceAmount ??
      rawPrice.value ??
      rawPrice.price_value ??
      rawPrice.priceValue ??
      rawPrice.price ??
      nestedPrice?.amount ??
      nestedPrice?.value ??
      nestedPrice?.price ??
      rawPrice.min ??
      rawPrice.min_price ??
      rawPrice.minPrice ??
      rawPrice.offer_price ??
      rawPrice.offerPrice,
  );
  if (directAmount != null) {
    const directCurrency = normalizeCurrencyCode(
      rawPrice.currency ??
        rawPrice.currency_code ??
        rawPrice.currencyCode ??
        rawPrice.priceCurrency ??
        nestedPrice?.currency ??
        nestedPrice?.currencyCode ??
        nestedPrice?.priceCurrency,
      fallbackCurrency,
    );
    return { amount: directAmount, currency: directCurrency || 'USD', unknown: false };
  }

  const usd = toPositiveNumberOrNull(rawPrice.usd ?? rawPrice.price_usd ?? rawPrice.priceUsd);
  if (usd != null) return { amount: usd, currency: 'USD', unknown: false };
  const cny = toPositiveNumberOrNull(rawPrice.cny ?? rawPrice.price_cny ?? rawPrice.priceCny);
  if (cny != null) return { amount: cny, currency: 'CNY', unknown: false };
  return null;
}

function extractCatalogCandidatePrice(rawProduct) {
  const base = rawProduct && typeof rawProduct === 'object' && !Array.isArray(rawProduct) ? rawProduct : null;
  if (!base) return null;

  const seeds = [
    base.price,
    base.price_amount,
    base.priceAmount,
    base.price_value,
    base.priceValue,
    base.offer_price,
    base.offerPrice,
    base.sale_price,
    base.salePrice,
    base.list_price,
    base.listPrice,
    base.min_price,
    base.minPrice,
    base.max_price,
    base.maxPrice,
    base.pricing,
    base.price_info,
    base.priceInfo,
    base.offer,
    base.offers,
    base.subject && typeof base.subject === 'object' && !Array.isArray(base.subject) ? base.subject.price : null,
    base.subject && typeof base.subject === 'object' && !Array.isArray(base.subject) ? base.subject.offers : null,
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku) ? base.sku.price : null,
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku) ? base.sku.offers : null,
    base.product && typeof base.product === 'object' && !Array.isArray(base.product) ? base.product.price : null,
    base.product && typeof base.product === 'object' && !Array.isArray(base.product) ? base.product.offers : null,
  ];

  for (const seed of seeds) {
    if (seed == null) continue;
    if (Array.isArray(seed)) {
      for (const item of seed) {
        const parsed = normalizePriceObject(item, { fallbackCurrency: 'USD' });
        if (parsed) return parsed;
      }
      continue;
    }
    const parsed = normalizePriceObject(seed, { fallbackCurrency: 'USD' });
    if (parsed) return parsed;
  }

  const usd = toPositiveNumberOrNull(base.price_usd ?? base.priceUsd ?? base.usd);
  if (usd != null) return { amount: usd, currency: 'USD', unknown: false };
  const cny = toPositiveNumberOrNull(base.price_cny ?? base.priceCny ?? base.cny);
  if (cny != null) return { amount: cny, currency: 'CNY', unknown: false };
  return null;
}

function extractProductPriceFromHtml(html) {
  const text = String(html || '');
  if (!text) return null;

  const metaCurrencyMatch = text.match(
    /<meta[^>]+(?:property|name)=["'](?:product:price:currency|og:price:currency)["'][^>]+content=["']([^"']{2,12})["']/i,
  );
  const metaCurrency = normalizeCurrencyCode(metaCurrencyMatch?.[1] || '', '');

  const scriptRe = /<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
  let m;
  while ((m = scriptRe.exec(text))) {
    const raw = decodeHtmlEntitiesBasic(String(m[1] || '')).trim();
    if (!raw) continue;
    let parsed = null;
    try {
      parsed = JSON.parse(raw);
    } catch {
      continue;
    }
    const stack = Array.isArray(parsed) ? [...parsed] : [parsed];
    while (stack.length) {
      const node = stack.shift();
      if (!node || typeof node !== 'object') continue;
      if (Array.isArray(node)) {
        stack.push(...node);
        continue;
      }

      const currency = normalizeCurrencyCode(
        node.priceCurrency ?? node.price_currency ?? node.currency ?? node.currencyCode,
        metaCurrency,
      );
      const offerAmount =
        toPositiveNumberOrNull(node.price) ??
        toPositiveNumberOrNull(node.lowPrice) ??
        toPositiveNumberOrNull(node.highPrice);
      if (offerAmount != null) {
        return {
          amount: offerAmount,
          currency: currency || 'USD',
          unknown: false,
          source: 'json_ld_offer',
        };
      }

      const offers = node.offers ?? node.offer ?? node.aggregateOffer ?? node.aggregate_offer;
      if (offers) {
        if (Array.isArray(offers)) stack.push(...offers);
        else stack.push(offers);
      }
      if (node['@graph']) {
        if (Array.isArray(node['@graph'])) stack.push(...node['@graph']);
        else stack.push(node['@graph']);
      }
      const nested = node.mainEntity ?? node.main_entity ?? node.itemOffered;
      if (nested) stack.push(nested);
    }
  }

  const metaAmountMatch = text.match(
    /<meta[^>]+(?:property|name)=["'](?:product:price:amount|og:price:amount|twitter:data1|price)["'][^>]+content=["']([^"']{1,32})["']/i,
  );
  const metaAmount = toPositiveNumberOrNull(metaAmountMatch?.[1]);
  if (metaAmount != null) {
    return {
      amount: metaAmount,
      currency: metaCurrency || 'USD',
      unknown: false,
      source: 'meta_price',
    };
  }

  const inlineCurrency = normalizeCurrencyCode(
    text.match(/"priceCurrency"\s*:\s*"([A-Za-z]{3})"/i)?.[1] || '',
    metaCurrency,
  );
  const inlineAmount = toPositiveNumberOrNull(text.match(/"price"\s*:\s*"?([0-9]+(?:\.[0-9]{1,2})?)"?/i)?.[1]);
  if (inlineAmount != null) {
    return {
      amount: inlineAmount,
      currency: inlineCurrency || 'USD',
      unknown: false,
      source: 'inline_price',
    };
  }

  const plainText = stripHtmlToText(text).replace(/\s+/g, ' ').trim();
  if (plainText) {
    const prefixed = /(?:\b(USD|EUR|GBP|CNY|JPY)\b|([$]))\s*([0-9]{1,4}(?:[.,][0-9]{1,2})?)/gi;
    let mPrefixed;
    while ((mPrefixed = prefixed.exec(plainText))) {
      const rawCurrency = mPrefixed[1] || mPrefixed[2] || '';
      const amount = toPositiveNumberOrNull(mPrefixed[3]);
      if (amount == null) continue;
      const currency = inferCurrencyFromPriceText(rawCurrency, metaCurrency || 'USD');
      return {
        amount,
        currency: currency || 'USD',
        unknown: false,
        source: 'on_page_structured_text',
      };
    }

    const suffixed = /([0-9]{1,4}(?:[.,][0-9]{1,2})?)\s*(USD|EUR|GBP|CNY|JPY)\b/gi;
    let mSuffixed;
    while ((mSuffixed = suffixed.exec(plainText))) {
      const amount = toPositiveNumberOrNull(mSuffixed[1]);
      if (amount == null) continue;
      const currency = inferCurrencyFromPriceText(mSuffixed[2], metaCurrency || 'USD');
      return {
        amount,
        currency: currency || 'USD',
        unknown: false,
        source: 'on_page_structured_text',
      };
    }
  }
  return null;
}

function slugToCandidateProductName(raw) {
  const text = String(raw || '')
    .replace(/\.[a-z0-9]{2,8}$/i, '')
    .replace(/[_-]+/g, ' ')
    .replace(/\b\d{5,}\b/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  if (!text) return '';
  return text
    .split(' ')
    .map((token) => {
      const t = String(token || '').trim();
      if (!t) return '';
      if (/^[A-Z0-9%+]+$/.test(t)) return t;
      return `${t.slice(0, 1).toUpperCase()}${t.slice(1).toLowerCase()}`;
    })
    .join(' ')
    .trim();
}

function extractOnPageRelatedProducts(html, { baseUrl, anchorName = '', max = 4 } = {}) {
  const source = String(html || '');
  const base = String(baseUrl || '').trim();
  if (!source || !base) return [];

  let parsedBase = null;
  try {
    parsedBase = new URL(base);
  } catch {
    parsedBase = null;
  }
  if (!parsedBase) return [];

  const generic = new Set([
    'shop now',
    'add to cart',
    'learn more',
    'read more',
    'details',
    'discover',
    'ingredients',
    'reviews',
    'view',
    'buy',
    'product',
    'skip to main content',
    'skip to footer content',
    'contact us',
    'search',
    'my account',
    'sign in',
    'menu',
    'home',
  ]);
  const productPathLike = /(product|serum|cream|moistur|cleanser|toner|mask|spf|sunscreen|retinol|niacinamide|peptide)/i;
  const anchorKey = String(anchorName || '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ')
    .trim();

  const seen = new Set();
  const out = [];
  const re = /<a[^>]+href\s*=\s*["']([^"']{2,600})["'][^>]*>([\s\S]{1,400}?)<\/a>/gi;
  let m = re.exec(source);
  while (m) {
    const hrefRaw = decodeHtmlEntitiesBasic(m[1] || '');
    const hrefTrimmed = String(hrefRaw || '').trim();
    if (!hrefTrimmed || hrefTrimmed.startsWith('#') || /^javascript:/i.test(hrefTrimmed) || /^mailto:/i.test(hrefTrimmed) || /^tel:/i.test(hrefTrimmed)) {
      m = re.exec(source);
      continue;
    }
    const textRaw = stripHtmlToText(m[2] || '');
    let absUrl = '';
    try {
      const u = new URL(hrefTrimmed, parsedBase);
      if (!/^https?:$/i.test(u.protocol)) {
        m = re.exec(source);
        continue;
      }
      if (u.hostname.replace(/^www\./i, '') !== parsedBase.hostname.replace(/^www\./i, '')) {
        m = re.exec(source);
        continue;
      }
      const samePath = String(u.pathname || '') === String(parsedBase.pathname || '');
      const sameSearch = String(u.search || '') === String(parsedBase.search || '');
      if (samePath && sameSearch) {
        m = re.exec(source);
        continue;
      }
      absUrl = u.toString();
      const pathLower = String(u.pathname || '').toLowerCase();
      if (!productPathLike.test(pathLower) && !/\.html$/i.test(pathLower)) {
        m = re.exec(source);
        continue;
      }
    } catch {
      m = re.exec(source);
      continue;
    }

    const textNorm = String(textRaw || '').replace(/\s+/g, ' ').trim();
    const lowerTextNorm = textNorm.toLowerCase();
    const slugName = (() => {
      try {
        const u = new URL(absUrl);
        const parts = String(u.pathname || '')
          .split('/')
          .map((x) => x.trim())
          .filter(Boolean);
        return parts.length ? slugToCandidateProductName(parts[parts.length - 1]) : '';
      } catch {
        return '';
      }
    })();

    let name = textNorm;
    if (!name || name.length < 4 || generic.has(lowerTextNorm) || /^skip to /i.test(name) || /\b(contact us|search|my account|sign in)\b/i.test(name)) {
      name = slugName;
    }
    if (!name || name.length < 4 || name.length > 120) {
      m = re.exec(source);
      continue;
    }
    const nameKey = name.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
    if (!nameKey) {
      m = re.exec(source);
      continue;
    }
    if (generic.has(nameKey) || /^skip to /i.test(name) || /^contact us$/i.test(name)) {
      m = re.exec(source);
      continue;
    }
    if (anchorKey && nameKey === anchorKey) {
      m = re.exec(source);
      continue;
    }
    if (seen.has(nameKey)) {
      m = re.exec(source);
      continue;
    }
    seen.add(nameKey);
    out.push({ name, url: absUrl });
    if (out.length >= Math.max(1, Math.min(8, Number(max) || 4))) break;

    m = re.exec(source);
  }

  return out;
}

function buildOnPageCompetitorCandidates({
  html,
  productUrl,
  anchorProduct = null,
  profileSummary = null,
  lang = 'EN',
  maxCandidates = 4,
} = {}) {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const anchorObj = anchorProduct && typeof anchorProduct === 'object' && !Array.isArray(anchorProduct) ? anchorProduct : null;
  const anchorBrand = pickFirstTrimmed(anchorObj?.brand);
  const anchorName = pickFirstTrimmed(anchorObj?.name, anchorObj?.display_name);
  const anchorText = `${anchorBrand || ''} ${anchorName || ''}`.trim();
  const anchorTokens = tokenizeProductTextForSimilarity(anchorText);
  const anchorCategory = inferProductCategoryToken(anchorText);
  const profileSkinTags = buildProfileSkinTags(profileSummary);
  const rows = extractOnPageRelatedProducts(html, {
    baseUrl: productUrl,
    anchorName,
    max: Math.max(1, Math.min(8, Number(maxCandidates) || 4)),
  });
  const totalQueries = Math.max(1, rows.length);
  return rows.map((row, idx) => {
    const rowTokens = tokenizeProductTextForSimilarity(`${anchorBrand || ''} ${String(row.name || '')}`);
    const queryOverlap = rowTokens.filter((token) => anchorTokens.includes(token)).length;
    const rowCategory = inferProductCategoryToken(row.name || '');
    const sameCategory = Boolean(anchorCategory && rowCategory && anchorCategory === rowCategory);
    const scored = scoreRealtimeCompetitorCandidate({
      queryOverlap,
      ingredientNameOverlap: 0,
      sameCategory,
      sameBrand: Boolean(anchorBrand),
      anchorIngredientTokens: [],
      candidateIngredientTokens: [],
      profileSkinTags,
      candidateSkinTags: [],
      candidateSocialScore: null,
      candidateSocialSupportCount: null,
      recallHitCount: Math.max(1, totalQueries - idx),
      totalQueries,
    });
    const fallbackSimilarity = Number(Math.max(0.35, Math.min(0.72, 0.66 - idx * 0.07)).toFixed(3));
    const similarityScore = Number(Math.max(scored.similarity_score, fallbackSimilarity).toFixed(3));
    return {
      ...(anchorBrand ? { brand: anchorBrand } : {}),
      name: row.name,
      source: { type: 'on_page_related' },
      source_type: 'on_page_related',
      similarity_score: similarityScore,
      score_breakdown: scored.score_breakdown,
      why_candidate: uniqCaseInsensitiveStrings(
        [
          isCn ? '' : 'related product link found on the same product page',
          sameCategory
            ? isCn
              ? ''
              : 'same category/use-case'
            : '',
          scored.score_breakdown.query_overlap_score >= 0.45
            ? isCn
              ? ''
              : 'name tokens overlap with anchor product'
            : '',
          scored.score_breakdown.skin_fit_similarity >= 0.6
            ? isCn
              ? ''
              : 'better aligned with current skin profile'
            : '',
        ],
        4,
      ),
      compare_highlights: [
        isCn
          ? ''
          : 'Same-brand/context candidate; compare INCI and concentration before final pick.',
        row.url,
      ],
    };
  });
}

function deriveIngredientMechanisms(ingredients, lang = 'EN') {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const pool = Array.isArray(ingredients) ? ingredients.map((v) => String(v || '').toLowerCase()) : [];
  const joined = pool.join(' | ');
  const out = [];
  if (/\b(peptide|tripeptide|tetrapeptide|hexapeptide|pentapeptide)\b/.test(joined)) {
    out.push(
      isCn
        ? '/'
        : 'Peptide complexes are commonly used to support firmness and the look of fine lines (effect depends on formula and concentration).',
    );
  }
  if (/\b(hyaluronate|hyaluronic|glycerin|trehalose|urea|sodium pca|pca)\b/.test(joined)) {
    out.push(
      isCn
        ? '/'
        : 'Humectant blend suggests hydration support and moisture retention.',
    );
  }
  if (/\b(allantoin|panthenol|betaine)\b/.test(joined)) {
    out.push(
      isCn ? '' : 'Includes soothing-support ingredients that can improve tolerance.',
    );
  }
  return uniqCaseInsensitiveStrings(out, 4);
}

function deriveIngredientRiskNotes(ingredients, profileSummary, lang = 'EN') {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const list = Array.isArray(ingredients) ? ingredients.map((v) => String(v || '').trim()) : [];
  const joined = list.join(' | ').toLowerCase();
  const risks = [];

  const hasRetinoid = /\b(retinol|retinal|retinoate|adapalene|tretinoin)\b/.test(joined);
  const hasAcid = /\b(aha|bha|pha|glycolic|lactic|mandelic|salicylic|citric acid)\b/.test(joined);
  const hasFragrance = /\b(fragrance|parfum|linalool|limonene|citral|geraniol)\b/.test(joined);
  const hasAlcoholDenat = /\balcohol denat\b/.test(joined);
  const hasEssentialOil = /\b(essential oil|lavender oil|citrus peel oil|eucalyptus oil|menthol)\b/.test(joined);

  const sensitivity = String(profileSummary?.sensitivity || '').trim().toLowerCase();
  const barrier = String(profileSummary?.barrierStatus || '').trim().toLowerCase();
  const sensitiveProfile = sensitivity === 'high' || sensitivity === 'medium' || barrier === 'impaired';

  if (hasRetinoid) risks.push(isCn ? 'A/' : 'Contains retinoid-like ingredients with higher irritation/dryness risk early on.');
  if (hasAcid) risks.push(isCn ? '' : 'Contains exfoliating acids; frequency and layering need caution.');
  if (hasFragrance || hasEssentialOil) {
    risks.push(
      isCn
        ? '/'
        : 'May include fragrance-related ingredients; patch testing is recommended for sensitive skin.',
    );
  }
  if (hasAlcoholDenat && sensitiveProfile) {
    risks.push(
      isCn
        ? ''
        : 'With sensitive or impaired barrier, denatured alcohol can increase stinging risk.',
    );
  }
  return uniqCaseInsensitiveStrings(risks, 4);
}

function deriveKeyIngredientsForAnalysis(inciList, keyHints) {
  const hints = uniqCaseInsensitiveStrings(Array.isArray(keyHints) ? keyHints : [], 12);
  const inci = uniqCaseInsensitiveStrings(Array.isArray(inciList) ? inciList : [], 120);
  const picked = [];
  const seen = new Set();

  const add = (v) => {
    const s = String(v || '').trim();
    if (!s) return;
    const key = s.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    picked.push(s);
  };

  for (const item of hints) add(item);

  const activePatterns = [
    /\b(peptide|tripeptide|tetrapeptide|hexapeptide|pentapeptide|niacinamide|salicylic|glycolic|lactic|mandelic|retinol|retinal|adapalene|tretinoin|azelaic|tranexamic|ascorbic|vitamin c|ceramide|panthenol|hyaluronate|hyaluronic|allantoin)\b/i,
  ];
  for (const item of inci) {
    if (activePatterns.some((re) => re.test(item))) add(item);
    if (picked.length >= 10) break;
  }
  if (!picked.length) {
    for (const item of inci) {
      if (/^aqua|^water$/i.test(item)) continue;
      add(item);
      if (picked.length >= 8) break;
    }
  }
  return picked.slice(0, 10);
}

function normalizeInciIngredientName(raw) {
  const source = String(raw || '')
    .replace(/\s+/g, ' ')
    .trim();
  if (!source) return '';
  return source
    .split(/\s+/)
    .map((token) => {
      const t = String(token || '').trim();
      if (!t) return '';
      if (/^[A-Z0-9+%(),./-]+$/.test(t)) return t;
      return t
        .split('-')
        .map((part) => {
          const s = String(part || '').trim();
          if (!s) return '';
          if (/^[A-Z0-9]+$/.test(s)) return s;
          return `${s.slice(0, 1).toUpperCase()}${s.slice(1).toLowerCase()}`;
        })
        .join('-');
    })
    .join(' ')
    .trim();
}

function countRegexMatches(text, regex) {
  if (!(regex instanceof RegExp)) return 0;
  const rawFlags = String(regex.flags || '');
  const flags = rawFlags.includes('g') ? rawFlags : `${rawFlags}g`;
  const re = new RegExp(regex.source, flags);
  let count = 0;
  while (re.exec(text)) {
    count += 1;
    if (count >= 2000) break;
  }
  return count;
}

function collectThemeCountsFromText(text, definitions) {
  const out = [];
  for (const def of Array.isArray(definitions) ? definitions : []) {
    const label = String(def?.label || '').trim();
    if (!label) continue;
    const patterns = Array.isArray(def?.patterns) ? def.patterns : [];
    let count = 0;
    for (const re of patterns) count += countRegexMatches(text, re);
    if (count > 0) out.push({ label, count });
  }
  out.sort((a, b) => {
    if (b.count !== a.count) return b.count - a.count;
    return String(a.label || '').localeCompare(String(b.label || ''));
  });
  return out;
}

function extractAggregateRatingFromHtml(html) {
  const source = String(html || '');
  if (!source) return { rating_value: null, review_count: null };

  const ratingRaw =
    source.match(/"ratingValue"\s*:\s*"?([0-9]+(?:\.[0-9]+)?)"?/i)?.[1] ||
    source.match(/itemprop\s*=\s*"ratingValue"[^>]*content\s*=\s*"([0-9]+(?:\.[0-9]+)?)"/i)?.[1] ||
    null;
  const reviewRaw =
    source.match(/"reviewCount"\s*:\s*"?([0-9]{1,8})"?/i)?.[1] ||
    source.match(/itemprop\s*=\s*"reviewCount"[^>]*content\s*=\s*"([0-9]{1,8})"/i)?.[1] ||
    null;

  let ratingValue = ratingRaw != null ? Number(ratingRaw) : null;
  if (!Number.isFinite(ratingValue)) ratingValue = null;
  if (ratingValue != null && ratingValue > 5 && ratingValue <= 10) ratingValue = ratingValue / 2;
  if (ratingValue != null && (ratingValue < 0 || ratingValue > 5)) ratingValue = null;

  let reviewCount = reviewRaw != null ? Number(reviewRaw) : null;
  if (!Number.isFinite(reviewCount) || reviewCount < 0) reviewCount = null;
  if (reviewCount != null) reviewCount = Math.trunc(reviewCount);

  return { rating_value: ratingValue, review_count: reviewCount };
}

function extractRealtimeSocialSignalsFromHtml(html, { lang = 'EN', riskNotes = [] } = {}) {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const sourceText = stripHtmlToText(html).toLowerCase();
  const text = sourceText.length > 240000 ? sourceText.slice(0, 240000) : sourceText;

  const positiveThemes = collectThemeCountsFromText(text, [
    { label: isCn ? '' : 'hydration', patterns: [/\bhydrat(?:e|ing|ion)\b/gi, /\bmoisturi(?:z|s)(?:e|ing|er)\b/gi, /|/gi] },
    { label: isCn ? '' : 'soothing', patterns: [/\bsoothing?\b/gi, /\bcalm(?:ing)?\b/gi, /|/gi] },
    { label: isCn ? '' : 'lightweight texture', patterns: [/\blightweight\b/gi, /\bnon[-\s]?greasy\b/gi, /|/gi] },
    { label: isCn ? '' : 'firming', patterns: [/\bfirm(?:ing|ness)?\b/gi, /\bfine lines?\b/gi, /|/gi] },
    { label: isCn ? '' : 'brightening', patterns: [/\bbrighten(?:ing)?\b/gi, /\beven tone\b/gi, /|/gi] },
  ]);
  const negativeThemes = collectThemeCountsFromText(text, [
    { label: isCn ? '/' : 'sticky or pilling', patterns: [/\bsticky\b/gi, /\bpill(?:ing)?\b/gi, /||/gi] },
    { label: isCn ? '' : 'stinging or redness', patterns: [/\bsting(?:ing)?\b/gi, /\bred(?:ness)?\b/gi, /\birritat(?:e|ion)\b/gi, /||/gi] },
    { label: isCn ? '/' : 'breakout concerns', patterns: [/\bbreak ?out(?:s)?\b/gi, /\bclog(?:ged)? pores?\b/gi, /|/gi] },
    { label: isCn ? '/' : 'drying feel', patterns: [/\bdry(?:ing|ness)?\b/gi, /\btight(?:ness)?\b/gi, /||/gi] },
  ]);

  const rating = extractAggregateRatingFromHtml(html);
  const positiveLabels = positiveThemes.slice(0, 5).map((row) => row.label);
  const negativeLabels = negativeThemes.slice(0, 5).map((row) => row.label);
  const totalPos = positiveThemes.reduce((sum, row) => sum + Number(row.count || 0), 0);
  const totalNeg = negativeThemes.reduce((sum, row) => sum + Number(row.count || 0), 0);

  const combinedRiskText = `${String(riskNotes.join(' | ') || '').toLowerCase()} | ${negativeLabels.join(' | ').toLowerCase()} | ${text}`;
  const riskForGroups = uniqCaseInsensitiveStrings(
    [
      /\bsting|red|irritat|sensitive|||/.test(combinedRiskText)
        ? isCn
          ? '/'
          : 'Sensitive skin: start low and monitor for stinging/redness.'
        : '',
      /\bbreakout|clog|acne||/.test(combinedRiskText)
        ? isCn
          ? ''
          : 'Acne-prone skin: watch for clogging/breakout feedback.'
        : '',
      /\bdry|tight|barrier|||/.test(combinedRiskText)
        ? isCn
          ? ''
          : 'Impaired barrier: prioritize moisturizer and reduce active layering.'
        : '',
    ],
    4,
  );

  const platformScores = {};
  if (rating.rating_value != null) {
    platformScores.BrandSite = Number(Math.max(0, Math.min(1, rating.rating_value / 5)).toFixed(3));
  } else if (totalPos > 0 || totalNeg > 0) {
    const base = 0.52 + (totalPos - totalNeg) / Math.max(6, totalPos + totalNeg);
    platformScores.BrandSite = Number(Math.max(0.35, Math.min(0.8, base)).toFixed(3));
  }

  const notes = uniqCaseInsensitiveStrings(
    [
      rating.rating_value != null
        ? isCn
          ? ` ${rating.rating_value.toFixed(1)}/5${rating.review_count != null ? ` ${rating.review_count}` : ''}`
          : `Visible page rating is about ${rating.rating_value.toFixed(1)}/5${rating.review_count != null ? ` (n=${rating.review_count})` : ''}.`
        : '',
      totalPos || totalNeg
        ? isCn
          ? ` ${totalPos} ${totalNeg}`
          : `On-page text signals: positive themes ${totalPos}, negative themes ${totalNeg}.`
        : '',
      isCn
        ? ''
        : 'Note: these social signals are aggregated from public product-page text, not full cross-platform crawl.',
    ],
    3,
  );

  return {
    platform_scores: platformScores,
    typical_positive: positiveLabels,
    typical_negative: negativeLabels,
    risk_for_groups: riskForGroups,
    notes,
    has_signal: Boolean(Object.keys(platformScores).length || positiveLabels.length || negativeLabels.length || riskForGroups.length),
    review_count: rating.review_count,
  };
}

function tokenizeProductTextForSimilarity(raw) {
  const stopWords = new Set([
    'the', 'and', 'for', 'with', 'from', 'this', 'that', 'serum', 'cream', 'mask', 'toner', 'lotion', 'face', 'skin',
    'product', 'multi', 'plus', 'care', 'daily', 'night', 'day',
  ]);
  return Array.from(
    new Set(
      String(raw || '')
        .toLowerCase()
        .split(/[^a-z0-9]+/)
        .map((token) => token.trim())
        .filter((token) => token.length >= 3 && !stopWords.has(token)),
    ),
  );
}

function inferProductCategoryToken(raw) {
  const text = String(raw || '').toLowerCase();
  if (!text) return '';
  const categories = ['serum', 'essence', 'cream', 'moisturizer', 'cleanser', 'toner', 'sunscreen', 'spf', 'mask', 'oil'];
  return categories.find((token) => new RegExp(`\\b${token}\\b`, 'i').test(text)) || '';
}

function scoreCategoryUseCaseMatch({
  anchorCategoryToken = '',
  candidateNameText = '',
  candidateCategoryText = '',
} = {}) {
  const anchorToken = String(anchorCategoryToken || '').trim().toLowerCase();
  if (!anchorToken) return 0.7;

  const candidateToken = inferProductCategoryToken(`${candidateNameText || ''} ${candidateCategoryText || ''}`);
  if (candidateToken && candidateToken === anchorToken) return 1;
  if (candidateToken && candidateToken !== anchorToken) return 0.32;
  if (String(candidateCategoryText || '').trim()) return 0.48;
  return 0.58;
}

function computeTokenJaccardScore(a, b) {
  const left = Array.from(new Set(Array.isArray(a) ? a.map((x) => String(x || '').trim().toLowerCase()).filter(Boolean) : []));
  const right = Array.from(new Set(Array.isArray(b) ? b.map((x) => String(x || '').trim().toLowerCase()).filter(Boolean) : []));
  if (!left.length || !right.length) return null;
  const rightSet = new Set(right);
  let inter = 0;
  for (const token of left) {
    if (rightSet.has(token)) inter += 1;
  }
  const union = left.length + right.length - inter;
  if (!union) return null;
  return clamp01Score(inter / union);
}

function buildProfileSkinTags(profileSummary) {
  const profile = profileSummary && typeof profileSummary === 'object' && !Array.isArray(profileSummary) ? profileSummary : null;
  if (!profile) return [];
  const out = [];
  const add = (value) => {
    const tag = normalizeSkinTypeTag(value);
    if (!tag) return;
    if (!out.includes(tag)) out.push(tag);
  };
  add(profile.skinType);
  const sensitivity = String(profile.sensitivity || '').trim().toLowerCase();
  if (sensitivity === 'high' || sensitivity === 'medium' || sensitivity === 'sensitive' || sensitivity === 'reactive') {
    add('sensitive');
  } else {
    add(sensitivity);
  }
  const barrier = String(profile.barrierStatus || '').trim().toLowerCase();
  if (barrier === 'impaired' || barrier === 'damaged' || barrier === 'reactive') add('impaired_barrier');
  else add(barrier);
  for (const goal of Array.isArray(profile.goals) ? profile.goals : []) add(goal);
  return out.slice(0, 8);
}

function computeSkinFitSimilarity(profileTags, candidateTags) {
  const profile = Array.isArray(profileTags) ? profileTags.filter(Boolean) : [];
  const candidate = Array.isArray(candidateTags) ? candidateTags.filter(Boolean) : [];
  if (!profile.length) return 0.5;
  if (!candidate.length) return 0.42;
  const pSet = new Set(profile);
  let matched = 0;
  for (const tag of candidate) {
    if (pSet.has(tag)) matched += 1;
  }
  const base = matched / Math.max(1, Math.min(profile.length, 3));
  return clamp01Score(base);
}

function computeSocialReferenceScore({ baseScore, supportCount, hitCount, totalQueries }) {
  const ratingScore = baseScore == null ? 0.5 : clamp01Score(baseScore);
  const queryCap = Math.max(1, Math.min(4, Number(totalQueries) || 1));
  const freq = Math.max(0, (Number(hitCount) || 0) - 1);
  const coMention = queryCap <= 1 ? 0 : clamp01Score(freq / (queryCap - 1));
  const supportBoost =
    Number.isFinite(Number(supportCount)) && Number(supportCount) > 0
      ? Math.min(0.06, Math.log10(1 + Number(supportCount)) * 0.016)
      : 0;
  return clamp01Score(ratingScore * 0.78 + coMention * 0.22 + supportBoost);
}

function scoreRealtimeCompetitorCandidate({
  queryOverlap = 0,
  ingredientNameOverlap = 0,
  sameCategory = false,
  sameBrand = false,
  anchorIngredientTokens = [],
  candidateIngredientTokens = [],
  profileSkinTags = [],
  candidateSkinTags = [],
  candidateSocialScore = null,
  candidateSocialSupportCount = null,
  recallHitCount = 1,
  totalQueries = 1,
} = {}) {
  const queryScore = clamp01Score(queryOverlap > 0 ? Math.min(1, queryOverlap / 3) : 0.25);
  const ingredientNameScore = clamp01Score(ingredientNameOverlap > 0 ? Math.min(1, ingredientNameOverlap / 2) : 0);
  const ingredientJaccard = computeTokenJaccardScore(anchorIngredientTokens, candidateIngredientTokens);
  const ingredientSimilarity =
    ingredientJaccard == null
      ? clamp01Score(ingredientNameScore > 0 ? 0.4 + ingredientNameScore * 0.45 : 0.45)
      : clamp01Score(ingredientJaccard * 0.65 + ingredientNameScore * 0.35);

  const skinFitSimilarity = computeSkinFitSimilarity(profileSkinTags, candidateSkinTags);
  const socialReferenceScore = computeSocialReferenceScore({
    baseScore: candidateSocialScore,
    supportCount: candidateSocialSupportCount,
    hitCount: recallHitCount,
    totalQueries,
  });

  const breakdown = {
    category_score: sameCategory ? 1 : 0,
    ingredient_similarity: Number(ingredientSimilarity.toFixed(3)),
    skin_fit_similarity: Number(skinFitSimilarity.toFixed(3)),
    social_reference_score: Number(socialReferenceScore.toFixed(3)),
    query_overlap_score: Number(queryScore.toFixed(3)),
    brand_score: sameBrand ? 1 : 0,
  };

  const weighted =
    breakdown.category_score * 0.2 +
    breakdown.ingredient_similarity * 0.24 +
    breakdown.skin_fit_similarity * 0.17 +
    breakdown.social_reference_score * 0.17 +
    breakdown.query_overlap_score * 0.17 +
    breakdown.brand_score * 0.05;

  return {
    similarity_score: Number(Math.max(0.22, Math.min(0.95, weighted)).toFixed(3)),
    score_breakdown: breakdown,
  };
}

async function buildRealtimeCompetitorCandidates({
  productUrl,
  parsedProduct = null,
  keyIngredients = [],
  anchorProduct = null,
  profileSummary = null,
  lang = 'EN',
  mode = 'main_path',
  deadlineMs = 0,
  timeoutMs = PRODUCT_URL_REALTIME_COMPETITOR_TIMEOUT_MS,
  maxQueries = PRODUCT_URL_REALTIME_COMPETITOR_MAX_QUERIES,
  maxCandidates = PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  logger,
} = {}) {
  const isCn = String(lang || '').toUpperCase() === 'CN';
  const catalogSearchBaseUrls = buildRecoCatalogSearchBaseUrlCandidates({
    includeLocalFallback:
      RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
      RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED,
  });
  if (!catalogSearchBaseUrls.length) {
    return { candidates: [], queries: [], reason: 'pivota_backend_not_configured' };
  }
  const startedAt = Date.now();
  const effectiveTimeoutMs = Math.max(
    260,
    Math.min(5000, Number.isFinite(Number(timeoutMs)) ? Math.trunc(Number(timeoutMs)) : PRODUCT_URL_REALTIME_COMPETITOR_TIMEOUT_MS),
  );
  const normalizedDeadlineMs = Number.isFinite(Number(deadlineMs)) ? Math.trunc(Number(deadlineMs)) : 0;
  const softDeadlineMs = normalizedDeadlineMs > 0 ? normalizedDeadlineMs : startedAt + effectiveTimeoutMs;
  const normalizedMode = String(mode || '').trim().toLowerCase();
  const runMode =
    normalizedMode === 'sync_repair' || normalizedMode === 'async_backfill'
      ? normalizedMode
      : 'main_path';
  const syncResolveFallbackEnabled = (() => {
    const raw = String(process.env.AURORA_BFF_RECO_COMPETITOR_SYNC_RESOLVE_FALLBACK || 'false')
      .trim()
      .toLowerCase();
    return raw === 'true' || raw === '1' || raw === 'yes' || raw === 'y' || raw === 'on';
  })();
  const allowResolveFallback = runMode === 'async_backfill' || (runMode === 'sync_repair' && syncResolveFallbackEnabled);
  const searchAllMerchants =
    runMode !== 'main_path'
      ? true
      : PRODUCT_URL_REALTIME_COMPETITOR_MAIN_SEARCH_ALL_MERCHANTS;
  const transientReasons = new Set(['upstream_timeout', 'upstream_error', 'rate_limited']);
  const getRemainingMs = () => Math.max(0, softDeadlineMs - Date.now());
  const reserveAfterSearchMs =
    runMode === 'async_backfill'
      ? 180
      : runMode === 'sync_repair'
        ? 280
        : 120;
  const effectiveSearchTimeoutMs = Math.max(
    260,
    Math.min(
      effectiveTimeoutMs,
      Math.max(260, effectiveTimeoutMs - reserveAfterSearchMs),
    ),
  );

  const parsedProductObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  const anchorObj = anchorProduct && typeof anchorProduct === 'object' && !Array.isArray(anchorProduct) ? anchorProduct : parsedProductObj;
  const anchorId = pickFirstTrimmed(anchorObj?.product_id, anchorObj?.sku_id);
  const anchorBrand = pickFirstTrimmed(anchorObj?.brand);
  const anchorText = buildProductInputText(anchorObj, null) || '';

  const baseInput = buildProductInputText(parsedProductObj, null) || String(productUrl || '').trim();
  const fromCatalogQueries = buildProductCatalogQueryCandidates({
    inputText: baseInput,
    inputUrl: productUrl,
    parsedProduct: parsedProductObj,
  });
  const categoryToken = inferProductCategoryToken(`${anchorText} ${baseInput}`);
  const queries = buildRealtimeCompetitorQueryPlan({
    fromCatalogQueries,
    keyIngredients,
    parsedProduct: parsedProductObj,
    categoryToken,
    maxQueries,
  });
  if (!queries.length) return { candidates: [], queries: [], reason: 'query_missing' };

  const searchResults = await Promise.all(
    queries.map(async (queryText) => {
      const remainingMs = getRemainingMs();
      if (remainingMs < 260) {
        return {
          query: queryText,
          searched: {
            ok: false,
            products: [],
            reason: 'budget_exhausted',
            latency_ms: 0,
          },
        };
      }
      const perQueryTimeoutMs = Math.max(
        250,
        Math.min(
          effectiveSearchTimeoutMs,
          Math.max(250, remainingMs - 80),
        ),
      );
      const searched = await searchPivotaBackendProducts({
        query: queryText,
        limit: 6,
        logger,
        timeoutMs: perQueryTimeoutMs,
        searchAllMerchants,
        deadlineMs: softDeadlineMs,
      });
      return { query: queryText, searched };
    }),
  );

  const queryTokens = tokenizeProductTextForSimilarity(queries.join(' | '));
  const ingredientTokens = tokenizeProductTextForSimilarity(keyIngredients.slice(0, 6).join(' | '));
  const anchorIngredientTokens = ingredientTokens;
  const profileSkinTags = buildProfileSkinTags(profileSummary);
  const totalQueriesForRecall = Math.max(1, queries.length);

  const recallHitCountByProduct = new Map();
  for (const row of searchResults) {
    const list = Array.isArray(row?.searched?.products) ? row.searched.products : [];
    for (const product of list) {
      const normalized = normalizeRecoCatalogProduct(product);
      if (!normalized) continue;
      const productId = pickFirstTrimmed(normalized.product_id, normalized.sku_id);
      if (!productId) continue;
      const key = String(productId).toLowerCase();
      recallHitCountByProduct.set(key, (recallHitCountByProduct.get(key) || 0) + 1);
    }
  }

  const seenProduct = new Set();
  const candidates = [];
  for (const row of searchResults) {
    const list = Array.isArray(row?.searched?.products) ? row.searched.products : [];
    for (const product of list) {
      const normalized = normalizeRecoCatalogProduct(product);
      if (!normalized) continue;
      const productId = pickFirstTrimmed(normalized.product_id, normalized.sku_id);
      if (!productId) continue;
      if (anchorId && productId === anchorId) continue;
      const lowerKey = `${productId}`.toLowerCase();
      if (seenProduct.has(lowerKey)) continue;
      seenProduct.add(lowerKey);

      const brand = pickFirstTrimmed(normalized.brand);
      const name = pickFirstTrimmed(normalized.display_name, normalized.name);
      const candidateText = `${brand} ${name}`.trim().toLowerCase();
      const nameTokens = tokenizeProductTextForSimilarity(candidateText);
      const categoryUseCaseMatch = scoreCategoryUseCaseMatch({
        anchorCategoryToken: categoryToken,
        candidateNameText: candidateText,
        candidateCategoryText: normalized.category || '',
      });

      const queryOverlap = queryTokens.filter((token) => nameTokens.includes(token)).length;
      const ingredientOverlap = ingredientTokens.filter((token) => nameTokens.includes(token)).length;
      const sameBrand = anchorBrand && brand && anchorBrand.toLowerCase() === brand.toLowerCase();
      const sameCategory = categoryUseCaseMatch >= 0.78;
      const scored = scoreRealtimeCompetitorCandidate({
        queryOverlap,
        ingredientNameOverlap: ingredientOverlap,
        sameCategory,
        sameBrand,
        anchorIngredientTokens,
        candidateIngredientTokens: Array.isArray(normalized.ingredient_tokens) ? normalized.ingredient_tokens : [],
        profileSkinTags,
        candidateSkinTags: Array.isArray(normalized.skin_type_tags) ? normalized.skin_type_tags : [],
        candidateSocialScore: normalized.social_ref_score,
        candidateSocialSupportCount: normalized.social_ref_support_count,
        recallHitCount: recallHitCountByProduct.get(lowerKey) || 1,
        totalQueries: totalQueriesForRecall,
      });
      const similarityScore = scored.similarity_score;

      const whyCandidate = uniqCaseInsensitiveStrings(
        [
          sameCategory
            ? isCn
              ? `${categoryToken}`
              : `same category (${categoryToken})`
            : '',
          ingredientOverlap
            ? isCn
              ? ''
              : 'overlap with key-active tokens'
            : '',
          scored.score_breakdown.ingredient_similarity >= 0.62
            ? isCn
              ? ''
              : 'high key-ingredient similarity'
            : '',
          scored.score_breakdown.skin_fit_similarity >= 0.6
            ? isCn
              ? '/'
              : 'better match for current skin profile'
            : '',
          scored.score_breakdown.social_reference_score >= 0.65
            ? isCn
              ? '/'
              : 'strong social rating/comparison-reference signal'
            : '',
          (recallHitCountByProduct.get(lowerKey) || 0) > 1
            ? isCn
              ? ''
              : 'appears across multiple comparison queries'
            : '',
          sameBrand
            ? isCn
              ? ''
              : 'same-brand nearby option'
            : '',
          queryOverlap
            ? isCn
              ? '/'
              : 'similar name/claim keywords'
            : '',
          !sameCategory && !ingredientOverlap && !sameBrand && !queryOverlap
            ? isCn
              ? 'catalog '
              : 'catalog text-match candidate'
            : '',
        ],
        4,
      );

      const compareHighlights = uniqCaseInsensitiveStrings(
        [
          sameCategory
            ? isCn
              ? '/'
              : 'Same format/use-case, suitable as a dupe baseline.'
            : '',
          scored.score_breakdown.ingredient_similarity >= 0.55
            ? isCn
              ? ''
              : 'Ingredient similarity is high; still compare concentration and formula structure.'
            : '',
          scored.score_breakdown.skin_fit_similarity >= 0.6
            ? isCn
              ? '//'
              : 'Closer alignment with user skin profile (type/sensitivity/barrier).'
            : '',
          scored.score_breakdown.social_reference_score >= 0.65
            ? isCn
              ? '/ dupe '
              : 'Strong social reference signal; prioritize for dupe comparison.'
            : '',
        ],
        3,
      );

      candidates.push({
        product_id: productId,
        name: name || (isCn ? '' : 'Unknown product'),
        ...(brand ? { brand } : {}),
        ...(normalized.category ? { category: normalized.category } : {}),
        ...(normalized.price ? { price: normalized.price } : {}),
        source: { type: 'catalog_search' },
        source_type: 'catalog_search',
        category_use_case_match: Number(categoryUseCaseMatch.toFixed(3)),
        ...(normalized.social_raw ? { social_raw: normalized.social_raw } : {}),
        why_candidate: whyCandidate,
        similarity_score: similarityScore,
        score_breakdown: scored.score_breakdown,
        ...(compareHighlights.length ? { compare_highlights: compareHighlights } : {}),
      });
    }
  }

  candidates.sort((a, b) => {
    const scoreA = Number.isFinite(Number(a?.similarity_score)) ? Number(a.similarity_score) : 0;
    const scoreB = Number.isFinite(Number(b?.similarity_score)) ? Number(b.similarity_score) : 0;
    if (scoreB !== scoreA) return scoreB - scoreA;
    return String(a?.name || '').localeCompare(String(b?.name || ''));
  });

  let finalCandidates = candidates.slice(0, maxCandidates);
  if (finalCandidates.length) return { candidates: finalCandidates, queries, reason: null };
  const allSearchTransientFailure =
    searchResults.length > 0 &&
    searchResults.every((row) => {
      const searched = row && typeof row === 'object' ? row.searched : null;
      const reason = String(searched?.reason || '').trim().toLowerCase();
      return !searched?.ok && transientReasons.has(reason);
    });
  if (!allowResolveFallback) {
    return {
      candidates: [],
      queries,
      reason: allSearchTransientFailure ? 'catalog_search_transient_failed' : 'catalog_search_no_candidates',
    };
  }
  if (runMode === 'main_path' && getRemainingMs() < 420) {
    return {
      candidates: [],
      queries,
      reason: allSearchTransientFailure ? 'catalog_search_transient_failed' : 'catalog_search_budget_exhausted',
    };
  }

  const resolveQueryList = [...queries].sort((a, b) => {
    const lenA = String(a || '').trim().length || 999;
    const lenB = String(b || '').trim().length || 999;
    if (lenA !== lenB) return lenA - lenB;
    return String(a || '').localeCompare(String(b || ''));
  });
  const resolveResults = [];
  for (const queryText of resolveQueryList) {
    const remainingMs = getRemainingMs();
    if (remainingMs < 320) break;
    // Keep resolve fallback bounded so source can return within DAG budget.
    const resolveTimeoutMs = Math.max(260, Math.min(remainingMs - 80, CATALOG_AVAIL_RESOLVE_TIMEOUT_MS));
    // eslint-disable-next-line no-await-in-loop
    const resolved = await resolveAvailabilityProductByQuery({
      query: queryText,
      lang,
      logger,
      timeoutMs: resolveTimeoutMs,
    });
    resolveResults.push({ query: queryText, resolved });
  }
  for (const row of resolveResults) {
    const normalized = normalizeRecoCatalogProduct(row?.resolved?.product);
    if (!normalized) continue;
    const productId = pickFirstTrimmed(normalized.product_id, normalized.sku_id);
    if (!productId) continue;
    if (anchorId && productId === anchorId) continue;
    const lowerKey = `${productId}`.toLowerCase();
    if (seenProduct.has(lowerKey)) continue;
    seenProduct.add(lowerKey);

    const brand = pickFirstTrimmed(normalized.brand);
    const name = pickFirstTrimmed(normalized.display_name, normalized.name);
    const candidateText = `${brand} ${name}`.trim().toLowerCase();
    const nameTokens = tokenizeProductTextForSimilarity(candidateText);
    const categoryUseCaseMatch = scoreCategoryUseCaseMatch({
      anchorCategoryToken: categoryToken,
      candidateNameText: candidateText,
      candidateCategoryText: normalized.category || '',
    });

    const queryTokensForRow = tokenizeProductTextForSimilarity(String(row.query || ''));
    const queryOverlap = queryTokensForRow.filter((token) => nameTokens.includes(token)).length;
    const ingredientOverlap = ingredientTokens.filter((token) => nameTokens.includes(token)).length;
    const sameBrand = anchorBrand && brand && anchorBrand.toLowerCase() === brand.toLowerCase();
    const sameCategory = categoryUseCaseMatch >= 0.78;
    const scored = scoreRealtimeCompetitorCandidate({
      queryOverlap,
      ingredientNameOverlap: ingredientOverlap,
      sameCategory,
      sameBrand,
      anchorIngredientTokens,
      candidateIngredientTokens: Array.isArray(normalized.ingredient_tokens) ? normalized.ingredient_tokens : [],
      profileSkinTags,
      candidateSkinTags: Array.isArray(normalized.skin_type_tags) ? normalized.skin_type_tags : [],
      candidateSocialScore: normalized.social_ref_score,
      candidateSocialSupportCount: normalized.social_ref_support_count,
      recallHitCount: recallHitCountByProduct.get(lowerKey) || 1,
      totalQueries: totalQueriesForRecall,
    });
    const similarityScore = scored.similarity_score;

    candidates.push({
      product_id: productId,
      name: name || (isCn ? '' : 'Unknown product'),
      ...(brand ? { brand } : {}),
      ...(normalized.category ? { category: normalized.category } : {}),
      ...(normalized.price ? { price: normalized.price } : {}),
      source: { type: 'catalog_resolve_fallback' },
      source_type: 'catalog_resolve_fallback',
      category_use_case_match: Number(categoryUseCaseMatch.toFixed(3)),
      ...(normalized.social_raw ? { social_raw: normalized.social_raw } : {}),
      why_candidate: uniqCaseInsensitiveStrings(
        [
          isCn ? 'catalog resolve ' : 'catalog resolve fallback hit',
          sameCategory
            ? isCn
              ? `${categoryToken}`
              : `same category (${categoryToken})`
            : '',
          queryOverlap
            ? isCn
              ? ''
              : 'similar query keywords'
            : '',
          scored.score_breakdown.ingredient_similarity >= 0.6
            ? isCn
              ? ''
              : 'high key-ingredient similarity'
            : '',
          scored.score_breakdown.skin_fit_similarity >= 0.6
            ? isCn
              ? ''
              : 'better match for user skin profile'
            : '',
          scored.score_breakdown.social_reference_score >= 0.65
            ? isCn
              ? '/'
              : 'strong social rating/comparison-reference signal'
            : '',
          sameBrand
            ? isCn
              ? ''
              : 'same-brand nearby option'
            : '',
        ],
        4,
      ),
      similarity_score: similarityScore,
      score_breakdown: scored.score_breakdown,
      compare_highlights: uniqCaseInsensitiveStrings(
        [
          isCn
            ? ' resolve '
            : 'Derived from resolve fallback; compare formula details before final pick.',
          sameCategory
            ? isCn
              ? '/'
              : 'Same format/use-case, suitable as a dupe baseline.'
            : '',
          scored.score_breakdown.ingredient_similarity >= 0.55
            ? isCn
              ? ' dupe '
              : 'Ingredient similarity is high; candidate is suitable for dupe compare.'
            : '',
        ],
        3,
      ),
    });
  }

  candidates.sort((a, b) => {
    const scoreA = Number.isFinite(Number(a?.similarity_score)) ? Number(a.similarity_score) : 0;
    const scoreB = Number.isFinite(Number(b?.similarity_score)) ? Number(b.similarity_score) : 0;
    if (scoreB !== scoreA) return scoreB - scoreA;
    return String(a?.name || '').localeCompare(String(b?.name || ''));
  });
  finalCandidates = candidates.slice(0, maxCandidates);
  if (finalCandidates.length) return { candidates: finalCandidates, queries, reason: null };

  const allFailed = searchResults.every((row) => !(row?.searched?.ok));
  const resolveAllFailed = resolveResults.every((row) => !(row?.resolved?.ok));
  return { candidates: [], queries, reason: allFailed && resolveAllFailed ? 'catalog_search_failed' : 'catalog_search_empty' };
}

function canonicalizeProductUrlForIntelKb(rawUrl) {
  const text = String(rawUrl || '').trim();
  if (!text) return '';
  try {
    const parsed = new URL(text);
    parsed.hash = '';
    const trackingParams = ['fbclid', 'gclid', 'igshid', 'mc_cid', 'mc_eid', 'ref', 'ref_src'];
    for (const key of Array.from(parsed.searchParams.keys())) {
      const lower = String(key || '').toLowerCase();
      if (lower.startsWith('utm_') || trackingParams.includes(lower)) parsed.searchParams.delete(key);
    }
    if (typeof parsed.searchParams.sort === 'function') parsed.searchParams.sort();
    return parsed.toString();
  } catch {
    return text;
  }
}

function buildProductIntelKbKey({ productUrl, parsedProduct, lang = 'EN' } = {}) {
  const parsedProductObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  const anchorId = pickFirstTrimmed(parsedProductObj?.product_id, parsedProductObj?.sku_id);
  const langCode = String(lang || 'EN').toUpperCase() === 'CN' ? 'CN' : 'EN';
  const normalizedUrl = canonicalizeProductUrlForIntelKb(productUrl);
  const keyRaw = anchorId ? `product:${anchorId}|lang:${langCode}` : normalizedUrl ? `url:${normalizedUrl}|lang:${langCode}` : '';
  return normalizeProductIntelKbKey(keyRaw);
}

function parseTimestampMs(raw) {
  const text = String(raw || '').trim();
  if (!text) return 0;
  const ms = Date.parse(text);
  return Number.isFinite(ms) ? ms : 0;
}

function getProductAnalysisSocialSummaryCount(payload) {
  let count = 0;
  for (const block of ['competitors', 'related_products', 'dupes']) {
    const blockObj = isPlainObject(payload?.[block]) ? payload[block] : {};
    const candidates = Array.isArray(blockObj.candidates) ? blockObj.candidates : [];
    for (const candidate of candidates) {
      const summary = isPlainObject(candidate?.social_summary_user_visible)
        ? candidate.social_summary_user_visible
        : null;
      const themes = Array.isArray(summary?.themes) ? summary.themes.filter(Boolean) : [];
      if (themes.length) count += 1;
    }
  }
  return count;
}

function getProductAnalysisSocialChannels(payload) {
  const provenance = isPlainObject(payload?.provenance) ? payload.provenance : {};
  const evidence = isPlainObject(payload?.evidence) ? payload.evidence : {};
  const socialSignals = isPlainObject(evidence.social_signals) ? evidence.social_signals : {};
  const platformScores = isPlainObject(socialSignals.platform_scores) ? socialSignals.platform_scores : {};
  return extractWhitelistedSocialChannels({
    channels: [
      ...(Array.isArray(provenance.social_channels_used) ? provenance.social_channels_used : []),
      ...Object.keys(platformScores),
    ],
  });
}

function resolveProductAnalysisSocialState(payload) {
  const provenance = isPlainObject(payload?.provenance) ? payload.provenance : {};
  const nowMs = Date.now();
  const ttlMs = Number(RECO_DOGFOOD_CONFIG?.social?.ttl_ms) > 0
    ? Number(RECO_DOGFOOD_CONFIG.social.ttl_ms)
    : 72 * 60 * 60 * 1000;
  const freshUntilMs = parseTimestampMs(provenance.social_fresh_until);
  const generatedAtMs = parseTimestampMs(provenance.generated_at);
  const isFreshByWindow = freshUntilMs > nowMs;
  const isFreshByGeneratedAt = generatedAtMs > 0 && generatedAtMs + ttlMs > nowMs;
  const socialSummaryCount = getProductAnalysisSocialSummaryCount(payload);
  const socialChannels = getProductAnalysisSocialChannels(payload);
  const hasCoverage = socialSummaryCount > 0 && socialChannels.length >= 2;
  const fresh = (isFreshByWindow || isFreshByGeneratedAt) && hasCoverage;
  return {
    shouldRefresh: !fresh,
    fetchMode: fresh ? 'kb_hit' : 'stale_kb',
    socialChannels,
    socialSummaryCount,
    socialFreshUntil: freshUntilMs > 0 ? new Date(freshUntilMs).toISOString() : null,
  };
}

function applyProductAnalysisSocialProvenance(payload, patch = {}) {
  const p = isPlainObject(payload) ? payload : {};
  const provenance = isPlainObject(p.provenance) ? p.provenance : {};
  const next = {
    ...provenance,
    ...(isPlainObject(patch) ? patch : {}),
  };
  const socialChannels = extractWhitelistedSocialChannels({
    channels: Array.isArray(next.social_channels_used) ? next.social_channels_used : [],
  });
  if (socialChannels.length) next.social_channels_used = socialChannels;
  else delete next.social_channels_used;
  return {
    ...p,
    provenance: next,
  };
}

function scheduleProductIntelKbBackfill({
  productUrl,
  parsedProduct = null,
  payload = null,
  lang = 'EN',
  source = 'url_realtime_product_intel',
  sourceMeta = null,
  logger,
} = {}) {
  if (!PRODUCT_INTEL_KB_ASYNC_BACKFILL_ENABLED) return;
  const kbKey = buildProductIntelKbKey({ productUrl, parsedProduct, lang });
  if (!kbKey) return;
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) return;

  let analysisSnapshot = null;
  try {
    analysisSnapshot = JSON.parse(JSON.stringify(payload));
  } catch {
    analysisSnapshot = null;
  }
  if (!analysisSnapshot || typeof analysisSnapshot !== 'object' || Array.isArray(analysisSnapshot)) return;

  const sourceMetaObj = sourceMeta && typeof sourceMeta === 'object' && !Array.isArray(sourceMeta) ? sourceMeta : null;
  setImmediate(() => {
    upsertProductIntelKbEntry({
      kb_key: kbKey,
      analysis: analysisSnapshot,
      source,
      source_meta: sourceMetaObj,
      last_success_at: new Date().toISOString(),
      last_error: null,
    }).catch((err) => {
      logger?.warn(
        { err: err?.message || String(err), kb_key: kbKey },
        'aurora bff: async product-intel kb backfill failed',
      );
    });
  });
}

function isLikelyNoiseCompetitorName(name) {
  const text = String(name || '').trim().toLowerCase();
  if (!text) return true;
  if (text.length < 4) return true;
  if (/^skip to\b/i.test(text)) return true;
  if (/^(contact us|home|menu|search|my account|sign in|footer|header)$/i.test(text)) return true;
  if (/\b(skip to main content|skip to footer content|contact us)\b/i.test(text)) return true;
  return false;
}

function sanitizeCompetitorCandidates(candidates, max = 10) {
  const out = [];
  const seen = new Set();
  for (const item of Array.isArray(candidates) ? candidates : []) {
    const row = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
    if (!row) continue;
    const name = pickFirstTrimmed(row.name, row.display_name);
    if (!name || isLikelyNoiseCompetitorName(name)) continue;
    const brand = pickFirstTrimmed(row.brand);
    const key = `${String(brand || '').toLowerCase()}::${String(name).toLowerCase()}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push({ ...row, name });
    if (out.length >= Math.max(1, Math.min(12, Number(max) || 10))) break;
  }
  return out;
}

const RECO_PRICE_BANDS = new Set(['budget', 'mid', 'premium', 'luxury', 'unknown']);
const RECO_COMPETITOR_BLOCKED_SOURCE_TYPES = new Set(['on_page_related', 'aurora_alternatives']);

function normalizeRecoSourceObject(raw) {
  if (isPlainObject(raw)) {
    const type = String(raw.type || '').trim();
    if (type) {
      return {
        type,
        ...(typeof raw.name === 'string' && raw.name.trim() ? { name: raw.name.trim() } : {}),
        ...(typeof raw.url === 'string' && raw.url.trim() ? { url: raw.url.trim() } : {}),
      };
    }
  }
  if (typeof raw === 'string' && raw.trim()) return { type: raw.trim() };
  return { type: 'unknown' };
}

function getRecoCandidateSourceTypeToken(candidate) {
  const row = isPlainObject(candidate) ? candidate : {};
  return String((row.source && row.source.type) || row.source_type || row.sourceType || '')
    .trim()
    .toLowerCase();
}

function isBlockedCompetitorSourceType(sourceType) {
  const token = String(sourceType || '').trim().toLowerCase();
  if (!token) return false;
  return RECO_COMPETITOR_BLOCKED_SOURCE_TYPES.has(token);
}

function filterBlockedCompetitorSourceCandidates(rows) {
  return (Array.isArray(rows) ? rows : []).filter((row) => !isBlockedCompetitorSourceType(getRecoCandidateSourceTypeToken(row)));
}

function normalizeRecoEvidenceRefs(raw) {
  const out = [];
  for (const item of Array.isArray(raw) ? raw : []) {
    if (isPlainObject(item)) {
      out.push(item);
      if (out.length >= 8) break;
      continue;
    }
    if (typeof item === 'string' && item.trim()) {
      out.push({ id: item.trim() });
      if (out.length >= 8) break;
    }
  }
  return out;
}

function normalizeRecoSocialSummaryKeyword(raw) {
  const text = String(raw == null ? '' : raw).trim();
  if (!text) return '';
  if (text.length < 2 || text.length > 40) return '';
  if (/https?:\/\//i.test(text)) return '';
  if (/@/.test(text)) return '';
  if (/^(?:route_|dedupe_|internal_|fallback_|ref_)/i.test(text)) return '';
  if (/|100%\s*(?:||identical|same)|miracle\s+dupe|/i.test(text)) return '';
  return text;
}

const RECO_SOCIAL_VOLUME_BUCKETS = new Set(['low', 'mid', 'high', 'unknown']);

function normalizeRecoSocialSummaryUserVisible(raw) {
  const obj = isPlainObject(raw) ? raw : null;
  if (!obj) return null;
  const themes = uniqCaseInsensitiveStrings(Array.isArray(obj.themes) ? obj.themes : [])
    .slice(0, 3);
  if (!themes.length) return null;

  const topKeywords = uniqCaseInsensitiveStrings(
    (Array.isArray(obj.top_keywords) ? obj.top_keywords : [])
      .map((item) => normalizeRecoSocialSummaryKeyword(item))
      .filter(Boolean),
  ).slice(0, 6);
  const sentimentHint = typeof obj.sentiment_hint === 'string' ? obj.sentiment_hint.trim() : '';
  const volumeRaw = String(obj.volume_bucket || '').trim().toLowerCase();
  const volumeBucket = RECO_SOCIAL_VOLUME_BUCKETS.has(volumeRaw) ? volumeRaw : 'unknown';

  return {
    themes,
    ...(topKeywords.length ? { top_keywords: topKeywords } : {}),
    ...(sentimentHint ? { sentiment_hint: sentimentHint } : {}),
    volume_bucket: volumeBucket,
  };
}

function inferRecoPriceBand(rawBand, row) {
  const explicit = String(rawBand || '').trim().toLowerCase();
  if (RECO_PRICE_BANDS.has(explicit)) return explicit;
  const price = Number(
    row?.price ??
      row?.price_value ??
      row?.priceValue ??
      row?.amount ??
      row?.offer_price ??
      row?.offerPrice ??
      NaN,
  );
  if (!Number.isFinite(price) || price <= 0) return 'unknown';
  if (price < 20) return 'budget';
  if (price < 55) return 'mid';
  if (price < 110) return 'premium';
  return 'luxury';
}

function normalizeRecoScoreBreakdown(raw, similarityHint = null) {
  const hint = normalizeMaybePercentScore(similarityHint);
  const out = normalizeCanonicalScoreBreakdown(raw, { similarityHint: hint });
  const requiredKeys = [
    'category_use_case_match',
    'ingredient_functional_similarity',
    'skin_fit_similarity',
    'social_reference_strength',
    'price_distance',
    'brand_constraint',
    'score_total',
  ];
  for (const key of requiredKeys) {
    if (out[key] == null) out[key] = 0;
  }
  if (out.quality == null) out.quality = 0;
  return out;
}

function normalizeRecoCandidateForContract(item) {
  const row = isPlainObject(item) ? item : null;
  if (!row) return null;
  const similarityRaw = normalizeMaybePercentScore(row.similarity_score ?? row.similarityScore);
  const whyCandidate = normalizeWhyCandidateObject(row.why_candidate ?? row.whyCandidate, {
    lang: 'EN',
  });
  const source = normalizeRecoSourceObject(row.source ?? row.source_type ?? row.sourceType);
  const evidenceRefs = normalizeRecoEvidenceRefs(row.evidence_refs ?? row.evidenceRefs);
  const priceBand = inferRecoPriceBand(row.price_band ?? row.priceBand, row);
  const socialSummary = normalizeRecoSocialSummaryUserVisible(
    row.social_summary_user_visible ?? row.socialSummaryUserVisible,
  );
  const next = {
    ...row,
    ...(similarityRaw != null ? { similarity_score: similarityRaw } : {}),
    why_candidate: whyCandidate,
    score_breakdown: normalizeRecoScoreBreakdown(row.score_breakdown ?? row.scoreBreakdown, similarityRaw),
    source,
    evidence_refs: evidenceRefs,
    price_band: priceBand,
    ...(socialSummary ? { social_summary_user_visible: socialSummary } : {}),
  };
  delete next.social_raw;
  delete next.socialRaw;
  delete next.__dag_source;
  delete next.__social_channels_used;
  if (!socialSummary) delete next.social_summary_user_visible;
  return next;
}

function normalizeRecoBlockForContract(rawBlock, { max = 10 } = {}) {
  const block = isPlainObject(rawBlock) ? rawBlock : {};
  const candidates = sanitizeCompetitorCandidates(block.candidates, max)
    .map((item) => normalizeRecoCandidateForContract(item))
    .filter(Boolean);
  return {
    ...block,
    candidates,
  };
}

function normalizeRecoConfidenceEntry(raw, fallbackReason = 'contract_default') {
  const obj = isPlainObject(raw) ? raw : {};
  const scoreRaw = normalizeMaybePercentScore(obj.score);
  const score = scoreRaw == null ? 0 : scoreRaw;
  const levelRaw = String(obj.level || '').trim().toLowerCase();
  const level = levelRaw === 'high' || levelRaw === 'med' || levelRaw === 'low'
    ? levelRaw
    : score >= 0.75
      ? 'high'
      : score >= 0.4
        ? 'med'
        : 'low';
  const reasons = uniqCaseInsensitiveStrings(Array.isArray(obj.reasons) ? obj.reasons : []);
  if (!reasons.length) reasons.push(fallbackReason);
  return {
    score,
    level,
    reasons: reasons.slice(0, 8),
  };
}

function normalizeRecoConfidenceByBlock(raw) {
  const out = {};
  const src = isPlainObject(raw) ? raw : {};
  for (const [key, value] of Object.entries(src)) {
    const token = String(key || '').trim();
    if (!token) continue;
    out[token] = normalizeRecoConfidenceEntry(value, `${token}_default`);
  }
  const requiredBlocks = ['competitors', 'related_products', 'dupes'];
  for (const block of requiredBlocks) {
    if (!out[block]) out[block] = normalizeRecoConfidenceEntry(null, `${block}_default`);
  }
  return out;
}

function normalizeRecoProvenance(raw, payload) {
  const src = isPlainObject(raw) ? raw : {};
  const socialChannelsUsed = extractWhitelistedSocialChannels({
    channels: [
      ...(Array.isArray(src.social_channels_used) ? src.social_channels_used : []),
      ...(Array.isArray(src.socialChannelsUsed) ? src.socialChannelsUsed : []),
    ],
  });
  const contractVersion =
    (typeof src.contract_version === 'string' && src.contract_version.trim()) ||
    (typeof payload?.product_intel_contract_version === 'string' && payload.product_intel_contract_version.trim()) ||
    'aurora.product_intel.contract.v2';
  return {
    ...src,
    generated_at:
      (typeof src.generated_at === 'string' && src.generated_at.trim()) || new Date().toISOString(),
    contract_version: contractVersion,
    pipeline: (typeof src.pipeline === 'string' && src.pipeline.trim()) || 'aurora_product_intel_main_path',
    source: (typeof src.source === 'string' && src.source.trim()) || 'aurora_bff_routes',
    validation_mode: (typeof src.validation_mode === 'string' && src.validation_mode.trim()) || 'soft_fail',
    ...(socialChannelsUsed.length ? { social_channels_used: socialChannelsUsed } : {}),
  };
}

function normalizeRecoGuardBrandId(value) {
  return String(value == null ? '' : value).trim().toLowerCase();
}

function getRecoGuardAnchorBrandId(payload) {
  const p = isPlainObject(payload) ? payload : {};
  const assessment = isPlainObject(p.assessment) ? p.assessment : {};
  const anchor = isPlainObject(assessment.anchor_product || assessment.anchorProduct)
    ? (assessment.anchor_product || assessment.anchorProduct)
    : {};
  return pickFirstTrimmed(
    anchor.brand_id,
    anchor.brandId,
    anchor.brand,
    anchor.brand_name,
    anchor.brandName,
    p.anchor_brand_id,
    p.anchorBrandId,
  );
}

function getRecoGuardCandidateBrandId(candidate) {
  const row = isPlainObject(candidate) ? candidate : {};
  return pickFirstTrimmed(row.brand_id, row.brandId, row.brand, row.brand_name, row.brandName);
}

function getRecoGuardCandidateSourceType(candidate) {
  return getRecoCandidateSourceTypeToken(candidate);
}

function getRecoGuardTopFeatureKeys(block) {
  const token = String(block || '').trim().toLowerCase();
  if (token === 'related_products') return ['brand_affinity', 'co_view', 'kb_routine'];
  if (token === 'dupes') {
    return [
      'category_use_case_match',
      'ingredient_functional_similarity',
      'skin_fit_similarity',
      'social_reference_strength',
      'price_distance',
      'brand_constraint',
    ];
  }
  return [
    'category_use_case_match',
    'ingredient_functional_similarity',
    'skin_fit_similarity',
    'social_reference_strength',
    'price_distance',
    'quality',
    'brand_constraint',
  ];
}

const RECO_GUARD_FEATURE_REASON_KEYWORDS = {
  category_use_case_match: ['category', 'use-case', 'scenario', '', ''],
  ingredient_functional_similarity: ['ingredient', 'active', '', ''],
  skin_fit_similarity: ['skin profile', 'skin type', 'sensitive', '', ''],
  social_reference_strength: ['social', 'public', 'community', '', ''],
  price_distance: ['price', 'budget', 'cost', '', ''],
  quality: ['source quality', 'evidence', '', ''],
  brand_constraint: ['cross-brand', ''],
  brand_affinity: ['brand affinity', ''],
  co_view: ['co-view', ''],
  kb_routine: ['routine', '', ''],
};

function normalizeRecoGuardWhyCandidateText(whyCandidate) {
  if (!whyCandidate) return '';
  if (Array.isArray(whyCandidate)) return whyCandidate.map((item) => String(item || '').toLowerCase()).join(' | ');
  if (isPlainObject(whyCandidate)) {
    const reasons = Array.isArray(whyCandidate.reasons_user_visible) ? whyCandidate.reasons_user_visible : [];
    const summary = typeof whyCandidate.summary === 'string' ? whyCandidate.summary : '';
    return [summary, ...reasons].map((item) => String(item || '').toLowerCase()).join(' | ');
  }
  return String(whyCandidate || '').toLowerCase();
}

function isRecoGuardExplanationAlignedAt3(candidate, block) {
  const row = isPlainObject(candidate) ? candidate : {};
  const scoreBreakdown = isPlainObject(row.score_breakdown) ? row.score_breakdown : {};
  const scored = [];
  for (const key of getRecoGuardTopFeatureKeys(block)) {
    const value = normalizeMaybePercentScore(scoreBreakdown[key]);
    if (value == null) continue;
    scored.push({ key, value });
  }
  if (!scored.length) return false;
  scored.sort((a, b) => {
    if (b.value !== a.value) return b.value - a.value;
    return a.key.localeCompare(b.key);
  });
  const reasonsText = normalizeRecoGuardWhyCandidateText(row.why_candidate);
  if (!reasonsText.trim()) return false;
  const top3 = scored.slice(0, 3);
  return top3.every((item) =>
    (RECO_GUARD_FEATURE_REASON_KEYWORDS[item.key] || []).some((keyword) =>
      reasonsText.includes(String(keyword || '').trim().toLowerCase()),
    ),
  );
}

function observeRecoGuardrailBlockMetrics(payload, { mode = 'main_path', anchorBrandId = '' } = {}) {
  const p = isPlainObject(payload) ? payload : {};
  const modeToken = normalizeRecoGuardMode(mode);
  const anchorBrandToken = normalizeRecoGuardBrandId(anchorBrandId || getRecoGuardAnchorBrandId(p));
  let competitorsTotal = 0;
  let competitorsSameBrand = 0;
  let competitorsOnPage = 0;
  let alignmentTotal = 0;
  let alignmentAligned = 0;

  for (const block of ['competitors', 'related_products', 'dupes']) {
    const blockObj = isPlainObject(p[block]) ? p[block] : {};
    const candidates = Array.isArray(blockObj.candidates) ? blockObj.candidates : [];
    for (const candidate of candidates) {
      const sourceType = getRecoGuardCandidateSourceType(candidate) || 'unknown';
      const candidateBrandToken = normalizeRecoGuardBrandId(getRecoGuardCandidateBrandId(candidate));
      const brandRelation =
        anchorBrandToken && candidateBrandToken
          ? anchorBrandToken === candidateBrandToken
            ? 'same_brand'
            : 'cross_brand'
          : 'unknown';
      recordRecoCandidate({
        block,
        sourceType,
        brandRelation,
        mode: modeToken,
      });

      const aligned = isRecoGuardExplanationAlignedAt3(candidate, block);
      recordRecoExplanationAlignment({
        block,
        aligned,
        mode: modeToken,
      });
      alignmentTotal += 1;
      if (aligned) alignmentAligned += 1;

      if (block === 'competitors') {
        competitorsTotal += 1;
        if (sourceType === 'on_page_related') competitorsOnPage += 1;
        if (brandRelation === 'same_brand') competitorsSameBrand += 1;
      }
    }
  }

  const sameBrandRate = competitorsTotal > 0 ? competitorsSameBrand / competitorsTotal : 0;
  const onPageRate = competitorsTotal > 0 ? competitorsOnPage / competitorsTotal : 0;
  const alignmentRate = alignmentTotal > 0 ? alignmentAligned / alignmentTotal : 0;
  setRecoGuardrailRates({
    competitorsSameBrandRate: sameBrandRate,
    competitorsOnPageSourceRate: onPageRate,
    explanationAlignmentAt3: alignmentRate,
  });
  return {
    competitors_total: competitorsTotal,
    competitors_same_brand_hits: competitorsSameBrand,
    competitors_on_page_hits: competitorsOnPage,
    explanation_alignment_at3: alignmentRate,
  };
}

function applyRecoGuardrailToProductAnalysisPayload(
  payload,
  { logger, requestId = 'unknown', mode = 'main_path' } = {},
) {
  const p = isPlainObject(payload) ? payload : null;
  if (!p) return payload;
  const modeToken = normalizeRecoGuardMode(mode);
  const anchorBrandId = normalizeRecoGuardBrandId(getRecoGuardAnchorBrandId(p));
  const telemetry = observeRecoGuardrailBlockMetrics(p, { mode: modeToken, anchorBrandId });
  if (!AURORA_BFF_RECO_GUARD_ENABLED) return p;

  const competitorsObj = isPlainObject(p.competitors) ? p.competitors : {};
  const rawCandidates = Array.isArray(competitorsObj.candidates) ? competitorsObj.candidates : [];
  const nowMs = Date.now();
  const circuitBefore = getRecoGuardrailCircuitSnapshot(modeToken, nowMs);
  let circuitOpen = Boolean(circuitBefore.open);
  let circuitUntilMs = Number(circuitBefore.open_until_ms || 0);
  let autoRollbackFlag = false;
  let circuitRecovered = false;
  const violations = [];
  let filteredCandidates = [];

  for (const candidate of rawCandidates) {
    const sourceType = getRecoGuardCandidateSourceType(candidate);
    const candidateBrandId = normalizeRecoGuardBrandId(getRecoGuardCandidateBrandId(candidate));
    const sameBrandBlocked =
      AURORA_BFF_RECO_GUARD_STRICT_DEFAULT_MODE &&
      Boolean(anchorBrandId) &&
      Boolean(candidateBrandId) &&
      anchorBrandId === candidateBrandId;
    const onPageBlocked = sourceType === 'on_page_related';
    const legacySourceBlocked = sourceType === 'aurora_alternatives';
    if (!sameBrandBlocked && !onPageBlocked && !legacySourceBlocked) {
      filteredCandidates.push(candidate);
      continue;
    }
    if (sameBrandBlocked) {
      violations.push({
        violation_type: 'same_brand',
        source_type: sourceType || 'unknown',
        candidate_brand_id: candidateBrandId || '',
      });
    }
    if (onPageBlocked) {
      violations.push({
        violation_type: 'on_page_source',
        source_type: sourceType || 'unknown',
        candidate_brand_id: candidateBrandId || '',
      });
    }
    if (legacySourceBlocked) {
      violations.push({
        violation_type: 'legacy_alternatives_source',
        source_type: sourceType || 'unknown',
        candidate_brand_id: candidateBrandId || '',
      });
    }
  }

  if (circuitOpen && AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED) {
    if (!violations.length && filteredCandidates.length) {
      const state = getRecoGuardrailCircuitState(modeToken);
      state.open_until_ms = 0;
      state.consecutive_violations = 0;
      state.last_violations = [];
      circuitOpen = false;
      circuitUntilMs = 0;
      circuitRecovered = true;
      logger?.info?.(
        {
          event_name: 'reco_guardrail_circuit_recovered',
          request_id: requestId,
          mode: modeToken,
          block: 'competitors',
          candidates_after: filteredCandidates.length,
        },
        'aurora bff: reco guardrail circuit recovered',
      );
    } else {
      autoRollbackFlag = true;
      filteredCandidates = [];
    }
  }

  const violationTypes = uniqCaseInsensitiveStrings(
    violations.map((item) => item.violation_type),
    8,
  );
  let circuitOpenedNow = false;
  if (violations.length && !circuitOpen) {
    const circuitUpdate = markRecoGuardrailCircuitViolation(modeToken, violationTypes, nowMs);
    circuitOpenedNow = Boolean(circuitUpdate.opened);
    circuitOpen = Boolean(circuitUpdate.snapshot.open);
    circuitUntilMs = Number(circuitUpdate.snapshot.open_until_ms || 0);
    if (circuitOpenedNow) {
      autoRollbackFlag = true;
      filteredCandidates = [];
      recordRecoGuardrailCircuitOpen({ mode: modeToken });
      logger?.warn(
        {
          event_name: 'reco_guardrail_circuit_opened',
          request_id: requestId,
          mode: modeToken,
          block: 'competitors',
          circuit_open: true,
          circuit_until_ms: circuitUntilMs,
          auto_rollback_flag: true,
        },
        'aurora bff: reco guardrail circuit opened',
      );
    }
  } else if (!circuitOpen) {
    markRecoGuardrailCircuitSuccess(modeToken);
  }

  const effectiveCandidates =
    circuitOpen && AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED ? [] : filteredCandidates;
  const hasSanitizeAction = effectiveCandidates.length !== rawCandidates.length || violations.length > 0;
  const guardrailApplied = Boolean(hasSanitizeAction || (circuitOpen && AURORA_BFF_RECO_GUARD_CIRCUIT_ENABLED));

  for (const violation of violations) {
    recordRecoGuardrailViolation({
      block: 'competitors',
      violationType: violation.violation_type,
      mode: modeToken,
      action: circuitOpen ? 'circuit_drop' : 'sanitize',
    });
    logger?.warn(
      {
        event_name: 'reco_guardrail_violation',
        request_id: requestId,
        mode: modeToken,
        block: 'competitors',
        violation_type: violation.violation_type,
        source_type: violation.source_type || 'unknown',
        anchor_brand_id: anchorBrandId || '',
        candidate_brand_id: violation.candidate_brand_id || '',
        action: circuitOpen ? 'circuit_drop' : 'sanitize',
        circuit_open: Boolean(circuitOpen),
        circuit_until_ms: circuitOpen ? circuitUntilMs : 0,
        auto_rollback_flag: Boolean(autoRollbackFlag),
      },
      'aurora bff: reco guardrail violation',
    );
  }

  const existingCodes = getProductAnalysisInternalMissingCodes(p);
  const guardCodes = [];
  if (guardrailApplied) guardCodes.push('reco_guardrail_applied');
  if (violationTypes.includes('same_brand')) guardCodes.push('reco_guardrail_same_brand_filtered');
  if (violationTypes.includes('on_page_source')) guardCodes.push('reco_guardrail_on_page_filtered');
  if (circuitOpen) guardCodes.push('reco_guardrail_circuit_open');
  if (circuitRecovered) guardCodes.push('reco_guardrail_circuit_recovered');
  const nextInternalCodes = uniqCaseInsensitiveStrings(
    [...existingCodes, ...guardCodes],
    32,
  );

  const confidenceByBlock = normalizeRecoConfidenceByBlock(p.confidence_by_block);
  if (guardrailApplied) {
    const prevCompetitorConfidence = isPlainObject(confidenceByBlock.competitors)
      ? confidenceByBlock.competitors
      : normalizeRecoConfidenceEntry(null, 'competitors_default');
    const reasons = uniqCaseInsensitiveStrings(
      [
        ...((Array.isArray(prevCompetitorConfidence.reasons) ? prevCompetitorConfidence.reasons : [])),
        ...(violationTypes.includes('same_brand') ? ['guardrail_same_brand_filtered'] : []),
        ...(violationTypes.includes('on_page_source') ? ['guardrail_on_page_filtered'] : []),
        ...(violationTypes.includes('legacy_alternatives_source') ? ['guardrail_legacy_alternatives_source_filtered'] : []),
        ...(circuitOpen ? ['guardrail_circuit_open'] : []),
      ],
      8,
    );
    confidenceByBlock.competitors = {
      score: Math.min(circuitOpen ? 0.05 : 0.2, Number(prevCompetitorConfidence.score) || 1),
      level: 'low',
      reasons: reasons.length ? reasons : ['guardrail_applied'],
    };
  }

  const provenanceObj = isPlainObject(p.provenance) ? p.provenance : {};
  const nextProvenance = {
    ...provenanceObj,
    guardrail_applied: guardrailApplied,
    guardrail_violations: uniqCaseInsensitiveStrings(
      [
        ...(Array.isArray(provenanceObj.guardrail_violations) ? provenanceObj.guardrail_violations : []),
        ...violationTypes,
        ...(circuitOpen ? ['circuit_open'] : []),
      ],
      8,
    ),
    guardrail_circuit_open: Boolean(circuitOpen),
    guardrail_circuit_until_ms: circuitOpen ? circuitUntilMs : 0,
    auto_rollback_flag: Boolean(autoRollbackFlag),
  };

  logger?.info?.(
    {
      event_name: 'reco_guardrail_gate_result',
      request_id: requestId,
      mode: modeToken,
      block: 'competitors',
      violation_count: violations.length,
      action: circuitOpen ? 'circuit_drop' : hasSanitizeAction ? 'sanitize' : 'pass',
      circuit_open: Boolean(circuitOpen),
      circuit_until_ms: circuitOpen ? circuitUntilMs : 0,
      auto_rollback_flag: Boolean(autoRollbackFlag),
      candidates_before: rawCandidates.length,
      candidates_after: effectiveCandidates.length,
      competitors_same_brand_rate: telemetry.competitors_total > 0
        ? telemetry.competitors_same_brand_hits / telemetry.competitors_total
        : 0,
      competitors_on_page_source_rate: telemetry.competitors_total > 0
        ? telemetry.competitors_on_page_hits / telemetry.competitors_total
        : 0,
      explanation_alignment_at3: telemetry.explanation_alignment_at3,
    },
    'aurora bff: reco guardrail gate result',
  );

  return applyProductAnalysisGapContract({
    ...p,
    competitors: {
      ...competitorsObj,
      candidates: effectiveCandidates,
    },
    confidence_by_block: confidenceByBlock,
    provenance: nextProvenance,
    internal_debug_codes: nextInternalCodes,
    missing_info_internal: nextInternalCodes,
  });
}

function finalizeProductAnalysisRecoContract(payload, { logger, requestId = 'unknown', mode = 'main_path' } = {}) {
  const p = isPlainObject(payload) ? payload : {};
  const internalCodes = uniqCaseInsensitiveStrings(
    [
      ...getProductAnalysisInternalMissingCodes(p),
      ...(Array.isArray(p.missing_info_internal) ? p.missing_info_internal : []),
      ...(Array.isArray(p.internal_debug_codes) ? p.internal_debug_codes : []),
    ],
    32,
  );
  const normalized = applyProductAnalysisGapContract({
    ...p,
    competitors: normalizeRecoBlockForContract(p.competitors),
    related_products: normalizeRecoBlockForContract(p.related_products),
    dupes: normalizeRecoBlockForContract(p.dupes),
    confidence_by_block: normalizeRecoConfidenceByBlock(p.confidence_by_block),
    provenance: normalizeRecoProvenance(p.provenance, p),
    missing_info_internal: internalCodes,
    internal_debug_codes: internalCodes,
  });

  const validation = validateRecoBlocksResponse(normalized);
  if (validation.ok) {
    return applyRecoGuardrailToProductAnalysisPayload(normalized, {
      logger,
      requestId,
      mode,
    });
  }

  const fallbackCodes = uniqCaseInsensitiveStrings(
    [...internalCodes, 'reco_blocks_schema_invalid'],
    32,
  );
  logger?.warn(
    { errors: validation.errors.slice(0, 8) },
    'aurora bff: reco blocks schema invalid; soft-fail fallback applied',
  );
  const fallbackPayload = applyProductAnalysisGapContract({
    ...normalized,
    competitors: { candidates: [] },
    related_products: { candidates: [] },
    dupes: { candidates: [] },
    confidence_by_block: normalizeRecoConfidenceByBlock({}),
    provenance: normalizeRecoProvenance(normalized.provenance, normalized),
    missing_info_internal: fallbackCodes,
    internal_debug_codes: fallbackCodes,
  });
  return applyRecoGuardrailToProductAnalysisPayload(fallbackPayload, {
    logger,
    requestId,
    mode,
  });
}

function buildRouterAnchorFromProductLike(anchorProduct) {
  const anchor = anchorProduct && typeof anchorProduct === 'object' && !Array.isArray(anchorProduct) ? anchorProduct : null;
  if (!anchor) return {};
  return {
    brand_id: pickFirstTrimmed(anchor.brand_id, anchor.brandId, anchor.brand, anchor.brand_name, anchor.brandName),
    category_taxonomy: anchor.category_taxonomy || anchor.categoryTaxonomy || anchor.category || null,
    price: anchor.price || null,
  };
}

function summarizeRouterReasonCodes(routeOut) {
  const out = [];
  const seen = new Set();
  for (const row of Array.isArray(routeOut?.internal_reason_codes) ? routeOut.internal_reason_codes : []) {
    const reasons = Array.isArray(row?.reason_codes) ? row.reason_codes : [];
    for (const raw of reasons) {
      const token = String(raw || '').trim();
      if (!token) continue;
      const normalized = `router.${token}`;
      if (seen.has(normalized)) continue;
      seen.add(normalized);
      out.push(normalized);
      if (out.length >= 24) return out;
    }
  }
  return out;
}

function routeCompetitorCandidatePools({
  anchorProduct = null,
  candidates = [],
  ctx = null,
  maxCandidates = PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
} = {}) {
  const routed = routeCandidates(
    buildRouterAnchorFromProductLike(anchorProduct),
    Array.isArray(candidates) ? candidates : [],
    ctx || {
      allow_same_brand_competitors: false,
      allow_same_brand_dupes: false,
    },
  );
  return {
    routed,
    compPool: filterBlockedCompetitorSourceCandidates(sanitizeCompetitorCandidates(routed?.comp_pool, maxCandidates)),
    relPool: sanitizeCompetitorCandidates(routed?.rel_pool, maxCandidates),
    dupePool: filterBlockedCompetitorSourceCandidates(sanitizeCompetitorCandidates(routed?.dupe_pool, maxCandidates)),
  };
}

function buildRecoBlocksTimeouts() {
  return {
    catalog_ann: AURORA_BFF_RECO_BLOCKS_TIMEOUT_CATALOG_ANN_MS,
    ingredient_index: AURORA_BFF_RECO_BLOCKS_TIMEOUT_INGREDIENT_INDEX_MS,
    skin_fit_light: AURORA_BFF_RECO_BLOCKS_TIMEOUT_SKIN_FIT_LIGHT_MS,
    kb_backfill: AURORA_BFF_RECO_BLOCKS_TIMEOUT_KB_BACKFILL_MS,
    dupe_pipeline: AURORA_BFF_RECO_BLOCKS_TIMEOUT_DUPE_PIPELINE_MS,
    on_page_related: AURORA_BFF_RECO_BLOCKS_TIMEOUT_ON_PAGE_RELATED_MS,
  };
}

function buildRecoBlocksRouterCtx() {
  return {
    allow_same_brand_competitors: false,
    allow_same_brand_dupes: false,
  };
}

function getRecoDogfoodSessionId(req, ctx, explicitSessionId = '') {
  const fromBody = pickFirstTrimmed(explicitSessionId);
  if (fromBody) return fromBody;
  const fromHeader = pickFirstTrimmed(
    req?.get?.('X-Session-ID'),
    req?.get?.('x-session-id'),
    req?.headers?.['x-session-id'],
  );
  if (fromHeader) return fromHeader;
  return pickFirstTrimmed(ctx?.aurora_uid, ctx?.trace_id, ctx?.request_id, 'anonymous');
}

function normalizeDogfoodFeaturesEffective(raw = null, { autoRollback = false } = {}) {
  const src = isPlainObject(raw) ? raw : {};
  const baseline = {
    interleave: Boolean(RECO_DOGFOOD_CONFIG.dogfood_mode && RECO_DOGFOOD_CONFIG.interleave.enabled),
    exploration: Boolean(RECO_DOGFOOD_CONFIG.dogfood_mode && RECO_DOGFOOD_CONFIG.exploration.enabled),
    async_rerank: Boolean(RECO_DOGFOOD_CONFIG.dogfood_mode && RECO_DOGFOOD_CONFIG.ui.allow_block_internal_rerank_on_async),
    show_employee_feedback_controls: Boolean(
      RECO_DOGFOOD_CONFIG.dogfood_mode && RECO_DOGFOOD_CONFIG.ui.show_employee_feedback_controls,
    ),
  };
  const merged = {
    interleave: src.interleave == null ? baseline.interleave : Boolean(src.interleave),
    exploration: src.exploration == null ? baseline.exploration : Boolean(src.exploration),
    async_rerank: src.async_rerank == null ? baseline.async_rerank : Boolean(src.async_rerank),
    show_employee_feedback_controls:
      src.show_employee_feedback_controls == null
        ? baseline.show_employee_feedback_controls
        : Boolean(src.show_employee_feedback_controls),
  };
  if (!autoRollback) return merged;
  return {
    ...merged,
    interleave: false,
    exploration: false,
    async_rerank: false,
    show_employee_feedback_controls: false,
  };
}

function getRecoBlockCandidates(payload, block) {
  const obj = isPlainObject(payload?.[block]) ? payload[block] : {};
  return Array.isArray(obj.candidates) ? obj.candidates : [];
}

function scheduleDogfoodAsyncBlockPatches({
  ticketId,
  payload,
  mode = 'main_path',
  logger,
  allowAsyncRerank = false,
  lang = 'EN',
} = {}) {
  if (!RECO_DOGFOOD_CONFIG.dogfood_mode) return;
  if (!allowAsyncRerank) return;
  const ticket = String(ticketId || '').trim();
  if (!ticket) return;
  const sourcePayload = isPlainObject(payload) ? payload : {};
  setTimeout(() => {
    social_enrich_async({
      logger,
      mode,
      lang,
      payload: sourcePayload,
      skip_kb_write: true,
      apply_async_patch: ({ block, next_candidates }) =>
        applyAsyncBlockPatch({
          ticketId: ticket,
          block,
          nextCandidates: Array.isArray(next_candidates) ? next_candidates : [],
        }),
      on_async_update: ({ block, result, changed_count }) => {
        const changedCount = Number.isFinite(Number(changed_count)) ? Math.max(0, Math.trunc(Number(changed_count))) : 0;
        const normalizedResult = String(result || '').trim().toLowerCase() || 'skipped';
        recordRecoAsyncUpdate({
          block,
          result: normalizedResult,
          mode,
          changedCount,
        });
        logger?.info?.(
          {
            event_name: 'reco_async_update',
            ticket_id: ticket,
            block,
            mode,
            result: normalizedResult,
            changed_count: changedCount,
          },
          'aurora bff: reco async update',
        );
      },
    });
  }, 180);
}

function augmentProductAnalysisPayloadForDogfood({
  payload,
  req,
  ctx,
  mode = 'main_path',
  cardId = '',
  sessionId = '',
  logger,
} = {}) {
  const p = isPlainObject(payload) ? payload : null;
  if (!p) return payload;

  const provenance = isPlainObject(p.provenance) ? { ...p.provenance } : {};
  const autoRollback = provenance.auto_rollback_flag === true || provenance.guardrail_circuit_open === true;
  const featuresEffective = normalizeDogfoodFeaturesEffective(provenance.dogfood_features_effective, {
    autoRollback,
  });
  provenance.dogfood_mode = Boolean(RECO_DOGFOOD_CONFIG.dogfood_mode);
  provenance.dogfood_features_effective = featuresEffective;
  provenance.interleave = isPlainObject(provenance.interleave)
    ? provenance.interleave
    : {
      enabled: featuresEffective.interleave,
      rankerA: RECO_DOGFOOD_CONFIG.interleave.rankerA,
      rankerB: RECO_DOGFOOD_CONFIG.interleave.rankerB,
    };
  provenance.lock_top_n_on_first_paint = RECO_DOGFOOD_CONFIG.ui.lock_top_n_on_first_paint;

  const anchorProductId = pickFirstTrimmed(
    p?.assessment?.anchor_product?.product_id,
    p?.assessment?.anchor_product?.sku_id,
    p?.assessment?.anchor_product?.name,
  );
  const blocks = {
    competitors: getRecoBlockCandidates(p, 'competitors'),
    related_products: getRecoBlockCandidates(p, 'related_products'),
    dupes: getRecoBlockCandidates(p, 'dupes'),
  };

  const trackingPayload = isPlainObject(p.candidate_tracking)
    ? p.candidate_tracking
    : isPlainObject(p.tracking)
      ? p.tracking
      : null;
  const trackingByBlock = isPlainObject(trackingPayload?.by_block) ? trackingPayload.by_block : null;
  const interleaveAttributionByBlock = isPlainObject(trackingPayload?.interleave_attribution_by_block)
    ? trackingPayload.interleave_attribution_by_block
    : null;
  const explorationKeysByBlock = isPlainObject(trackingPayload?.exploration_keys_by_block)
    ? trackingPayload.exploration_keys_by_block
    : null;

  if (RECO_DOGFOOD_CONFIG.dogfood_mode) {
    registerRecoTrackingSnapshot({
      requestId: ctx?.request_id,
      sessionId: getRecoDogfoodSessionId(req, ctx, sessionId),
      anchorProductId,
      blocks,
      trackingByBlock,
      interleaveAttribution: interleaveAttributionByBlock,
      explorationKeys: explorationKeysByBlock,
      ttlMs: RECO_DOGFOOD_CONFIG.async.poll_ttl_ms,
    });

    const ticket = createAsyncTicket({
      requestId: ctx?.request_id,
      cardId,
      lockTopN: RECO_DOGFOOD_CONFIG.ui.lock_top_n_on_first_paint,
      initialPayload: {
        competitors: p.competitors,
        related_products: p.related_products,
        dupes: p.dupes,
        provenance,
      },
      ttlMs: RECO_DOGFOOD_CONFIG.async.poll_ttl_ms,
    });
    provenance.async_ticket_id = ticket.ticketId;
    scheduleDogfoodAsyncBlockPatches({
      ticketId: ticket.ticketId,
      payload: p,
      mode,
      logger,
      allowAsyncRerank: featuresEffective.async_rerank === true,
      lang: ctx?.lang,
    });
  }

  for (const block of ['competitors', 'related_products', 'dupes']) {
    const map = isPlainObject(trackingByBlock?.[block]) ? trackingByBlock[block] : null;
    if (!map) continue;
    const explorationCount = Object.values(map).reduce(
      (sum, entry) => sum + (isPlainObject(entry) && entry.was_exploration_slot === true ? 1 : 0),
      0,
    );
    if (explorationCount > 0) {
      recordRecoExplorationSlot({
        block,
        mode,
        delta: explorationCount,
      });
    }
  }

  const nextPayload = {
    ...p,
    provenance,
  };
  delete nextPayload.candidate_tracking;
  delete nextPayload.candidate_tracking_internal;
  delete nextPayload.internal_attribution;
  delete nextPayload.tracking;
  if (isPlainObject(nextPayload.provenance)) {
    nextPayload.provenance = { ...nextPayload.provenance };
    delete nextPayload.provenance.candidate_tracking;
    delete nextPayload.provenance.candidate_tracking_internal;
    delete nextPayload.provenance.internal_attribution;
    delete nextPayload.provenance.internal_reason_codes;
  }
  return nextPayload;
}

function augmentEnvelopeProductAnalysisCardsForDogfood({
  envelope,
  req,
  ctx,
  mode = 'main_path',
  sessionId = '',
  logger,
} = {}) {
  const env = isPlainObject(envelope) ? { ...envelope } : envelope;
  if (!isPlainObject(env)) return envelope;
  const cards = Array.isArray(env.cards) ? env.cards : [];
  env.cards = cards.map((card) => {
    if (!isPlainObject(card)) return card;
    const type = String(card.type || '').trim().toLowerCase();
    if (type !== 'product_analysis') return card;
    return {
      ...card,
      payload: augmentProductAnalysisPayloadForDogfood({
        payload: card.payload,
        req,
        ctx,
        mode,
        cardId: card.card_id,
        sessionId,
        logger,
      }),
    };
  });
  return env;
}

async function augmentEnvelopeProductAnalysisCardsWithPrelabelSuggestions({
  envelope,
  logger,
} = {}) {
  if (!RECO_DOGFOOD_CONFIG.dogfood_mode || !RECO_DOGFOOD_CONFIG.prelabel?.enabled) return envelope;
  const env = isPlainObject(envelope) ? { ...envelope } : envelope;
  if (!isPlainObject(env)) return envelope;
  const cards = Array.isArray(env.cards) ? env.cards : [];
  if (!cards.length) return env;

  env.cards = await Promise.all(
    cards.map(async (card) => {
      if (!isPlainObject(card)) return card;
      const type = String(card.type || '').trim().toLowerCase();
      if (type !== 'product_analysis') return card;
      const payload = isPlainObject(card.payload) ? card.payload : null;
      if (!payload) return card;

      const anchorProductId = pickFirstTrimmed(
        payload?.assessment?.anchor_product?.product_id,
        payload?.assessment?.anchor_product?.sku_id,
        payload?.assessment?.anchorProduct?.product_id,
        payload?.assessment?.anchorProduct?.sku_id,
      );
      if (!anchorProductId) return card;

      try {
        const suggestions = await loadSuggestionsForAnchor({
          anchor_product_id: anchorProductId,
          limit: 220,
        });
        if (!Array.isArray(suggestions) || !suggestions.length) return card;
        return {
          ...card,
          payload: attachPrelabelSuggestionsToPayload(payload, suggestions),
        };
      } catch (err) {
        logger?.warn?.(
          {
            err: err?.message || String(err),
            anchor_product_id: anchorProductId,
          },
          'aurora bff: attach prelabel suggestions failed',
        );
        return card;
      }
    }),
  );
  return env;
}

async function fetchProductPageHtmlForReco({
  productUrl,
  timeoutMs = AURORA_BFF_RECO_BLOCKS_TIMEOUT_ON_PAGE_RELATED_MS,
  logger,
} = {}) {
  const urlText = String(productUrl || '').trim();
  if (!/^https?:\/\//i.test(urlText)) return '';
  try {
    const resp = await axios.get(urlText, {
      timeout: Math.max(120, Number(timeoutMs) || AURORA_BFF_RECO_BLOCKS_TIMEOUT_ON_PAGE_RELATED_MS),
      maxContentLength: PRODUCT_URL_INGREDIENT_ANALYSIS_MAX_BYTES,
      maxBodyLength: PRODUCT_URL_INGREDIENT_ANALYSIS_MAX_BYTES,
      responseType: 'text',
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; AuroraBff/1.0; +https://aurora.pivota.cc)',
        Accept: 'text/html,application/xhtml+xml',
      },
      validateStatus: (status) => status >= 200 && status < 400,
    });
    return typeof resp?.data === 'string' ? resp.data : '';
  } catch (err) {
    logger?.debug?.(
      { err: err?.message || String(err), url: urlText },
      'aurora bff: reco blocks on-page html fetch failed',
    );
    return '';
  }
}

async function runRecoBlocksForUrl({
  productUrl,
  anchorProduct = null,
  parsedProduct = null,
  keyIngredients = [],
  profileSummary = null,
  lang = 'EN',
  mode = 'main_path',
  logger,
  html = '',
  existingPayload = null,
  budgetMs = AURORA_BFF_RECO_BLOCKS_BUDGET_MS,
  maxCandidates = PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
} = {}) {
  if (!AURORA_BFF_RECO_BLOCKS_DAG_ENABLED) return null;
  const urlText = String(productUrl || '').trim();
  if (!/^https?:\/\//i.test(urlText)) return null;

  const anchorObj =
    (anchorProduct && typeof anchorProduct === 'object' && !Array.isArray(anchorProduct) ? anchorProduct : null) ||
    (parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null) ||
    null;

  const payloadObj = existingPayload && typeof existingPayload === 'object' && !Array.isArray(existingPayload)
    ? existingPayload
    : null;
  const modeToken = String(mode || '').trim().toLowerCase() || 'main_path';

  const kbCompetitors = sanitizeCompetitorCandidates(payloadObj?.competitors?.candidates, maxCandidates).map((row) => ({
    ...row,
    source: normalizeRecoSourceObject(row?.source || row?.source_type || 'kb_backfill'),
    source_type: String(row?.source?.type || row?.source_type || 'kb_backfill'),
  }));
  const kbRelated = sanitizeCompetitorCandidates(payloadObj?.related_products?.candidates, maxCandidates).map((row) => ({
    ...row,
    source: normalizeRecoSourceObject(row?.source || row?.source_type || 'on_page_related'),
    source_type: String(row?.source?.type || row?.source_type || 'on_page_related'),
  }));
  const kbDupes = sanitizeCompetitorCandidates(payloadObj?.dupes?.candidates, maxCandidates).map((row) => ({
    ...row,
    source: normalizeRecoSourceObject(row?.source || row?.source_type || 'kb_backfill'),
    source_type: String(row?.source?.type || row?.source_type || 'kb_backfill'),
  }));

  const sourceFns = {
    catalog_ann: async ({ timeout_ms: timeoutMs, deadline_ms: deadlineMs }) => {
      const queryLimit =
        modeToken === 'async_backfill'
          ? PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_QUERIES
          : modeToken === 'sync_repair'
            ? PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_MAX_QUERIES
            : PRODUCT_URL_REALTIME_COMPETITOR_MAX_QUERIES;
      return buildRealtimeCompetitorCandidates({
        productUrl: urlText,
        parsedProduct: anchorObj,
        keyIngredients: Array.isArray(keyIngredients) ? keyIngredients : [],
        anchorProduct: anchorObj,
        profileSummary,
        lang,
        mode: modeToken,
        deadlineMs,
        timeoutMs: Math.max(120, Number(timeoutMs) || PRODUCT_URL_REALTIME_COMPETITOR_TIMEOUT_MS),
        maxQueries: queryLimit,
        maxCandidates,
        logger,
      });
    },
    ingredient_index: async () => ({
      candidates: [],
      meta: {
        key_ingredients: Array.isArray(keyIngredients) ? keyIngredients.slice(0, 8) : [],
      },
    }),
    skin_fit_light: async () => ({
      candidates: [],
      meta: {
        profile_skin_tags: buildProfileSkinTags(profileSummary),
      },
    }),
    kb_backfill: async () => ({
      competitors: kbCompetitors,
      related_products: kbRelated,
      dupes: kbDupes,
      candidates: [],
      meta: {
        from_existing_payload: Boolean(payloadObj),
      },
    }),
    dupe_pipeline: async () => ({
      candidates: [],
      dupes: kbDupes,
      meta: {
        mode,
      },
    }),
    on_page_related: async ({ timeout_ms: timeoutMs }) => {
      let sourceHtml = typeof html === 'string' ? html : '';
      if (!sourceHtml) {
        sourceHtml = await fetchProductPageHtmlForReco({
          productUrl: urlText,
          timeoutMs,
          logger,
        });
      }
      if (!sourceHtml) return { candidates: [] };
      return {
        candidates: buildOnPageCompetitorCandidates({
          html: sourceHtml,
          productUrl: urlText,
          anchorProduct: anchorObj,
          profileSummary,
          lang,
          maxCandidates,
        }),
      };
    },
  };

  return recoBlocks(
    buildRouterAnchorFromProductLike(anchorObj),
    {
      mode,
      lang,
      on_page_mode: AURORA_BFF_RECO_BLOCKS_ON_PAGE_MODE,
      logger,
      max_candidates: maxCandidates,
      timeouts_ms: (() => {
        const next = buildRecoBlocksTimeouts();
        if (modeToken === 'sync_repair') {
          next.catalog_ann = Math.max(
            next.catalog_ann,
            Math.max(
              1800,
              Math.min(PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS, 2600),
            ),
          );
        } else if (modeToken === 'async_backfill') {
          next.catalog_ann = Math.max(
            next.catalog_ann,
            Math.min(PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_TIMEOUT_MS, 2600),
          );
        }
        return next;
      })(),
      router_ctx: buildRecoBlocksRouterCtx(),
      dogfood_config: RECO_DOGFOOD_CONFIG,
      pool_size: RECO_DOGFOOD_CONFIG.retrieval.pool_size,
      sources: sourceFns,
    },
    budgetMs,
  );
}

function sanitizeCompetitorsInPayload(payload, { max = 10 } = {}) {
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return payload;
  const competitorsObj = p.competitors && typeof p.competitors === 'object' && !Array.isArray(p.competitors) ? p.competitors : null;
  const rawCandidates = Array.isArray(competitorsObj?.candidates) ? competitorsObj.candidates : [];
  if (!rawCandidates.length) return payload;
  const assessment = p.assessment && typeof p.assessment === 'object' && !Array.isArray(p.assessment) ? p.assessment : null;
  const anchorProduct = assessment && typeof assessment.anchor_product === 'object' && !Array.isArray(assessment.anchor_product)
    ? assessment.anchor_product
    : null;
  const routedPools = routeCompetitorCandidatePools({
    anchorProduct,
    candidates: rawCandidates,
    maxCandidates: max,
  });
  const cleanCandidates = routedPools.compPool;
  const recoveredRelated = routedPools.relPool;
  const rawLen = rawCandidates.length;
  const cleanLen = cleanCandidates.length;
  const existingRelatedObj = p.related_products && typeof p.related_products === 'object' && !Array.isArray(p.related_products)
    ? p.related_products
    : null;
  const existingRelated = Array.isArray(existingRelatedObj?.candidates) ? existingRelatedObj.candidates : [];
  const mergedRelated = sanitizeCompetitorCandidates([...existingRelated, ...recoveredRelated], max);
  const hasChanged = cleanLen !== rawLen || mergedRelated.length !== existingRelated.length;
  if (!hasChanged) return payload;

  const missingInfo = getProductAnalysisInternalMissingCodes(p);
  const nextMissingInfo = cleanLen
    ? uniqCaseInsensitiveStrings(
        [
          ...stripCompetitorMissingTokens(missingInfo),
          ...(cleanLen < PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT ? ['competitors_low_coverage'] : []),
        ],
        16,
      )
    : uniqCaseInsensitiveStrings([...missingInfo, 'competitors_missing', 'competitor_candidates_filtered_noise'], 16);

  return applyProductAnalysisGapContract({
    ...p,
    competitors: {
      ...(competitorsObj || {}),
      candidates: cleanCandidates,
    },
    ...(mergedRelated.length
      ? {
        related_products: {
          ...(existingRelatedObj || {}),
          candidates: mergedRelated,
        },
      }
      : {}),
    internal_debug_codes: uniqCaseInsensitiveStrings([
      ...nextMissingInfo,
      ...summarizeRouterReasonCodes(routedPools.routed),
    ], 32),
  });
}

function getCompetitorCandidatesFromPayload(payload, { max = 10 } = {}) {
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return [];
  const competitors =
    p.competitors && typeof p.competitors === 'object' && !Array.isArray(p.competitors)
      ? p.competitors
      : null;
  return sanitizeCompetitorCandidates(competitors?.candidates, max);
}

function getEffectiveCompetitorCoverageFromPayload(payload, { max = 10 } = {}) {
  const candidates = getCompetitorCandidatesFromPayload(payload, { max });
  if (!candidates.length) return 0;
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return candidates.length;
  const assessment =
    p.assessment && typeof p.assessment === 'object' && !Array.isArray(p.assessment)
      ? p.assessment
      : null;
  const anchorProduct =
    assessment &&
    assessment.anchor_product &&
    typeof assessment.anchor_product === 'object' &&
    !Array.isArray(assessment.anchor_product)
      ? assessment.anchor_product
      : null;
  if (!anchorProduct) return candidates.length;
  const routedPools = routeCompetitorCandidatePools({
    anchorProduct,
    candidates,
    maxCandidates: Math.max(1, Math.min(12, Number(max) || 10)),
  });
  return Array.isArray(routedPools?.compPool) ? routedPools.compPool.length : 0;
}

function hasCompetitorCandidatesInPayload(payload, { minCount = 1 } = {}) {
  const threshold = Math.max(1, Math.min(10, Number(minCount) || 1));
  return getEffectiveCompetitorCoverageFromPayload(payload, { max: 10 }) >= threshold;
}

function hasLowCoverageCompetitorsInPayload(payload, { preferredCount = 2 } = {}) {
  const target = Math.max(1, Math.min(10, Number(preferredCount) || 2));
  const count = getEffectiveCompetitorCoverageFromPayload(payload, { max: 10 });
  return count > 0 && count < target;
}

function hasLowCoverageCompetitorToken(payload) {
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return false;
  const missingInfo = getProductAnalysisInternalMissingCodes(p);
  return missingInfo.some((raw) => {
    const token = String(raw || '').trim().toLowerCase();
    return token === 'competitors_low_coverage'
      || token === 'alternatives_limited'
      || token === 'competitors_missing'
      || token === 'alternatives_unavailable'
      || token === 'competitor_sync_aurora_fallback_used';
  });
}

function shouldRepairCompetitorCoverage(payload, { preferredCount = 2 } = {}) {
  const target = Math.max(1, Math.min(10, Number(preferredCount) || 2));
  const count = getEffectiveCompetitorCoverageFromPayload(payload, { max: 10 });
  // Empty competitors should always try a bounded repair pass, even when old KB
  // snapshots no longer carry explicit low-coverage tokens.
  if (count === 0) return true;
  if (count >= target) return false;
  return hasLowCoverageCompetitorToken(payload);
}

function getProductAnalysisInternalMissingCodes(payload) {
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return [];
  return uniqCaseInsensitiveStrings(
    [
      ...(Array.isArray(p.internal_debug_codes) ? p.internal_debug_codes : []),
      ...(Array.isArray(p.missing_info_internal) ? p.missing_info_internal : []),
      ...(Array.isArray(p.missing_info) ? p.missing_info : []),
    ],
    32,
  );
}

function stripCompetitorMissingTokens(items) {
  const out = [];
  for (const raw of Array.isArray(items) ? items : []) {
    const token = String(raw || '').trim();
    if (!token) continue;
    if (token === 'competitors_missing') continue;
    if (token === 'competitors.competitors.candidates') continue;
    if (token === 'competitors_low_coverage') continue;
    if (token === 'alternatives_unavailable') continue;
    if (token === 'alternatives_limited') continue;
    if (token === 'competitor_candidates_filtered_noise') continue;
    if (token === 'competitor_sync_enrich_used') continue;
    if (token === 'competitor_sync_aurora_fallback_used') continue;
    if (/^competitor_recall_/i.test(token)) continue;
    out.push(token);
  }
  return Array.from(new Set(out));
}

function shouldServeProductIntelKbPayload(payload) {
  const p = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!p) return false;
  const assessment = p.assessment && typeof p.assessment === 'object' && !Array.isArray(p.assessment) ? p.assessment : null;
  if (!assessment) return false;

  const missingInfo = getProductAnalysisInternalMissingCodes(p);
  const hasCompetitors = hasCompetitorCandidatesInPayload(p);
  const competitorMissing = missingInfo.some((raw) => {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) return false;
    return token === 'competitors_missing'
      || token === 'competitors.competitors.candidates'
      || token === 'alternatives_unavailable'
      || token === 'competitor_sync_aurora_fallback_used'
      || token.startsWith('competitor_recall_');
  });
  if (competitorMissing && !hasCompetitors) {
    return shouldRepairCompetitorCoverage(p, { preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT });
  }
  return true;
}

function scheduleProductIntelCompetitorEnrichBackfill({
  productUrl,
  parsedProduct = null,
  payload = null,
  lang = 'EN',
  profileSummary = null,
  source = 'url_realtime_product_intel',
  sourceMeta = null,
  forceEnhance = false,
  logger,
} = {}) {
  if (!PRODUCT_INTEL_KB_ASYNC_BACKFILL_ENABLED || !PRODUCT_URL_REALTIME_COMPETITOR_ASYNC_ENRICH_ENABLED) return;
  const urlText = String(productUrl || '').trim();
  if (!/^https?:\/\//i.test(urlText)) return;
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) return;
  if (forceEnhance) {
    if (!shouldRepairCompetitorCoverage(payload, { preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT })) return;
  } else if (
    hasCompetitorCandidatesInPayload(payload) &&
    !hasLowCoverageCompetitorsInPayload(payload, { preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT })
  ) {
    return;
  }

  let payloadSnapshot = null;
  try {
    payloadSnapshot = JSON.parse(JSON.stringify(payload));
  } catch {
    payloadSnapshot = null;
  }
  if (!payloadSnapshot || typeof payloadSnapshot !== 'object' || Array.isArray(payloadSnapshot)) return;

  setImmediate(async () => {
    try {
      const assessment =
        payloadSnapshot.assessment && typeof payloadSnapshot.assessment === 'object' && !Array.isArray(payloadSnapshot.assessment)
          ? payloadSnapshot.assessment
          : null;
      const assessmentAnchor =
        assessment &&
        assessment.anchor_product &&
        typeof assessment.anchor_product === 'object' &&
        !Array.isArray(assessment.anchor_product)
          ? assessment.anchor_product
          : null;
      const anchorForReco =
        assessmentAnchor ||
        (parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null);
      const keyIngredients =
        payloadSnapshot.evidence &&
        payloadSnapshot.evidence.science &&
        Array.isArray(payloadSnapshot.evidence.science.key_ingredients)
          ? payloadSnapshot.evidence.science.key_ingredients
          : [];

      const dagOut = await runRecoBlocksForUrl({
        productUrl: urlText,
        anchorProduct: anchorForReco,
        parsedProduct: parsedProduct,
        keyIngredients,
        profileSummary,
        lang,
        mode: 'async_backfill',
        logger,
        existingPayload: payloadSnapshot,
        budgetMs: Math.max(AURORA_BFF_RECO_BLOCKS_BUDGET_MS, PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_TIMEOUT_MS),
        maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_CANDIDATES,
      });
      if (!dagOut || typeof dagOut !== 'object') return;
      let asyncCandidates = sanitizeCompetitorCandidates(
        dagOut?.competitors?.candidates,
        PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_CANDIDATES,
      );
      let asyncRelated = sanitizeCompetitorCandidates(
        dagOut?.related_products?.candidates,
        PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_CANDIDATES,
      );
      let asyncDupes = sanitizeCompetitorCandidates(
        dagOut?.dupes?.candidates,
        PRODUCT_URL_REALTIME_COMPETITOR_BACKFILL_MAX_CANDIDATES,
      );
      if (!asyncCandidates.length && !asyncRelated.length && !asyncDupes.length) return;
      const routeReasonCodes = summarizeRouterReasonCodes({
        internal_reason_codes: Array.isArray(dagOut.internal_reason_codes) ? dagOut.internal_reason_codes : [],
      });
      const dagDiagnostics = dagOut.diagnostics && typeof dagOut.diagnostics === 'object' ? dagOut.diagnostics : null;
      const dagFallbacksUsed = uniqCaseInsensitiveStrings(
        [
          ...(Array.isArray(dagDiagnostics?.fallbacks_used) ? dagDiagnostics.fallbacks_used : []),
        ],
        12,
      );
      const dagTimedOutBlocks = Array.isArray(dagDiagnostics?.timed_out_blocks) ? dagDiagnostics.timed_out_blocks : [];

      const existingEvidence =
        payloadSnapshot.evidence && typeof payloadSnapshot.evidence === 'object' && !Array.isArray(payloadSnapshot.evidence)
          ? payloadSnapshot.evidence
          : {};
      const existingExpertNotes = Array.isArray(existingEvidence.expert_notes) ? existingEvidence.expert_notes : [];
      const existingEvidenceMissing = stripCompetitorMissingTokens(existingEvidence.missing_info || []);
      const existingProvenance =
        payloadSnapshot.provenance && typeof payloadSnapshot.provenance === 'object' && !Array.isArray(payloadSnapshot.provenance)
          ? payloadSnapshot.provenance
          : {};
      const asyncNote =
        String(lang || '').toUpperCase() === 'CN'
          ? `reco DAG${asyncCandidates
            .slice(0, 3)
            .map((x) => x.name)
            .join('')}`
          : `Competitors backfilled async (reco DAG): ${asyncCandidates
            .slice(0, 3)
            .map((x) => x.name)
            .join(', ')}`;

      const mergedPayload = {
        ...payloadSnapshot,
        competitors: { candidates: asyncCandidates },
        ...(asyncRelated.length ? { related_products: { candidates: asyncRelated } } : {}),
        ...(asyncDupes.length ? { dupes: { candidates: asyncDupes } } : {}),
        evidence: {
          ...existingEvidence,
          expert_notes: uniqCaseInsensitiveStrings([...existingExpertNotes, asyncNote], 6),
          missing_info: existingEvidenceMissing,
        },
        ...(dagOut.confidence_patch && typeof dagOut.confidence_patch === 'object'
          ? { confidence_by_block: dagOut.confidence_patch }
          : {}),
        provenance: {
          ...existingProvenance,
          source: 'url_realtime_product_intel_async_backfill',
          ...(dagOut.provenance_patch && typeof dagOut.provenance_patch === 'object' ? dagOut.provenance_patch : {}),
        },
        internal_debug_codes: uniqCaseInsensitiveStrings(
          [
            ...stripCompetitorMissingTokens(getProductAnalysisInternalMissingCodes(payloadSnapshot)),
            ...(Array.isArray(asyncCandidates) && asyncCandidates.length < PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT
              ? ['competitors_low_coverage']
              : []),
            ...routeReasonCodes,
            ...dagFallbacksUsed.map((item) => `reco_dag_fallback_${String(item || '').trim().toLowerCase()}`),
            ...dagTimedOutBlocks.map((item) => `reco_dag_timeout_${String(item || '').trim().toLowerCase()}`),
            'competitor_async_backfill_used',
          ],
          32,
        ),
      };
      const enriched = enrichProductAnalysisPayload(mergedPayload, { lang, profileSummary });
      const kbKey = buildProductIntelKbKey({
        productUrl: urlText,
        parsedProduct: assessmentAnchor || anchorForReco,
        lang,
      });
      if (!kbKey) return;
      await upsertProductIntelKbEntry({
        kb_key: kbKey,
        analysis: enriched,
        source,
        source_meta: {
          ...(sourceMeta && typeof sourceMeta === 'object' && !Array.isArray(sourceMeta) ? sourceMeta : {}),
          competitor_async_enriched: true,
          competitor_async_source: 'reco_blocks_dag',
          competitor_queries: Array.isArray(dagOut.catalog_queries) ? dagOut.catalog_queries : [],
          competitor_router_reason_codes: routeReasonCodes,
          reco_blocks_dag: dagDiagnostics
            ? {
              mode: String(dagDiagnostics.mode || 'async_backfill'),
              budget_ms: Number(dagDiagnostics.budget_ms || AURORA_BFF_RECO_BLOCKS_BUDGET_MS),
              timed_out_blocks: dagTimedOutBlocks,
              fallbacks_used: dagFallbacksUsed,
              block_stats:
                dagOut.provenance_patch && typeof dagOut.provenance_patch === 'object'
                  ? dagOut.provenance_patch.block_stats || null
                  : null,
            }
            : null,
        },
        last_success_at: new Date().toISOString(),
        last_error: null,
      });
    } catch (err) {
      logger?.warn(
        { err: err?.message || String(err), url: urlText },
        'aurora bff: async competitor enrich backfill failed',
      );
    }
  });
}

async function maybeSyncRepairLowCoverageCompetitors({
  productUrl,
  payload,
  parsedProduct = null,
  profileSummary = null,
  lang = 'EN',
  logger,
} = {}) {
  const urlText = String(productUrl || '').trim();
  if (!/^https?:\/\//i.test(urlText)) return { payload, enhanced: false, reason: 'url_missing' };

  const payloadObj = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!payloadObj) return { payload, enhanced: false, reason: 'payload_missing' };

  const preferredCount = PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT;
  const existingCandidates = getCompetitorCandidatesFromPayload(payloadObj, {
    max: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  });
  const lowCoverageTokenPresent = hasLowCoverageCompetitorToken(payloadObj);
  if (!existingCandidates.length && !lowCoverageTokenPresent) {
    return { payload: payloadObj, enhanced: false, reason: 'competitors_missing' };
  }
  if (existingCandidates.length >= preferredCount) return { payload: payloadObj, enhanced: false, reason: 'coverage_ok' };
  if (!lowCoverageTokenPresent) return { payload: payloadObj, enhanced: false, reason: 'coverage_token_missing' };

  const assessment =
    payloadObj.assessment && typeof payloadObj.assessment === 'object' && !Array.isArray(payloadObj.assessment)
      ? payloadObj.assessment
      : null;
  const assessmentAnchor =
    assessment &&
    assessment.anchor_product &&
    typeof assessment.anchor_product === 'object' &&
    !Array.isArray(assessment.anchor_product)
      ? assessment.anchor_product
      : null;
  const anchorForRecall =
    assessmentAnchor ||
    (parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null);
  const keyIngredients =
    payloadObj.evidence &&
    payloadObj.evidence.science &&
    Array.isArray(payloadObj.evidence.science.key_ingredients)
      ? payloadObj.evidence.science.key_ingredients
      : [];

  let dagOut = null;
  try {
    dagOut = await runRecoBlocksForUrl({
      productUrl: urlText,
      anchorProduct: anchorForRecall,
      parsedProduct: parsedProduct,
      keyIngredients,
      profileSummary,
      lang,
      mode: 'sync_repair',
      logger,
      existingPayload: payloadObj,
      budgetMs: Math.max(
        AURORA_BFF_RECO_BLOCKS_BUDGET_MS,
        PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS + 900,
        2500,
      ),
      maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
    });
  } catch (err) {
    logger?.warn(
      { err: err?.message || String(err), url: urlText },
      'aurora bff: sync competitor repair dag failed',
    );
    return { payload: payloadObj, enhanced: false, reason: 'reco_blocks_failed' };
  }
  if (!dagOut || typeof dagOut !== 'object') {
    return { payload: payloadObj, enhanced: false, reason: 'dag_disabled' };
  }

  let mergedCandidates = sanitizeCompetitorCandidates(
    dagOut?.competitors?.candidates,
    PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  );
  let mergedRelatedCandidates = sanitizeCompetitorCandidates(
    dagOut?.related_products?.candidates,
    PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  );
  let mergedDupeCandidates = sanitizeCompetitorCandidates(
    dagOut?.dupes?.candidates,
    PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  );
  let syncDirectRecallUsed = false;
  if (!mergedCandidates.length) {
    try {
      const directRecallTimeoutMs = Math.max(2200, PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS + 900);
      const directRecall = await buildRealtimeCompetitorCandidates({
        productUrl: urlText,
        parsedProduct: anchorForRecall,
        keyIngredients: Array.isArray(keyIngredients) ? keyIngredients : [],
        anchorProduct: anchorForRecall,
        profileSummary,
        lang,
        mode: 'sync_repair',
        deadlineMs: Date.now() + directRecallTimeoutMs + 600,
        timeoutMs: directRecallTimeoutMs,
        maxQueries: Math.max(1, Math.min(4, PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_MAX_QUERIES + 1)),
        maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
        logger,
      });
      const directCandidates = sanitizeCompetitorCandidates(
        directRecall?.candidates,
        PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
      );
      if (directCandidates.length) {
        const rerouted = routeCompetitorCandidatePools({
          anchorProduct: anchorForRecall,
          candidates: directCandidates,
          maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
        });
        mergedCandidates = sanitizeCompetitorCandidates(
          rerouted.compPool,
          PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
        );
        mergedRelatedCandidates = sanitizeCompetitorCandidates(
          [...mergedRelatedCandidates, ...(Array.isArray(rerouted.relPool) ? rerouted.relPool : [])],
          PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
        );
        mergedDupeCandidates = sanitizeCompetitorCandidates(
          [...mergedDupeCandidates, ...(Array.isArray(rerouted.dupePool) ? rerouted.dupePool : [])],
          PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
        );
        syncDirectRecallUsed = mergedCandidates.length > 0;
      }
    } catch (err) {
      logger?.warn?.(
        { err: err?.message || String(err), url: urlText },
        'aurora bff: sync repair direct recall failed',
      );
    }
  }
  if (!mergedCandidates.length && !mergedRelatedCandidates.length && !mergedDupeCandidates.length) {
    return { payload: payloadObj, enhanced: false, reason: 'reco_dag_empty' };
  }

  const existingKey = existingCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });
  const mergedKey = mergedCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });
  const existingRelatedObj =
    payloadObj.related_products && typeof payloadObj.related_products === 'object' && !Array.isArray(payloadObj.related_products)
      ? payloadObj.related_products
      : null;
  const existingRelatedCandidates = sanitizeCompetitorCandidates(
    existingRelatedObj?.candidates,
    PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  );
  const existingRelatedKey = existingRelatedCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });
  const mergedRelatedKey = mergedRelatedCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });

  const existingDupeCandidates = sanitizeCompetitorCandidates(
    payloadObj?.dupes?.candidates,
    PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  );
  const existingDupeKey = existingDupeCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });
  const mergedDupeKey = mergedDupeCandidates.map((row) => {
    const id = pickFirstTrimmed(row?.product_id, row?.sku_id);
    const name = pickFirstTrimmed(row?.name, row?.display_name);
    return `${String(id || '').toLowerCase()}::${String(name || '').toLowerCase()}`;
  });

  const changed = mergedKey.join('|') !== existingKey.join('|');
  const relatedChanged = mergedRelatedKey.join('|') !== existingRelatedKey.join('|');
  const dupeChanged = mergedDupeKey.join('|') !== existingDupeKey.join('|');
  const coverageImproved = mergedCandidates.length >= preferredCount;
  if (!changed && !coverageImproved && !relatedChanged && !dupeChanged) {
    return { payload: payloadObj, enhanced: false, reason: 'no_delta' };
  }

  const dagDiagnostics = dagOut.diagnostics && typeof dagOut.diagnostics === 'object' ? dagOut.diagnostics : null;
  const dagFallbacksUsed = uniqCaseInsensitiveStrings(
    [
      ...(Array.isArray(dagDiagnostics?.fallbacks_used) ? dagDiagnostics.fallbacks_used : []),
      ...(syncDirectRecallUsed ? ['sync_direct_catalog_recall'] : []),
    ],
    12,
  );
  const dagTimedOutBlocks = Array.isArray(dagDiagnostics?.timed_out_blocks) ? dagDiagnostics.timed_out_blocks : [];
  const routeReasonCodes = summarizeRouterReasonCodes({
    internal_reason_codes: Array.isArray(dagOut.internal_reason_codes) ? dagOut.internal_reason_codes : [],
  });
  const existingMissingInfo = getProductAnalysisInternalMissingCodes(payloadObj);
  const mergedMissingInfo = uniqCaseInsensitiveStrings(
    [
      ...stripCompetitorMissingTokens(existingMissingInfo),
      ...(mergedCandidates.length < preferredCount ? ['competitors_low_coverage'] : []),
      ...routeReasonCodes,
      ...dagFallbacksUsed.map((item) => `reco_dag_fallback_${String(item || '').trim().toLowerCase()}`),
      ...dagTimedOutBlocks.map((item) => `reco_dag_timeout_${String(item || '').trim().toLowerCase()}`),
      ...(syncDirectRecallUsed ? ['competitor_sync_direct_recall_used'] : []),
      'competitor_sync_enrich_used',
    ],
    32,
  );

  const evidenceObj =
    payloadObj.evidence && typeof payloadObj.evidence === 'object' && !Array.isArray(payloadObj.evidence)
      ? payloadObj.evidence
      : {};
  const evidenceMissing = uniqCaseInsensitiveStrings(
    [
      ...stripCompetitorMissingTokens(evidenceObj.missing_info || []),
      ...(mergedCandidates.length < preferredCount ? ['competitors_low_coverage'] : []),
    ],
    16,
  );
  const existingExpertNotes = Array.isArray(evidenceObj.expert_notes) ? evidenceObj.expert_notes : [];
  const syncNote = (() => {
    const isCn = String(lang || '').toUpperCase() === 'CN';
    if (mergedCandidates.length) {
      return isCn
        ? `${mergedCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join('')}`
        : `Competitors refreshed on main path: ${mergedCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join(', ')}`;
    }
    if (mergedRelatedCandidates.length) {
      return isCn
        ? `related_products${mergedRelatedCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join('')}`
        : `Related products refreshed on main path: ${mergedRelatedCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join(', ')}`;
    }
    if (mergedDupeCandidates.length) {
      return isCn
        ? `dupe ${mergedDupeCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join('')}`
        : `Dupe candidates refreshed: ${mergedDupeCandidates
          .slice(0, 3)
          .map((x) => x.name)
          .join(', ')}`;
    }
    return '';
  })();

  const existingProvenance =
    payloadObj.provenance && typeof payloadObj.provenance === 'object' && !Array.isArray(payloadObj.provenance)
      ? payloadObj.provenance
      : {};
  const nextProvenancePatch =
    dagOut.provenance_patch && typeof dagOut.provenance_patch === 'object' && !Array.isArray(dagOut.provenance_patch)
      ? dagOut.provenance_patch
      : null;

  const mergedPayload = {
    ...payloadObj,
    competitors: { candidates: mergedCandidates },
    ...(mergedRelatedCandidates.length ? { related_products: { candidates: mergedRelatedCandidates } } : {}),
    ...(mergedDupeCandidates.length ? { dupes: { candidates: mergedDupeCandidates } } : {}),
    evidence: {
      ...evidenceObj,
      expert_notes: uniqCaseInsensitiveStrings([...existingExpertNotes, syncNote], 8),
      missing_info: evidenceMissing,
    },
    ...(dagOut.confidence_patch && typeof dagOut.confidence_patch === 'object'
      ? { confidence_by_block: dagOut.confidence_patch }
      : {}),
    provenance: {
      ...existingProvenance,
      source: 'url_realtime_product_intel_sync_repair',
      ...(nextProvenancePatch || {}),
    },
    internal_debug_codes: mergedMissingInfo,
  };
  return { payload: mergedPayload, enhanced: true, reason: null };
}

async function buildProductAnalysisFromUrlIngredients({
  productUrl,
  lang = 'EN',
  profileSummary = null,
  parsedProduct = null,
  logger,
} = {}) {
  const urlText = String(productUrl || '').trim();
  if (!/^https?:\/\//i.test(urlText)) return null;

  let parsedUrl = null;
  try {
    parsedUrl = new URL(urlText);
  } catch {
    return null;
  }

  let html = '';
  try {
    const resp = await axios.get(parsedUrl.toString(), {
      timeout: PRODUCT_URL_INGREDIENT_ANALYSIS_TIMEOUT_MS,
      maxContentLength: PRODUCT_URL_INGREDIENT_ANALYSIS_MAX_BYTES,
      maxBodyLength: PRODUCT_URL_INGREDIENT_ANALYSIS_MAX_BYTES,
      responseType: 'text',
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; AuroraBff/1.0; +https://aurora.pivota.cc)',
        Accept: 'text/html,application/xhtml+xml',
      },
      validateStatus: (status) => status >= 200 && status < 400,
    });
    html = typeof resp?.data === 'string' ? resp.data : '';
  } catch (err) {
    logger?.warn(
      { url: parsedUrl.toString(), err: err?.message || String(err) },
      'aurora bff: product URL ingredient extraction failed',
    );
    return null;
  }

  const inciList = extractInciListFromHtml(html);
  if (!inciList.length) return null;

  const keyHints = extractKeyIngredientsFromHtml(html);
  const normalizedInci = uniqCaseInsensitiveStrings(inciList.map((item) => normalizeInciIngredientName(item)).filter(Boolean), 120);
  const keyIngredients = deriveKeyIngredientsForAnalysis(normalizedInci, keyHints.map((item) => normalizeInciIngredientName(item)));
  const mechanisms = deriveIngredientMechanisms(keyIngredients, lang);
  const riskNotes = deriveIngredientRiskNotes(normalizedInci, profileSummary || {}, lang);
  const socialSignals = extractRealtimeSocialSignalsFromHtml(html, { lang, riskNotes });

  const isCn = String(lang || '').toUpperCase() === 'CN';
  const skinType = String(profileSummary?.skinType || '').trim().toLowerCase();
  const sensitivity = String(profileSummary?.sensitivity || '').trim().toLowerCase();
  const barrier = String(profileSummary?.barrierStatus || '').trim().toLowerCase();
  const highSensitivity = sensitivity === 'high' || barrier === 'impaired';
  const mediumSensitivity = sensitivity === 'medium';
  const lowerInci = normalizedInci.join(' | ').toLowerCase();
  const hasAcidLike = /\b(aha|bha|pha|glycolic|lactic|mandelic|salicylic|retinol|retinal|adapalene|tretinoin)\b/.test(lowerInci);
  const hasFragranceLike = /\b(fragrance|parfum|linalool|limonene|citral|geraniol)\b/.test(lowerInci);

  const verdict =
    highSensitivity && (hasAcidLike || hasFragranceLike)
      ? isCn
        ? ''
        : 'Caution'
      : mediumSensitivity && hasAcidLike
        ? isCn
          ? ''
          : 'Caution'
        : isCn
          ? ''
          : 'Likely Suitable';

  const profileNote = (() => {
    if (!skinType && !sensitivity && !barrier) return '';
    if (isCn) {
      return `${[skinType || '', ` ${sensitivity || ''}`, ` ${barrier || ''}`].join(' / ')}`;
    }
    return `Your profile: ${[skinType || 'unknown skinType', `sensitivity=${sensitivity || 'unknown'}`, `barrier=${barrier || 'unknown'}`].join(' / ')}`;
  })();

  const hostName = String(parsedUrl.hostname || '').replace(/^www\./i, '');
  const pageTitle = extractPageTitleFromHtml(html);
  const extractedPrice = extractProductPriceFromHtml(html);

  const parsedProductObj = parsedProduct && typeof parsedProduct === 'object' && !Array.isArray(parsedProduct) ? parsedProduct : null;
  const anchorBrand = pickFirstTrimmed(
    parsedProductObj?.brand,
    pageTitle.includes('|') ? pageTitle.split('|').slice(-1)[0] : '',
  );
  const anchorName = pickFirstTrimmed(
    parsedProductObj?.name,
    pageTitle.includes('|') ? pageTitle.split('|')[0] : pageTitle,
    parsedProductObj?.display_name,
  );
  const anchorDisplayName = pickFirstTrimmed(
    parsedProductObj?.display_name,
    joinBrandAndName(anchorBrand, anchorName),
    anchorName,
  );
  const concentrationSignals = extractConcentrationSignals({
    pageTitle,
    anchorName,
    anchorDisplayName,
    keyIngredients,
  });
  const reasons = uniqCaseInsensitiveStrings(
    [
      isCn
        ? ` INCI  ${normalizedInci.length} `
        : `I extracted the INCI list directly from the product page (${normalizedInci.length} entries) for this assessment.`,
      keyIngredients.length
        ? isCn
          ? `${keyIngredients.slice(0, 5).join('')}`
          : `Detected key ingredients: ${keyIngredients.slice(0, 5).join(', ')}.`
        : '',
      riskNotes.length ? riskNotes[0] : '',
      socialSignals.typical_positive.length
        ? isCn
          ? `${socialSignals.typical_positive.slice(0, 2).join('')}`
          : `On-page sentiment leans positive: ${socialSignals.typical_positive.slice(0, 2).join(', ')}.`
        : '',
      concentrationSignals.length
        ? isCn
          ? `${concentrationSignals.slice(0, 2).join('')}`
          : `Detected concentration signal on page: ${concentrationSignals.slice(0, 2).join(', ')} (reference only).`
        : isCn
          ? ''
          : 'Boundary: concentration and batch variance are unknown; patch test first and start at low frequency.',
    ],
    5,
  );
  const parsedPrice = normalizePriceObject(
    parsedProductObj?.price ??
      parsedProductObj?.price_amount ??
      parsedProductObj?.priceAmount ??
      parsedProductObj?.offer_price ??
      parsedProductObj?.price_usd ??
      parsedProductObj?.priceUsd ??
      parsedProductObj?.price_cny ??
      parsedProductObj?.priceCny,
  );
  const anchorPrice = (() => {
    const nowIso = new Date().toISOString();
    if (parsedPrice) {
      return {
        ...parsedPrice,
        source: 'parsed_anchor_price',
        captured_at: nowIso,
      };
    }
    const extractedNormalized = normalizePriceObject(extractedPrice);
    if (!extractedNormalized) return null;
    const sourceToken = pickFirstTrimmed(extractedPrice?.source, 'page_price_signal');
    return {
      ...extractedNormalized,
      ...(sourceToken ? { source: sourceToken } : {}),
      captured_at: nowIso,
    };
  })();
  const anchorProduct = {
    ...(parsedProductObj?.product_id ? { product_id: String(parsedProductObj.product_id).trim() } : {}),
    ...(parsedProductObj?.sku_id ? { sku_id: String(parsedProductObj.sku_id).trim() } : {}),
    ...(anchorBrand ? { brand: anchorBrand } : {}),
    ...(anchorName ? { name: anchorName } : {}),
    ...(anchorDisplayName ? { display_name: anchorDisplayName } : {}),
    ...(anchorPrice ? { price: anchorPrice } : {}),
    url: parsedUrl.toString(),
  };

  let competitorOut = { candidates: [], queries: [], reason: 'dag_not_used' };
  let competitorSource = 'catalog';
  let competitorReason = null;
  let routedPools = { compPool: [], relPool: [], dupePool: [], routed: { internal_reason_codes: [] } };
  let dagDiagnostics = null;
  let dagReasonCodes = [];
  let dagConfidencePatch = null;
  let dagProvenancePatch = null;
  let dagTracking = null;

  const dagOut = await runRecoBlocksForUrl({
    productUrl: parsedUrl.toString(),
    anchorProduct,
    parsedProduct: parsedProductObj,
    keyIngredients,
    profileSummary,
    lang,
    mode: 'main_path',
    logger,
    html,
    budgetMs: AURORA_BFF_RECO_BLOCKS_BUDGET_MS,
    maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
  });

  if (dagOut && typeof dagOut === 'object') {
    const compPool = sanitizeCompetitorCandidates(dagOut?.competitors?.candidates, PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES);
    const relPool = sanitizeCompetitorCandidates(dagOut?.related_products?.candidates, PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES);
    const dupePool = sanitizeCompetitorCandidates(dagOut?.dupes?.candidates, PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES);
    routedPools = {
      compPool,
      relPool,
      dupePool,
      routed: {
        internal_reason_codes: Array.isArray(dagOut.internal_reason_codes) ? dagOut.internal_reason_codes : [],
      },
    };
    competitorOut = {
      candidates: compPool,
      queries: Array.isArray(dagOut.catalog_queries) ? dagOut.catalog_queries : [],
      reason: null,
    };
    dagDiagnostics = dagOut.diagnostics || null;
    dagConfidencePatch =
      dagOut.confidence_patch && typeof dagOut.confidence_patch === 'object' && !Array.isArray(dagOut.confidence_patch)
        ? dagOut.confidence_patch
        : null;
    dagProvenancePatch =
      dagOut.provenance_patch && typeof dagOut.provenance_patch === 'object' && !Array.isArray(dagOut.provenance_patch)
        ? dagOut.provenance_patch
        : null;
    dagTracking =
      dagOut.tracking && typeof dagOut.tracking === 'object' && !Array.isArray(dagOut.tracking)
        ? dagOut.tracking
        : null;
    competitorSource = 'reco_blocks_dag';
    dagReasonCodes = summarizeRouterReasonCodes(routedPools.routed);
    if (!compPool.length) {
      const fallbackUsed = Array.isArray(dagDiagnostics?.fallbacks_used) ? dagDiagnostics.fallbacks_used : [];
      const timedOut = Array.isArray(dagDiagnostics?.timed_out_blocks) ? dagDiagnostics.timed_out_blocks : [];
      if (fallbackUsed.includes('related_on_page_fallback') && relPool.length) {
        competitorSource = 'on_page_related_only';
      }
      competitorReason =
        timedOut.length || fallbackUsed.length
          ? 'dag_timeout_or_empty'
          : 'dag_empty';
    }
  } else {
    competitorOut = await buildRealtimeCompetitorCandidates({
      productUrl: parsedUrl.toString(),
      parsedProduct: parsedProductObj,
      keyIngredients,
      anchorProduct,
      profileSummary,
      lang,
      logger,
    });
    const recalledCandidates = sanitizeCompetitorCandidates(
      competitorOut?.candidates,
      PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
    );
    let onPageCandidates = [];
    competitorSource = 'catalog';
    competitorReason = competitorOut?.reason ? String(competitorOut.reason) : null;
    if (!recalledCandidates.length) {
      onPageCandidates = buildOnPageCompetitorCandidates({
        html,
        productUrl: parsedUrl.toString(),
        anchorProduct,
        profileSummary,
        lang,
        maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
      });
    }
    routedPools = routeCompetitorCandidatePools({
      anchorProduct,
      candidates: [...recalledCandidates, ...onPageCandidates],
      maxCandidates: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
    });
    if (!routedPools.compPool.length) {
      if (onPageCandidates.length || routedPools.relPool.length) {
        competitorSource = 'on_page_related_only';
        competitorReason = competitorReason || 'hard_gate_filtered';
      } else if (recalledCandidates.length) {
        competitorReason = competitorReason || 'hard_gate_filtered';
      }
    }
  }
  const competitorCandidates = routedPools.compPool;
  const relatedCandidates = routedPools.relPool;
  const dupeCandidates = routedPools.dupePool;
  const competitorMissing = !competitorCandidates.length;
  const socialMissing = !socialSignals.has_signal;

  const confidence = Number(
    Math.max(
      0.35,
      Math.min(
        0.84,
        0.42 +
          (normalizedInci.length >= 15 ? 0.12 : 0.04) +
          (keyIngredients.length >= 4 ? 0.1 : 0.04) +
          (riskNotes.length ? 0.04 : 0) +
          (socialMissing ? 0 : 0.05) +
          (competitorMissing ? 0 : 0.05),
      ),
    ).toFixed(3),
  );

  const evidenceMissingInfo = [];
  if (!concentrationSignals.length) evidenceMissingInfo.push('concentration_unknown');
  if (!anchorPrice) evidenceMissingInfo.push('price_unknown');
  if (socialMissing) evidenceMissingInfo.push('social_signals_missing');
  if (competitorMissing) evidenceMissingInfo.push('competitors_missing');
  if (!competitorMissing && competitorCandidates.length < PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT) {
    evidenceMissingInfo.push('competitors_low_coverage');
  }
  if (competitorMissing && competitorReason) evidenceMissingInfo.push(`competitor_recall_${String(competitorReason).toLowerCase()}`);
  const dagFallbacksUsed = Array.isArray(dagDiagnostics?.fallbacks_used) ? dagDiagnostics.fallbacks_used : [];
  const dagTimedOutBlocks = Array.isArray(dagDiagnostics?.timed_out_blocks) ? dagDiagnostics.timed_out_blocks : [];
  const routeReasonCodes = dagReasonCodes.length ? dagReasonCodes : summarizeRouterReasonCodes(routedPools.routed);

  const defaultConfidenceByBlock = {
    competitors: {
      score: competitorMissing ? 0.18 : 0.62,
      level: competitorMissing ? 'low' : 'med',
      reasons: competitorMissing ? ['competitors_missing'] : ['competitors_available'],
    },
    related_products: {
      score: relatedCandidates.length ? 0.62 : 0.42,
      level: relatedCandidates.length ? 'med' : 'low',
      reasons: relatedCandidates.length ? ['related_products_available'] : ['related_products_sparse'],
    },
    dupes: {
      score: dupeCandidates.length ? 0.58 : 0.38,
      level: dupeCandidates.length ? 'med' : 'low',
      reasons: dupeCandidates.length ? ['dupes_available'] : ['dupes_sparse'],
    },
  };

  const raw = {
    assessment: {
      verdict,
      reasons,
      anchor_product: anchorProduct,
    },
    evidence: {
      science: {
        key_ingredients: keyIngredients,
        mechanisms,
        fit_notes: profileNote ? [profileNote] : [],
        risk_notes: riskNotes,
      },
      social_signals: {
        ...(Object.keys(socialSignals.platform_scores || {}).length
          ? { platform_scores: socialSignals.platform_scores }
          : {}),
        typical_positive: socialSignals.typical_positive,
        typical_negative: socialSignals.typical_negative,
        risk_for_groups: socialSignals.risk_for_groups,
      },
      expert_notes: uniqCaseInsensitiveStrings(
        [
          isCn
            ? `${hostName || 'product page'} `
            : `Evidence source: ingredient list parsed from ${hostName || 'product page'}.`,
          anchorPrice
            ? isCn
              ? `${anchorPrice.currency || 'USD'} ${anchorPrice.amount}`
              : `Price signal from page: ${anchorPrice.currency || 'USD'} ${anchorPrice.amount} (used for comparable matching).`
            : '',
          ...socialSignals.notes,
          competitorOut?.queries?.length
            ? isCn
              ? `${competitorOut.queries.join(' | ')}`
              : `Competitor recall queries: ${competitorOut.queries.join(' | ')}`
            : '',
          dagFallbacksUsed.length
            ? isCn
              ? `DAG ${dagFallbacksUsed.join(', ')}`
              : `DAG fallback trace: ${dagFallbacksUsed.join(', ')}.`
            : '',
          dagTimedOutBlocks.length
            ? isCn
              ? `DAG ${dagTimedOutBlocks.join(', ')}`
              : `DAG timed-out branches: ${dagTimedOutBlocks.join(', ')}.`
            : '',
          competitorSource === 'on_page_related_only'
            ? isCn
              ? ' related products  related_products competitors'
              : 'On-page related products were routed to related_products and blocked from competitors by hard gates.'
            : '',
        ],
        6,
      ),
      confidence,
      missing_info: evidenceMissingInfo,
    },
    confidence,
    confidence_by_block: dagConfidencePatch || defaultConfidenceByBlock,
    provenance: {
      source: 'url_realtime_product_intel',
      pipeline: dagProvenancePatch?.pipeline || 'url_realtime_product_intel_v1',
      validation_mode: dagProvenancePatch?.validation_mode || 'soft_fail',
      ...(dagProvenancePatch && typeof dagProvenancePatch === 'object' ? dagProvenancePatch : {}),
    },
    missing_info: uniqCaseInsensitiveStrings(
      [
        'url_ingredient_analysis_used',
        'url_realtime_product_intel_used',
        ...(!anchorPrice ? ['price_unknown'] : []),
        ...(socialMissing ? ['social_signals_missing'] : []),
        ...(competitorMissing ? ['competitors_missing'] : []),
        ...(!competitorMissing && competitorCandidates.length < PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT ? ['competitors_low_coverage'] : []),
        competitorMissing && competitorReason ? `competitor_recall_${String(competitorReason).toLowerCase()}` : '',
      ],
      12,
    ),
    ...(competitorCandidates.length ? { competitors: { candidates: competitorCandidates } } : {}),
    ...(relatedCandidates.length ? { related_products: { candidates: relatedCandidates } } : {}),
    ...(dupeCandidates.length ? { dupes: { candidates: dupeCandidates } } : {}),
    ...(dagTracking ? { candidate_tracking: dagTracking } : {}),
  };

  const norm = normalizeProductAnalysis(raw);
  const payloadInternalCodes = Array.isArray(norm.payload?.internal_debug_codes) ? norm.payload.internal_debug_codes : [];
  const mergedInternalCodes = Array.from(
    new Set([
      ...payloadInternalCodes,
      'url_ingredient_analysis_used',
      'url_realtime_product_intel_used',
      ...(socialMissing ? ['social_signals_missing'] : []),
      ...(competitorMissing ? ['competitors_missing'] : []),
      ...(!competitorMissing && competitorCandidates.length < PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT ? ['competitors_low_coverage'] : []),
      ...(competitorMissing && competitorReason ? [`competitor_recall_${String(competitorReason).toLowerCase()}`] : []),
      ...routeReasonCodes,
      ...dagFallbacksUsed.map((item) => `reco_dag_fallback_${String(item || '').trim().toLowerCase()}`),
      ...dagTimedOutBlocks.map((item) => `reco_dag_timeout_${String(item || '').trim().toLowerCase()}`),
    ]),
  );
  const nextPayload = applyProductAnalysisGapContract({
    ...(norm.payload && typeof norm.payload === 'object' ? norm.payload : {}),
    ...(raw.confidence_by_block ? { confidence_by_block: raw.confidence_by_block } : {}),
    ...(raw.provenance ? { provenance: raw.provenance } : {}),
    internal_debug_codes: mergedInternalCodes,
  });
  const nextFieldMissing = Array.isArray(norm.field_missing) ? norm.field_missing.filter((item) => {
    const field = String(item?.field || '').trim();
    return field !== 'assessment' && field !== 'evidence';
  }) : [];
  return {
    payload: nextPayload,
    field_missing: nextFieldMissing,
    source_meta: {
      analyzer: 'url_realtime_product_intel_v1',
      source_url: parsedUrl.toString(),
      source_host: hostName || null,
      competitor_queries: competitorOut?.queries || [],
      competitor_reason: competitorReason || null,
      competitor_source: competitorSource,
      social_signal_present: !socialMissing,
      competitor_count: competitorCandidates.length,
      related_count: relatedCandidates.length,
      dupe_count: dupeCandidates.length,
      competitor_router_reason_codes: routeReasonCodes,
      reco_blocks_dag: dagDiagnostics
        ? {
          mode: String(dagDiagnostics.mode || 'main_path'),
          budget_ms: Number(dagDiagnostics.budget_ms || AURORA_BFF_RECO_BLOCKS_BUDGET_MS),
          timed_out_blocks: dagTimedOutBlocks,
          fallbacks_used: dagFallbacksUsed,
          block_stats: dagProvenancePatch?.block_stats || null,
        }
        : null,
    },
  };
}

function applyCommerceMedicalClaimGuard(text, lang) {
  const input = String(text || '');
  if (!input.trim()) return input;
  const lowered = input.toLowerCase();
  const hit =
    /(|||||||)/.test(input) ||
    /\b(cure|treat|heals?|prescription|steroid|dermatitis|eczema)\b/i.test(lowered);
  if (!hit) return input;

  recordClaimsViolation({ reason: 'commerce_medical_blacklist' });
  return lang === 'CN'
    ? '///'
    : "I can help with product info/ingredients/where to buy, but I can't provide medical diagnosis or treatment advice. If you suspect dermatitis/eczema, please see a clinician. Which brand or product are you looking for?";
}

function buildRecoCatalogQueries({ profileSummary, lang } = {}) {
  const raw = RECO_CATALOG_GROUNDED_QUERIES;
  const fromEnv = raw
    ? raw
      .split(',')
      .map((s) => s.trim())
      .filter(Boolean)
      .slice(0, 8)
    : null;

  const base = fromEnv && fromEnv.length > 0 ? fromEnv : ['cleanser', 'moisturizer', 'sunscreen'];

  const goalPrimaryRaw = profileSummary && typeof profileSummary.goal_primary === 'string' ? profileSummary.goal_primary.trim().toLowerCase() : '';
  const goals = Array.isArray(profileSummary?.goals) ? profileSummary.goals : [];
  const goalsText = [goalPrimaryRaw, ...goals.map((g) => String(g || '').trim().toLowerCase())].filter(Boolean).join(' ');
  const hasAcne = /\b(acne|breakout|breakouts)\b/.test(goalsText) || //.test(goalsText);

  const isCn = String(lang || '').toUpperCase() === 'CN';
  const stepLabels = {
    cleanser: isCn ? '' : 'Cleanser',
    moisturizer: isCn ? '' : 'Moisturizer',
    sunscreen: isCn ? '' : 'Sunscreen',
    treatment: isCn ? '' : 'Treatment',
  };

  const items = base.map((q, idx) => {
    const key = String(q || '').trim().toLowerCase();
    const step = stepLabels[key] || (isCn ? ` ${idx + 1}` : `Recommendation ${idx + 1}`);
    const slot = idx === 0 ? 'am' : idx === 1 ? 'pm' : 'other';
    const query = hasAcne && key === 'cleanser' ? 'acne cleanser' : q;
    return { query: String(query || '').trim(), step, slot };
  });

  return items.slice(0, 8);
}

function shouldUseRecoCatalogTransientFallback(catalogDebug) {
  if (!RECO_CATALOG_TRANSIENT_FALLBACK_ENABLED) return false;
  if (!catalogDebug || typeof catalogDebug !== 'object' || Array.isArray(catalogDebug)) return false;
  const queryCount = Number.isFinite(Number(catalogDebug.query_count)) ? Math.trunc(Number(catalogDebug.query_count)) : 0;
  const okCount = Number.isFinite(Number(catalogDebug.ok_count)) ? Math.trunc(Number(catalogDebug.ok_count)) : 0;
  if (queryCount <= 0 || okCount > 0) return false;

  const timeoutCount = Number.isFinite(Number(catalogDebug.timeout_count)) ? Math.trunc(Number(catalogDebug.timeout_count)) : 0;
  const statusCounts =
    catalogDebug.status_counts && typeof catalogDebug.status_counts === 'object' && !Array.isArray(catalogDebug.status_counts)
      ? catalogDebug.status_counts
      : null;
  const timeoutByStatus = Number.isFinite(Number(statusCounts && statusCounts.upstream_timeout))
    ? Math.trunc(Number(statusCounts.upstream_timeout))
    : 0;
  const upstreamErrorByStatus = Number.isFinite(Number(statusCounts && statusCounts.upstream_error))
    ? Math.trunc(Number(statusCounts.upstream_error))
    : 0;
  const rateLimitedByStatus = Number.isFinite(Number(statusCounts && statusCounts.rate_limited))
    ? Math.trunc(Number(statusCounts.rate_limited))
    : 0;
  const transientByStatus = timeoutByStatus + upstreamErrorByStatus + rateLimitedByStatus;
  const skippedReason = String(catalogDebug.skipped_reason || '').trim().toLowerCase();
  const failFastAfter =
    catalogDebug.fail_fast_after && typeof catalogDebug.fail_fast_after === 'object' && !Array.isArray(catalogDebug.fail_fast_after)
      ? catalogDebug.fail_fast_after
      : null;
  const failFastAfterOpen = Boolean(failFastAfter && failFastAfter.open === true);
  const failFastAfterReason = String(failFastAfter && failFastAfter.last_reason ? failFastAfter.last_reason : '')
    .trim()
    .toLowerCase();
  const failFastAfterTransient =
    failFastAfterReason === 'all_queries_failed' || failFastAfterReason === 'probe_transient_errors';

  if (skippedReason === 'fail_fast_open') return true;
  if (timeoutCount >= Math.max(1, queryCount)) return true;
  if (transientByStatus >= Math.max(1, queryCount)) return true;
  if (failFastAfterOpen && failFastAfterTransient) return true;
  return false;
}

function buildRecoCatalogTransientFallbackStructured({ ctx } = {}) {
  const isCn = String(ctx && ctx.lang ? ctx.lang : '').toUpperCase() === 'CN';
  const stableSeeds = [
    {
      query: 'Winona Soothing Repair Serum',
      brand: isCn ? '' : 'Winona',
      name: isCn ? '' : 'Soothing Repair Serum',
      display_name: isCn ? ' ' : 'Winona Soothing Repair Serum',
      step: isCn ? '' : 'Barrier Serum',
      slot: 'pm',
      reasons: isCn
        ? ['']
        : ['Prioritizes barrier repair and soothing support for PM recovery.'],
    },
    {
      query: 'The Ordinary Niacinamide 10% + Zinc 1%',
      brand: 'The Ordinary',
      name: 'Niacinamide 10% + Zinc 1%',
      display_name: 'The Ordinary Niacinamide 10% + Zinc 1%',
      step: isCn ? '' : 'Balancing Serum',
      slot: 'am',
      reasons: isCn
        ? ['']
        : ['Targets uneven tone and pores with a light daytime active step.'],
    },
    {
      query: 'IPSA Time Reset Aqua',
      brand: 'IPSA',
      name: 'Time Reset Aqua',
      display_name: 'IPSA Time Reset Aqua',
      step: isCn ? '' : 'Hydration Base',
      slot: 'am',
      reasons: isCn
        ? ['']
        : ['Provides hydration baseline and tolerance support for layering.'],
    },
  ];

  const recos = [];
  const seenProductIds = new Set();
  for (const seed of stableSeeds) {
    if (recos.length >= RECO_CATALOG_TRANSIENT_FALLBACK_MAX_ITEMS) break;
    const match = resolveRecoStableAliasRefByQuery(seed.query);
    if (!match || !match.canonicalProductRef) continue;
    const productId = String(match.canonicalProductRef.product_id || '').trim();
    const merchantId = String(match.canonicalProductRef.merchant_id || '').trim();
    if (!productId || !merchantId || seenProductIds.has(productId)) continue;
    seenProductIds.add(productId);
    recos.push({
      slot: seed.slot,
      step: seed.step,
      score: 90 - recos.length * 2,
      sku: {
        product_id: productId,
        merchant_id: merchantId,
        brand: seed.brand,
        name: seed.name,
        display_name: seed.display_name,
        canonical_product_ref: {
          product_id: productId,
          merchant_id: merchantId,
        },
      },
      reasons: seed.reasons,
      warnings: [
        isCn
          ? ''
          : 'Catalog upstream is unstable; showing stable fallback picks for faster response.',
      ],
    });
  }

  if (!recos.length) return null;
  return {
    recommendations: recos,
    evidence: null,
    confidence: 0.62,
    missing_info: [],
    warnings: [
      isCn
        ? ''
        : 'Catalog service is unstable right now; returning stable fallback picks first.',
    ],
  };
}

async function buildRecoGenerateFromCatalog({ ctx, profileSummary, debug, logger } = {}) {
  const startedAt = Date.now();
  const failFastBefore = getRecoCatalogFailFastSnapshot(startedAt);
  let probeWhileOpen = false;
  let searchTimeoutEffectiveMs = RECO_CATALOG_SEARCH_TIMEOUT_MS;
  const debugInfo = {
    enabled: RECO_CATALOG_GROUNDED_ENABLED,
    search_timeout_ms: RECO_CATALOG_SEARCH_TIMEOUT_MS,
    search_concurrency: RECO_CATALOG_SEARCH_CONCURRENCY,
    fail_fast: failFastBefore,
  };

  if (!RECO_CATALOG_GROUNDED_ENABLED) {
    return { structured: null, debug: { ...debugInfo, skipped_reason: 'disabled', total_ms: Date.now() - startedAt } };
  }
  const catalogSearchBaseUrls = buildRecoCatalogSearchBaseUrlCandidates({
    includeLocalFallback:
      RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
      RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED,
  });
  debugInfo.catalog_search_sources = catalogSearchBaseUrls.slice(0, 6);
  debugInfo.catalog_search_source_health = getRecoCatalogSearchSourceHealthSnapshot(Date.now());
  if (!catalogSearchBaseUrls.length) {
    return {
      structured: null,
      debug: { ...debugInfo, skipped_reason: 'pivota_backend_not_configured', total_ms: Date.now() - startedAt },
    };
  }
  if (failFastBefore.open) {
    probeWhileOpen = beginRecoCatalogFailFastProbe(startedAt);
    if (!probeWhileOpen) {
      return { structured: null, debug: { ...debugInfo, skipped_reason: 'fail_fast_open', total_ms: Date.now() - startedAt } };
    }
    searchTimeoutEffectiveMs = Math.min(RECO_CATALOG_SEARCH_TIMEOUT_MS, RECO_CATALOG_FAIL_FAST_PROBE_SEARCH_TIMEOUT_MS);
  }

  const queries = buildRecoCatalogQueries({ profileSummary, lang: ctx && ctx.lang ? ctx.lang : 'EN' });
  if (!queries.length) {
    return { structured: null, debug: { ...debugInfo, skipped_reason: 'queries_empty', total_ms: Date.now() - startedAt } };
  }

  const results = await mapWithConcurrency(queries, RECO_CATALOG_SEARCH_CONCURRENCY, async (q) => {
    const out = await searchPivotaBackendProducts({
      query: q.query,
      limit: 6,
      logger,
      timeoutMs: searchTimeoutEffectiveMs,
    });
    return { ...q, ...out };
  });

  const usedProductIds = new Set();
  const recos = [];
  for (const r of results) {
    const products = Array.isArray(r?.products) ? r.products : [];
    const picked = products.find((p) => p && p.product_id && !usedProductIds.has(p.product_id));
    if (!picked) continue;
    usedProductIds.add(picked.product_id);
    recos.push({
      slot: r.slot || 'other',
      step: r.step || (ctx && ctx.lang === 'CN' ? '' : 'Recommendation'),
      score: 95,
      sku: picked,
      ...(debug
        ? {
          notes:
            ctx && ctx.lang === 'CN'
              ? [' Pivota PDP ']
              : ['From Pivota catalog (PDP test mode)'],
        }
        : {}),
    });
  }

  const statusCounts = {};
  let okCount = 0;
  let emptyCount = 0;
  let timeoutCount = 0;
  for (const r of results) {
    const reason = String(r?.reason || (r?.ok ? 'ok' : 'unknown')).trim() || 'unknown';
    statusCounts[reason] = (statusCounts[reason] || 0) + 1;
    if (r?.ok) okCount += 1;
    if (r?.ok && (!Array.isArray(r?.products) || r.products.length === 0)) emptyCount += 1;
    if (reason === 'upstream_timeout') timeoutCount += 1;
  }

  const transientReasons = new Set(['upstream_timeout', 'upstream_error', 'rate_limited']);
  const hasOnlyTransientErrors = results.length > 0 && results.every((r) => !r?.ok && transientReasons.has(String(r?.reason || '')));
  const hasTransientErrors = results.some((r) => !r?.ok && transientReasons.has(String(r?.reason || '')));
  const healthyProbeResult = okCount > 0 && !hasTransientErrors;
  if (probeWhileOpen) {
    if (!healthyProbeResult && (hasOnlyTransientErrors || hasTransientErrors)) {
      markRecoCatalogFailFastFailure('probe_transient_errors', Date.now());
    }
  } else if (okCount > 0) {
    markRecoCatalogFailFastSuccess();
  } else if (hasOnlyTransientErrors) {
    markRecoCatalogFailFastFailure('all_queries_failed', Date.now());
  }

  const debugPayload = {
    ...debugInfo,
    query_count: queries.length,
    ok_count: okCount,
    picked_count: recos.length,
    probe_while_open: probeWhileOpen,
    search_timeout_effective_ms: searchTimeoutEffectiveMs,
    total_ms: Date.now() - startedAt,
    fail_fast_after: getRecoCatalogFailFastSnapshot(Date.now()),
    timeout_count: timeoutCount,
    status_counts: statusCounts,
    ...(debug
      ? {
        empty_count: emptyCount,
      }
      : {}),
  };

  if (!recos.length) return { structured: null, debug: debugPayload };

  return {
    structured: {
      recommendations: recos,
      evidence: null,
      confidence: 0.9,
      missing_info: [],
      warnings: [],
    },
    debug: debugPayload,
  };
}

function deriveRecoPdpFastFallbackReasonCode(catalogDebug) {
  const debugObj = catalogDebug && typeof catalogDebug === 'object' ? catalogDebug : null;
  if (!debugObj) return null;
  if (String(debugObj.skipped_reason || '').trim() === 'fail_fast_open') return 'upstream_timeout';
  const okCount = Number.isFinite(Number(debugObj.ok_count)) ? Math.trunc(Number(debugObj.ok_count)) : 0;
  const timeoutCount = Number.isFinite(Number(debugObj.timeout_count)) ? Math.trunc(Number(debugObj.timeout_count)) : 0;
  const queryCount = Number.isFinite(Number(debugObj.query_count)) ? Math.trunc(Number(debugObj.query_count)) : 0;
  const statusCounts =
    debugObj.status_counts && typeof debugObj.status_counts === 'object' && !Array.isArray(debugObj.status_counts)
      ? debugObj.status_counts
      : null;
  const timeoutByStatus = Number.isFinite(Number(statusCounts && statusCounts.upstream_timeout))
    ? Math.trunc(Number(statusCounts ? statusCounts.upstream_timeout : 0))
    : 0;
  const failFastAfter =
    debugObj.fail_fast_after && typeof debugObj.fail_fast_after === 'object' && !Array.isArray(debugObj.fail_fast_after)
      ? debugObj.fail_fast_after
      : null;
  const failFastAfterOpen = Boolean(failFastAfter && failFastAfter.open === true);
  const failFastAfterReason = String(failFastAfter && failFastAfter.last_reason ? failFastAfter.last_reason : '')
    .trim()
    .toLowerCase();
  const failFastAfterTransient =
    failFastAfterReason === 'all_queries_failed' || failFastAfterReason === 'probe_transient_errors';
  if (okCount > 0) return null;
  if (timeoutCount > 0 && timeoutCount >= Math.max(1, queryCount)) return 'upstream_timeout';
  if (timeoutByStatus > 0 && timeoutByStatus >= Math.max(1, queryCount)) return 'upstream_timeout';
  if (failFastAfterOpen && failFastAfterTransient) return 'upstream_timeout';
  return null;
}

function normalizeHeatmapStepLabel(raw, { slot } = {}) {
  const slotPrefix = String(slot || '').trim().toUpperCase();
  const base =
    raw && typeof raw === 'object'
      ? String(raw.step || raw.category || raw.slot_step || raw.title || raw.name || raw.display_name || '').trim()
      : String(raw || '').trim();
  const label = base || '';
  if (!label) return '';
  if (!slotPrefix) return label.slice(0, 60);
  return `${slotPrefix} ${label}`.slice(0, 60);
}

function buildHeatmapStepsFromRoutine(routine, { testProduct } = {}) {
  const routineObj = routine && typeof routine === 'object' ? routine : {};
  const am = Array.isArray(routineObj.am) ? routineObj.am : [];
  const pm = Array.isArray(routineObj.pm) ? routineObj.pm : [];
  const out = [];

  for (const item of am) {
    const label = normalizeHeatmapStepLabel(item, { slot: 'AM' });
    out.push(label || item);
    if (out.length >= 16) return out;
  }
  for (const item of pm) {
    const label = normalizeHeatmapStepLabel(item, { slot: 'PM' });
    out.push(label || item);
    if (out.length >= 16) return out;
  }
  if (testProduct) {
    const label = normalizeHeatmapStepLabel(testProduct, { slot: 'TEST' });
    out.push(label || testProduct);
  }
  return out;
}

function extractHeatmapStepsFromConflictDetector({ conflictDetector, contextRaw } = {}) {
  if (conflictDetector && typeof conflictDetector === 'object') {
    const candidates = [
      conflictDetector.steps,
      conflictDetector.routine_steps,
      conflictDetector.routineSteps,
      conflictDetector.routineStepsV1,
      conflictDetector.routine && conflictDetector.routine.steps,
      conflictDetector.routine && conflictDetector.routine.routine_steps,
      conflictDetector.routine && conflictDetector.routine.routineSteps,
    ];
    for (const candidate of candidates) {
      if (Array.isArray(candidate) && candidate.length) return candidate;
    }
    const routineCandidate =
      conflictDetector.routine && typeof conflictDetector.routine === 'object'
        ? conflictDetector.routine
        : null;
    if (routineCandidate) {
      const steps = buildHeatmapStepsFromRoutine(routineCandidate);
      if (steps.length) return steps;
    }
  }

  if (contextRaw && typeof contextRaw === 'object') {
    const candidates = [
      contextRaw.routine,
      contextRaw.routine_v1,
      contextRaw.routineV1,
      contextRaw.current_routine,
      contextRaw.currentRoutine,
      contextRaw.recommended_routine,
      contextRaw.recommendedRoutine,
    ];
    for (const candidate of candidates) {
      if (Array.isArray(candidate) && candidate.length) return candidate;
      if (candidate && typeof candidate === 'object') {
        const steps = buildHeatmapStepsFromRoutine(candidate);
        if (steps.length) return steps;
      }
    }
  }

  return [];
}

let openaiClient;
let openaiCtor;
let openaiCtorResolved = false;
function getOpenAIConstructor() {
  if (openaiCtorResolved) return openaiCtor;
  openaiCtorResolved = true;
  try {
    const mod = require('openai');
    if (typeof mod === 'function') {
      openaiCtor = mod;
      return openaiCtor;
    }
    if (mod && typeof mod.OpenAI === 'function') {
      openaiCtor = mod.OpenAI;
      return openaiCtor;
    }
    if (mod && typeof mod.default === 'function') {
      openaiCtor = mod.default;
      return openaiCtor;
    }
  } catch (_err) {
    openaiCtor = null;
  }
  return openaiCtor;
}
function getOpenAIClient() {
  if (!OPENAI_API_KEY) return null;
  const OpenAI = getOpenAIConstructor();
  if (!OpenAI) return null;
  if (!openaiClient) {
    openaiClient = new OpenAI({
      apiKey: OPENAI_API_KEY,
      ...(OPENAI_BASE_URL ? { baseURL: OPENAI_BASE_URL } : {}),
    });
  }
  return openaiClient;
}

let geminiClient;
let geminiClientInitFailed = false;
function getGeminiClient() {
  if (!GEMINI_API_KEY) return { client: null, init_error: VisionUnavailabilityReason.VISION_MISSING_KEY };
  if (geminiClient) return { client: geminiClient, init_error: null };
  if (geminiClientInitFailed) return { client: null, init_error: VisionUnavailabilityReason.VISION_UNKNOWN };

  try {
    const { GoogleGenAI } = require('@google/genai');
    geminiClient = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
    return { client: geminiClient, init_error: null };
  } catch (_err) {
    geminiClientInitFailed = true;
    return { client: null, init_error: VisionUnavailabilityReason.VISION_UNKNOWN };
  }
}

function resolveVisionProviderSelection() {
  const requested = SKIN_VISION_PROVIDER;
  if (requested === 'openai') {
    return { provider: 'openai', apiKeyConfigured: Boolean(OPENAI_API_KEY), requested };
  }
  if (requested === 'gemini') {
    return { provider: 'gemini', apiKeyConfigured: Boolean(GEMINI_API_KEY), requested };
  }

  if (GEMINI_API_KEY) return { provider: 'gemini', apiKeyConfigured: true, requested };
  if (OPENAI_API_KEY) return { provider: 'openai', apiKeyConfigured: true, requested };
  return { provider: 'gemini', apiKeyConfigured: false, requested };
}

async function withVisionTimeout(promise, timeoutMs) {
  let timeoutRef = null;
  try {
    return await Promise.race([
      promise,
      new Promise((_, reject) => {
        timeoutRef = setTimeout(() => {
          const err = new Error(`vision timeout after ${timeoutMs}ms`);
          err.name = 'AbortError';
          reject(err);
        }, timeoutMs);
      }),
    ]);
  } finally {
    if (timeoutRef) clearTimeout(timeoutRef);
  }
}

async function extractTextFromGeminiResponse(response) {
  if (!response) return '';
  if (typeof response.text === 'function') {
    const maybe = await response.text();
    if (typeof maybe === 'string' && maybe.trim()) return maybe;
  }
  if (typeof response.text === 'string' && response.text.trim()) return response.text;

  const candidates = Array.isArray(response.candidates) ? response.candidates : [];
  const parts = [];
  for (const candidate of candidates) {
    const contentParts =
      candidate && candidate.content && Array.isArray(candidate.content.parts) ? candidate.content.parts : [];
    for (const part of contentParts) {
      if (part && typeof part.text === 'string' && part.text.trim()) parts.push(part.text);
    }
  }
  return parts.join('\n').trim();
}

function chooseVisionPhoto(passedPhotos) {
  if (!Array.isArray(passedPhotos) || !passedPhotos.length) return null;
  return (
    passedPhotos.find((p) => String(p.slot_id || '').trim().toLowerCase() === 'daylight') ||
    passedPhotos[0] ||
    null
  );
}

function isSignedUrlExpiredSignal({ status, detail, code } = {}) {
  const statusNum = Number(status || 0);
  const combined = `${detail || ''} ${code || ''}`.toLowerCase();
  const token = /(expired|request has expired|x-amz-expires|signature.*expired|token.*expired|expiredtoken|expiration)/i;
  if (token.test(combined)) return true;
  return statusNum === 410;
}

function classifySignedUrlFetchFailure({ status, detail, code } = {}) {
  if (isSignedUrlExpiredSignal({ status, detail, code })) {
    return { failure_code: 'DOWNLOAD_URL_EXPIRED', retryable: false };
  }
  const statusNum = Number(status || 0);
  const errorCode = String(code || '').toUpperCase();
  if (statusNum === 408) {
    return { failure_code: 'DOWNLOAD_URL_TIMEOUT', retryable: true };
  }
  if (statusNum >= 500 && statusNum < 600) {
    return { failure_code: 'DOWNLOAD_URL_FETCH_5XX', retryable: true };
  }
  if (statusNum >= 400 && statusNum < 500) {
    return { failure_code: 'DOWNLOAD_URL_FETCH_4XX', retryable: false };
  }
  if (errorCode === 'ECONNABORTED' || errorCode === 'ETIMEDOUT' || /timeout/i.test(String(detail || ''))) {
    return { failure_code: 'DOWNLOAD_URL_TIMEOUT', retryable: true };
  }
  if (errorCode === 'ENOTFOUND' || errorCode === 'EAI_AGAIN' || errorCode === 'EAI_FAIL') {
    return { failure_code: 'DOWNLOAD_URL_DNS', retryable: true };
  }
  return { failure_code: 'DOWNLOAD_URL_FETCH_5XX', retryable: true };
}

async function fetchBytesFromSignedUrl(downloadUrl) {
  const startedAt = Date.now();
  let lastFailure = null;
  const totalAttempts = PHOTO_FETCH_RETRIES + 1;

  for (let attempt = 0; attempt < totalAttempts; attempt += 1) {
    const elapsed = Date.now() - startedAt;
    const remaining = PHOTO_FETCH_TOTAL_TIMEOUT_MS - elapsed;
    if (remaining <= 0) {
      return {
        ok: false,
        failure_code: 'DOWNLOAD_URL_TIMEOUT',
        reason: 'download_url_fetch_timeout',
        status: null,
        detail: 'signed_url_fetch_total_timeout',
      };
    }

    const perAttemptTimeout = Math.min(PHOTO_FETCH_TIMEOUT_MS, remaining);
    try {
      const blobResp = await axios.get(downloadUrl, {
        timeout: perAttemptTimeout,
        validateStatus: () => true,
        responseType: 'arraybuffer',
        maxBodyLength: 15 * 1024 * 1024,
        maxContentLength: 15 * 1024 * 1024,
      });
      const detail = pickUpstreamErrorDetail(blobResp.data);
      if (blobResp.status >= 200 && blobResp.status < 300 && blobResp.data) {
        const contentTypeHeader =
          blobResp.headers && (blobResp.headers['content-type'] || blobResp.headers['Content-Type'])
            ? String(blobResp.headers['content-type'] || blobResp.headers['Content-Type']).trim()
            : null;
        return {
          ok: true,
          buffer: Buffer.from(blobResp.data),
          contentTypeHeader,
        };
      }

      const failure = classifySignedUrlFetchFailure({ status: blobResp.status, detail });
      lastFailure = {
        ok: false,
        failure_code: failure.failure_code,
        reason: String(failure.failure_code || 'download_url_fetch_failed').toLowerCase(),
        status: blobResp.status,
        detail: detail || null,
      };
      if (!failure.retryable || attempt >= totalAttempts - 1) return lastFailure;
    } catch (err) {
      const failure = classifySignedUrlFetchFailure({
        status: null,
        detail: err && err.message ? err.message : null,
        code: err && err.code ? err.code : null,
      });
      lastFailure = {
        ok: false,
        failure_code: failure.failure_code,
        reason: String(failure.failure_code || 'download_url_fetch_failed').toLowerCase(),
        status: null,
        detail: err && (err.code || err.message) ? String(err.code || err.message) : null,
      };
      if (!failure.retryable || attempt >= totalAttempts - 1) return lastFailure;
    }

    const backoffMs = Math.min(
      PHOTO_FETCH_RETRY_BASE_MS * (2 ** attempt),
      Math.max(0, PHOTO_FETCH_TOTAL_TIMEOUT_MS - (Date.now() - startedAt)),
    );
    if (backoffMs > 0) await sleep(backoffMs);
  }

  return (
    lastFailure || {
      ok: false,
      failure_code: 'DOWNLOAD_URL_FETCH_5XX',
      reason: 'download_url_fetch_failed',
      status: null,
      detail: null,
    }
  );
}

async function fetchPhotoBytesFromPivotaBackend({ req, photoId } = {}) {
  const auroraUid = getAuroraUidFromReq(req);
  if (!photoId) return { ok: false, reason: 'photo_id_missing', failure_code: 'DOWNLOAD_URL_GENERATE_FAILED' };

  const cached = getPhotoBytesCache({ photoId, auroraUid });
  if (cached) {
    return {
      ok: true,
      buffer: Buffer.from(cached.buffer),
      contentType: cached.contentType || 'image/jpeg',
      source: 'upload_cache',
    };
  }

  if (!PIVOTA_BACKEND_BASE_URL) {
    return {
      ok: false,
      reason: 'pivota_backend_not_configured',
      failure_code: 'DOWNLOAD_URL_GENERATE_FAILED',
    };
  }

  const authHeaders = buildPivotaBackendAuthHeaders(req);
  if (!Object.keys(authHeaders).length) {
    return {
      ok: false,
      reason: 'pivota_backend_auth_not_configured',
      failure_code: 'DOWNLOAD_URL_GENERATE_FAILED',
    };
  }

  let upstreamResp = null;
  try {
    upstreamResp = await axios.get(`${PIVOTA_BACKEND_BASE_URL}/photos/download-url`, {
      timeout: PHOTO_DOWNLOAD_URL_TIMEOUT_MS,
      validateStatus: () => true,
      headers: authHeaders,
      params: { upload_id: photoId },
    });
  } catch (err) {
    return {
      ok: false,
      reason: 'download_url_generate_failed',
      failure_code: 'DOWNLOAD_URL_GENERATE_FAILED',
      status: null,
      detail: err && (err.code || err.message) ? String(err.code || err.message) : null,
    };
  }

  const download = upstreamResp && upstreamResp.data && upstreamResp.data.download ? upstreamResp.data.download : null;
  const downloadUrl = download && typeof download.url === 'string' ? download.url.trim() : '';
  if (upstreamResp.status !== 200 || !downloadUrl) {
    const detail = pickUpstreamErrorDetail(upstreamResp.data);
    return {
      ok: false,
      reason: 'download_url_generate_failed',
      failure_code: 'DOWNLOAD_URL_GENERATE_FAILED',
      status: upstreamResp.status,
      detail: detail || null,
    };
  }

  const downloadExpiresAt =
    (download && typeof download.expires_at === 'string' && download.expires_at) ||
    (upstreamResp.data && typeof upstreamResp.data.expires_at === 'string' && upstreamResp.data.expires_at) ||
    null;
  const secLeft = secondsUntilIso(downloadExpiresAt);
  if (secLeft != null && secLeft <= 0) {
    return {
      ok: false,
      reason: 'download_url_expired',
      failure_code: 'DOWNLOAD_URL_EXPIRED',
      status: 410,
      detail: 'signed_url_expired_before_fetch',
    };
  }

  const contentTypeUpstream =
    typeof upstreamResp.data.content_type === 'string' && upstreamResp.data.content_type.trim()
      ? upstreamResp.data.content_type.trim()
      : null;
  const blobResp = await fetchBytesFromSignedUrl(downloadUrl);
  if (!blobResp || !blobResp.ok) return blobResp || { ok: false, reason: 'download_url_fetch_failed' };

  const buffer = blobResp.buffer;
  const contentTypeHeader = blobResp.contentTypeHeader;
  const finalContentType = contentTypeHeader || contentTypeUpstream || 'image/jpeg';
  setPhotoBytesCache({ photoId, auroraUid, buffer, contentType: finalContentType });
  return {
    ok: true,
    buffer,
    contentType: finalContentType,
    source: 'signed_url',
  };
}

function isPassedPhotoQcStatus(qcStatus) {
  return normalizePhotoQcStatus(qcStatus) === 'passed';
}

function normalizePhotoQcStatus(rawStatus) {
  const token = String(rawStatus || '')
    .trim()
    .toLowerCase();
  if (!token) return '';
  if (token === 'passed' || token === 'pass' || token === 'ok' || token === 'success' || token === 'succeeded') {
    return 'passed';
  }
  if (token === 'degraded' || token === 'warn' || token === 'warning' || token === 'low') {
    return 'degraded';
  }
  if (token === 'fail' || token === 'failed' || token === 'reject' || token === 'rejected' || token === 'bad') {
    return 'failed';
  }
  return '';
}

function resolvePhotoQcStatus(payload) {
  const source = payload && typeof payload === 'object' && !Array.isArray(payload) ? payload : null;
  if (!source) return null;
  const nestedQc = source.qc && typeof source.qc === 'object' && !Array.isArray(source.qc) ? source.qc : null;
  const candidates = [
    source.qc_status,
    nestedQc && nestedQc.qc_status,
    source.status,
    nestedQc && nestedQc.status,
    source.result,
    nestedQc && nestedQc.result,
    source.state,
    nestedQc && nestedQc.state,
  ];
  for (const candidate of candidates) {
    const normalized = normalizePhotoQcStatus(candidate);
    if (normalized) return normalized;
  }
  return null;
}

function hasNonEmptyRoutineInput(routineCandidate) {
  return Boolean(
    routineCandidate != null &&
      (typeof routineCandidate === 'string'
        ? String(routineCandidate).trim().length > 0
        : Array.isArray(routineCandidate)
          ? routineCandidate.length > 0
          : typeof routineCandidate === 'object'
            ? Object.keys(routineCandidate).length > 0
            : false),
  );
}

function normalizeQualityGradeForMetrics(grade) {
  const token = String(grade || '')
    .trim()
    .toLowerCase();
  if (token === 'pass' || token === 'degraded' || token === 'fail') return token;
  return 'unknown';
}

function normalizePipelineVersionForMetrics(version) {
  const token = String(version || '')
    .trim()
    .toLowerCase();
  if (token === 'a' || token === 'legacy' || token === 'v1') return 'A';
  if (token === 'b' || token === 'v2') return 'B';
  return 'unknown';
}

function inferDeviceClassForMetrics(req) {
  const explicit = req && typeof req.get === 'function' ? req.get('X-Device-Class') : null;
  if (explicit && String(explicit).trim()) return String(explicit).trim().slice(0, 64);
  const ua = req && typeof req.get === 'function' ? String(req.get('User-Agent') || '') : '';
  const lowered = ua.toLowerCase();
  if (!lowered) return 'unknown';
  if (/(iphone|android|ipad|mobile)/.test(lowered)) return 'mobile';
  if (/(macintosh|windows|linux|x11)/.test(lowered)) return 'desktop';
  return 'unknown';
}

function buildPhotoAutoNoticeMessage({ language, failureCode }) {
  const code = String(failureCode || 'DOWNLOAD_URL_GENERATE_FAILED').trim().toUpperCase();
  if (language === 'CN') {
    return `${code}/`;
  }
  return `We couldn't analyze your photo this time (reason: ${code}). Results below are based on your answers/history only. Please re-upload and retry.`;
}

let inferSkinMaskOnFaceCropImpl = inferSkinMaskOnFaceCrop;

function computeElapsedMs(startHrTime) {
  if (typeof startHrTime !== 'bigint') return 0;
  return Number(process.hrtime.bigint() - startHrTime) / 1e6;
}

function withTimeout(promise, timeoutMs, timeoutCode) {
  const ms = Number.isFinite(Number(timeoutMs)) ? Math.max(1, Math.trunc(Number(timeoutMs))) : 0;
  if (!ms) return promise;
  let timer = null;
  const timeoutPromise = new Promise((_, reject) => {
    timer = setTimeout(() => {
      const err = new Error(timeoutCode || 'timeout');
      err.code = timeoutCode || 'TIMEOUT';
      reject(err);
    }, ms);
    if (timer && typeof timer.unref === 'function') timer.unref();
  });
  return Promise.race([promise, timeoutPromise]).finally(() => {
    if (timer) clearTimeout(timer);
  });
}

function normalizeSkinmaskFallbackReason(rawReason, detail) {
  const reason = String(rawReason || '').trim().toUpperCase();
  const info = String(detail || '').trim().toUpperCase();
  if (reason.includes('TIMEOUT') || info.includes('TIMEOUT')) return 'TIMEOUT';
  if (
    reason === 'MODEL_PATH_MISSING' ||
    reason === 'ONNXRUNTIME_MISSING' ||
    reason === 'SESSION_UNAVAILABLE' ||
    reason === 'SESSION_LOAD_FAILED' ||
    info.includes('ENOENT') ||
    info.includes('NO SUCH FILE')
  ) {
    return 'MODEL_MISSING';
  }
  return 'ONNX_FAIL';
}

function maybeBuildPhotoModulesCardForAnalysis({
  requestId,
  analysis,
  usedPhotos,
  photoQuality,
  photoNotice,
  diagnosisInternal,
  profileSummary,
  language,
  skinMask,
} = {}) {
  if (!DIAG_PHOTO_MODULES_CARD) return null;
  if (DIAG_OVERLAY_MODE !== 'client') return null;

  const photoNoticeText =
    typeof photoNotice === 'string'
      ? photoNotice
      : photoNotice && typeof photoNotice.message === 'string'
        ? photoNotice.message
        : null;

  const built = buildPhotoModulesCard({
    requestId,
    analysis,
    usedPhotos: Boolean(usedPhotos),
    photoQuality,
    photoNotice: photoNoticeText,
    diagnosisInternal,
    profileSummary,
    language,
    ingredientRecEnabled: DIAG_INGREDIENT_REC,
    productRecEnabled: DIAG_PRODUCT_REC,
    productRecMinCitations: DIAG_PRODUCT_REC_MIN_CITATIONS,
    productRecMinEvidenceGrade: DIAG_PRODUCT_REC_MIN_EVIDENCE_GRADE,
    productRecRepairOnlyWhenDegraded: DIAG_PRODUCT_REC_REPAIR_ONLY_WHEN_DEGRADED,
    internalTestMode: INTERNAL_TEST_MODE,
    ingredientKbArtifactPath: DIAG_INGREDIENT_KB_V2_PATH,
    productCatalogPath: DIAG_PRODUCT_CATALOG_PATH,
    skinMask,
  });
  if (!built || !built.card) return null;

  const metrics = built.metrics && typeof built.metrics === 'object' ? built.metrics : {};
  recordPhotoModulesCardEmitted({
    qualityGrade: metrics.quality_grade || (photoQuality && photoQuality.grade),
  });

  const regionCounts = Array.isArray(metrics.regionCounts) ? metrics.regionCounts : [];
  for (const row of regionCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordRegionsEmitted({
      regionType: row.region_type,
      issueType: row.issue_type,
      delta,
    });
  }

  const moduleIssueCounts = Array.isArray(metrics.moduleIssueCounts) ? metrics.moduleIssueCounts : [];
  for (const row of moduleIssueCounts) {
    const count = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (count <= 0) continue;
    recordModulesIssueCountHistogram({
      moduleId: row.module_id,
      issueType: row.issue_type,
      count,
    });
  }

  const ingredientActionCounts = Array.isArray(metrics.ingredientActionCounts) ? metrics.ingredientActionCounts : [];
  for (const row of ingredientActionCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordIngredientActionsEmitted({
      moduleId: row.module_id,
      issueType: row.issue_type,
      delta,
    });
  }

  const productRecEmittedCounts = Array.isArray(metrics.productRecEmittedCounts) ? metrics.productRecEmittedCounts : [];
  for (const row of productRecEmittedCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordProductRecEmitted({
      market: row.market,
      qualityGrade: row.quality_grade,
      delta,
    });
  }

  const productRecSuppressedCounts = Array.isArray(metrics.productRecSuppressedCounts) ? metrics.productRecSuppressedCounts : [];
  for (const row of productRecSuppressedCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordProductRecSuppressed({
      reason: row.reason,
      delta,
    });
  }

  const claimsTemplateFallbackCounts = Array.isArray(metrics.claimsTemplateFallbackCounts) ? metrics.claimsTemplateFallbackCounts : [];
  for (const row of claimsTemplateFallbackCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordClaimsTemplateFallback({
      reason: row.reason,
      delta,
    });
  }

  const claimsViolationCounts = Array.isArray(metrics.claimsViolationCounts) ? metrics.claimsViolationCounts : [];
  for (const row of claimsViolationCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordClaimsViolation({
      reason: row.reason,
      delta,
    });
  }

  const geometryDropCounts = Array.isArray(metrics.geometryDropCounts) ? metrics.geometryDropCounts : [];
  for (const row of geometryDropCounts) {
    const delta = Number.isFinite(Number(row && row.count)) ? Number(row.count) : 0;
    if (delta <= 0) continue;
    recordGeometrySanitizerDropReason({
      reason: row.reason,
      regionType: row.region_type,
      delta,
    });
  }

  return built.card;
}

async function maybeInferSkinMaskForPhotoModules({ imageBuffer, diagnosisInternal, logger, requestId } = {}) {
  if (!DIAG_SKINMASK_ENABLED) return null;
  if (!imageBuffer || !Buffer.isBuffer(imageBuffer) || !imageBuffer.length) return null;
  recordSkinmaskEnabled();
  if (!DIAG_SKINMASK_MODEL_PATH) {
    recordSkinmaskFallback({ reason: 'MODEL_MISSING' });
    logger?.warn(
      {
        request_id: requestId || null,
        reason: 'MODEL_MISSING',
      },
      'aurora bff: skinmask onnx inference skipped',
    );
    return null;
  }

  const inferStartedAt = process.hrtime.bigint();
  try {
    const inferred = await withTimeout(
      Promise.resolve(
        inferSkinMaskOnFaceCropImpl({
          imageBuffer,
          diagnosisInternal,
          modelPath: DIAG_SKINMASK_MODEL_PATH,
        }),
      ),
      DIAG_SKINMASK_TIMEOUT_MS,
      'SKINMASK_TIMEOUT',
    );
    observeSkinmaskInferLatency({ latencyMs: computeElapsedMs(inferStartedAt) });
    if (!inferred || !inferred.ok) {
      const fallbackReason = normalizeSkinmaskFallbackReason(inferred && inferred.reason, inferred && inferred.detail);
      recordSkinmaskFallback({ reason: fallbackReason });
      logger?.warn(
        {
          request_id: requestId || null,
          fallback_reason: fallbackReason,
          reason: inferred && inferred.reason ? inferred.reason : 'unknown',
          detail: inferred && inferred.detail ? inferred.detail : null,
        },
        'aurora bff: skinmask onnx inference skipped',
      );
      return null;
    }
    return inferred;
  } catch (error) {
    observeSkinmaskInferLatency({ latencyMs: computeElapsedMs(inferStartedAt) });
    const fallbackReason = normalizeSkinmaskFallbackReason(error && error.code ? error.code : null, error && error.message);
    recordSkinmaskFallback({ reason: fallbackReason });
    logger?.warn(
      {
        request_id: requestId || null,
        fallback_reason: fallbackReason,
        reason: error && error.code ? String(error.code) : 'unknown',
        err: error && error.message ? error.message : String(error),
      },
      'aurora bff: skinmask onnx inference failed',
    );
    return null;
  }
}

async function buildAutoAnalysisFromConfirmedPhoto({ req, ctx, photoId, slotId, qcStatus, logger, identity } = {}) {
  if (!PHOTO_AUTO_ANALYZE_AFTER_CONFIRM) return null;
  if (!photoId || !isPassedPhotoQcStatus(qcStatus)) return null;

  const language = ctx && ctx.lang === 'CN' ? 'CN' : 'EN';
  const slot = String(slotId || 'daylight').trim() || 'daylight';
  const qc = String(qcStatus || 'passed').trim().toLowerCase() || 'passed';

  let profile = null;
  let recentLogs = [];
  let resolvedIdentity = identity || null;
  try {
    resolvedIdentity = resolvedIdentity || (await resolveIdentity(req, ctx));
    profile = await getProfileForIdentity({ auroraUid: resolvedIdentity.auroraUid, userId: resolvedIdentity.userId });
    recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: resolvedIdentity.auroraUid, userId: resolvedIdentity.userId }, 7);
  } catch (err) {
    logger?.warn({ err: err && err.message ? err.message : String(err) }, 'aurora bff: auto analysis failed to load memory context');
  }

  const profileSummary = summarizeProfileForContext(profile);
  const recentLogsSummary = Array.isArray(recentLogs) ? recentLogs.slice(0, 7) : [];
  const routineCandidate = profileSummary && profileSummary.currentRoutine;
  const hasPrimaryInput = hasNonEmptyRoutineInput(routineCandidate) || recentLogsSummary.length > 0;
  const detectorConfidence = inferDetectorConfidence({ profileSummary, recentLogsSummary, routineCandidate });
  const photoQuality = classifyPhotoQuality([{ slot_id: slot, photo_id: photoId, qc_status: qc }]);

  const fieldMissing = [];
  const qualityReasons = [];

  let usedPhotos = false;
  let analysisSource = hasPrimaryInput ? 'rule_based_with_photo_qc' : 'baseline_low_confidence';
  let diagnosisV1 = null;
  let diagnosisV1Internal = null;
  let diagnosisPhotoBytes = null;
  let analysis = null;
  let photoNotice = null;

  try {
    const photoResp = await fetchPhotoBytesFromPivotaBackend({ req, photoId });
    if (photoResp && photoResp.ok && photoResp.buffer && Buffer.isBuffer(photoResp.buffer) && photoResp.buffer.length > 0) {
      diagnosisPhotoBytes = photoResp.buffer;
      const profiler = createStageProfiler();
      const diag = await runSkinDiagnosisV1({
        imageBuffer: diagnosisPhotoBytes,
        language,
        profileSummary,
        recentLogsSummary,
        profiler,
      });
      if (diag && diag.ok && diag.diagnosis) {
        diagnosisV1 = diag.diagnosis;
        diagnosisV1Internal = diag.internal || null;
        usedPhotos = true;
        const qGrade = String(diagnosisV1?.quality?.grade || '').trim().toLowerCase();
        if (qGrade === 'fail') {
          analysis = buildRetakeSkinAnalysis({ language, photoQuality: diagnosisV1.quality || photoQuality });
          analysisSource = 'retake';
          qualityReasons.push(
            language === 'CN'
              ? ''
              : 'Photo was read, but pixel quality is insufficient; please retake and recheck.',
          );
        } else {
          analysis = buildSkinAnalysisFromDiagnosisV1(diagnosisV1, { language, profileSummary });
          analysisSource = 'diagnosis_v1_template';
        }
        if (qGrade === 'degraded') {
          qualityReasons.push(
            language === 'CN'
              ? ''
              : 'Photo analysis completed (degraded quality): conclusions are conservative.',
          );
        } else if (qGrade !== 'fail') {
          qualityReasons.push(language === 'CN' ? '' : 'Auto skin analysis completed from your photo.');
        }
      } else {
        const failureCode = 'diagnosis_failed';
        fieldMissing.push({ field: 'analysis.used_photos', reason: failureCode });
        photoNotice = {
          failure_code: failureCode,
          message: buildPhotoAutoNoticeMessage({ language, failureCode }),
        };
        qualityReasons.push(
          language === 'CN'
            ? '/'
            : 'Photo bytes were loaded, but diagnosis did not complete reliably; fell back to answers/history baseline.',
        );
      }
    } else {
      const failureCode = String(photoResp && (photoResp.failure_code || photoResp.reason) ? photoResp.failure_code || photoResp.reason : 'DOWNLOAD_URL_GENERATE_FAILED')
        .trim()
        .toUpperCase();
      fieldMissing.push({ field: 'analysis.used_photos', reason: failureCode });
      photoNotice = {
        failure_code: failureCode,
        message: buildPhotoAutoNoticeMessage({ language, failureCode }),
      };
      qualityReasons.push(language === 'CN' ? `${failureCode}` : `Photo fetch failed (${failureCode}).`);
    }
  } catch (err) {
    const failureCode = 'DOWNLOAD_URL_FETCH_5XX';
    fieldMissing.push({ field: 'analysis.used_photos', reason: failureCode });
    photoNotice = {
      failure_code: failureCode,
      message: buildPhotoAutoNoticeMessage({ language, failureCode }),
    };
    qualityReasons.push(language === 'CN' ? `${failureCode}` : `Photo fetch error (${failureCode}).`);
    logger?.warn(
      { err: err && err.message ? err.message : String(err) },
      'aurora bff: auto analysis photo fetch failed',
    );
  }

  if (!analysis) {
    if (hasPrimaryInput) {
      analysis = buildRuleBasedSkinAnalysis({ profile: profileSummary || profile, recentLogs, language });
      analysisSource = 'rule_based_with_photo_qc';
    } else {
      fieldMissing.push({ field: 'analysis.used_photos', reason: 'routine_or_recent_logs_required' });
      qualityReasons.push(
        language === 'CN'
          ? '/'
          : 'Routine/recent logs are missing; returning a low-risk baseline first.',
      );
      analysis = buildLowConfidenceBaselineSkinAnalysis({ profile: profileSummary || profile, language });
      analysisSource = 'baseline_low_confidence';
    }
  }

  if (analysis && diagnosisV1 && usedPhotos) {
    analysis = mergePhotoFindingsIntoAnalysis({
      analysis,
      diagnosisV1,
      language,
      profileSummary,
    });
  }

  analysis = buildExecutablePlanForAnalysis({
    analysis,
    language,
    usedPhotos,
    photoQuality: diagnosisV1 && diagnosisV1.quality ? diagnosisV1.quality : photoQuality,
    profileSummary,
    photoNoticeOverride: photoNotice && typeof photoNotice.message === 'string' ? photoNotice.message : '',
    photoFailureCode: photoNotice && typeof photoNotice.failure_code === 'string' ? photoNotice.failure_code : '',
    photosProvided: true,
  });
  const geometrySanitizer =
    analysis && analysis.__geometry_sanitizer && typeof analysis.__geometry_sanitizer === 'object'
      ? analysis.__geometry_sanitizer
      : null;
  if (analysis && Object.prototype.hasOwnProperty.call(analysis, '__geometry_sanitizer')) {
    delete analysis.__geometry_sanitizer;
  }

  const qualityGradeForMetrics = normalizeQualityGradeForMetrics(diagnosisV1?.quality?.grade || photoQuality?.grade);
  const pipelineVersionForMetrics = normalizePipelineVersionForMetrics(String(process.env.DIAG_PIPELINE_VERSION || 'legacy'));
  const deviceClassForMetrics = inferDeviceClassForMetrics(req);
  const sanitizerTotals = geometrySanitizer || { checked_n: 0, dropped_n: 0, clipped_n: 0 };
  recordAnalyzeRequest({
    issueType: 'all',
    qualityGrade: qualityGradeForMetrics,
    pipelineVersion: pipelineVersionForMetrics,
    deviceClass: deviceClassForMetrics,
  });
  recordGeometrySanitizerTotals({
    issueType: 'all',
    qualityGrade: qualityGradeForMetrics,
    pipelineVersion: pipelineVersionForMetrics,
    deviceClass: deviceClassForMetrics,
    dropped: sanitizerTotals.dropped_n,
    clipped: sanitizerTotals.clipped_n,
  });
  const sanitizerByIssue =
    geometrySanitizer && geometrySanitizer.by_issue && typeof geometrySanitizer.by_issue === 'object'
      ? geometrySanitizer.by_issue
      : {};
  for (const [issueType, issueStatsRaw] of Object.entries(sanitizerByIssue)) {
    const issueStats = issueStatsRaw && typeof issueStatsRaw === 'object' ? issueStatsRaw : {};
    const checkedN = Number(issueStats.checked_n || 0);
    if (checkedN <= 0) continue;
    recordAnalyzeRequest({
      issueType,
      qualityGrade: qualityGradeForMetrics,
      pipelineVersion: pipelineVersionForMetrics,
      deviceClass: deviceClassForMetrics,
    });
    recordGeometrySanitizerTotals({
      issueType,
      qualityGrade: qualityGradeForMetrics,
      pipelineVersion: pipelineVersionForMetrics,
      deviceClass: deviceClassForMetrics,
      dropped: issueStats.dropped_n,
      clipped: issueStats.clipped_n,
    });
  }

  const payload = {
    analysis,
    low_confidence: analysisSource === 'baseline_low_confidence',
    photos_provided: true,
    photo_qc: [`${slot}:${qc}`],
    used_photos: usedPhotos,
    analysis_source: !usedPhotos && analysisSource !== 'retake' ? 'rule_based_with_photo_qc' : analysisSource,
    ...(photoNotice ? { photo_notice: photoNotice } : {}),
    quality_report: {
      photo_quality: {
        grade: String(diagnosisV1?.quality?.grade || photoQuality?.grade || 'unknown').toLowerCase(),
        reasons:
          Array.isArray(diagnosisV1?.quality?.reasons) && diagnosisV1.quality.reasons.length
            ? diagnosisV1.quality.reasons
            : Array.isArray(photoQuality?.reasons)
              ? photoQuality.reasons
              : [],
      },
      detector_confidence: detectorConfidence,
      degraded_mode: SKIN_DEGRADED_MODE,
      llm: {
        vision: { decision: 'skip', reasons: ['auto_analysis_diagnosis_v1_only'], downgrade_confidence: false },
        report: { decision: 'skip', reasons: ['auto_analysis_diagnosis_v1_only'], downgrade_confidence: false },
      },
      reasons: qualityReasons.slice(0, 8),
    },
  };

  const photoModulesSkinMask = await maybeInferSkinMaskForPhotoModules({
    imageBuffer: diagnosisPhotoBytes,
    diagnosisInternal: diagnosisV1Internal,
    logger,
    requestId: ctx.request_id,
  });

  const photoModulesCard = maybeBuildPhotoModulesCardForAnalysis({
    requestId: ctx.request_id,
    analysis,
    usedPhotos,
    photoQuality: diagnosisV1 && diagnosisV1.quality ? diagnosisV1.quality : photoQuality,
    photoNotice,
    diagnosisInternal: diagnosisV1Internal,
    profileSummary,
    language,
    skinMask: photoModulesSkinMask,
  });

  const cards = [
    {
      card_id: `analysis_${ctx.request_id}`,
      type: 'analysis_summary',
      payload,
      ...(fieldMissing.length ? { field_missing: fieldMissing } : {}),
    },
    ...(photoModulesCard ? [photoModulesCard] : []),
  ];

  return {
    cards,
    session_patch: { next_state: 'S5_ANALYSIS_SUMMARY' },
    event: makeEvent(ctx, 'value_moment', {
      kind: 'skin_analysis',
      used_photos: usedPhotos,
      analysis_source: payload.analysis_source,
      source: 'photo_auto',
    }),
  };
}

async function safeBuildAutoAnalysisFromConfirmedPhoto({ req, ctx, photoId, slotId, qcStatus, logger, identity } = {}) {
  try {
    return await buildAutoAnalysisFromConfirmedPhoto({ req, ctx, photoId, slotId, qcStatus, logger, identity });
  } catch (err) {
    const message = err && err.message ? err.message : String(err);
    const code = err && err.code ? String(err.code) : 'PHOTO_AUTO_ANALYSIS_FAILED';
    logger?.error(
      {
        err: message,
        code,
        request_id: ctx && ctx.request_id ? ctx.request_id : null,
        trace_id: ctx && ctx.trace_id ? ctx.trace_id : null,
        aurora_uid: ctx && ctx.aurora_uid ? ctx.aurora_uid : null,
        photo_id: photoId || null,
        slot_id: slotId || null,
      },
      'aurora bff: auto analysis failed unexpectedly; returning photo_confirm only',
    );
    return {
      cards: [],
      session_patch: {},
      event: makeEvent(ctx, 'error', { code }),
    };
  }
}

async function runOpenAIVisionSkinAnalysis({
  imageBuffer,
  language,
  photoQuality,
  diagnosisPolicy,
  diagnosisV1,
  profileSummary,
  recentLogsSummary,
  profiler,
  promptVersion,
} = {}) {
  const startedAt = Date.now();
  if (!SKIN_VISION_ENABLED) {
    return {
      ok: false,
      provider: 'openai',
      reason: VisionUnavailabilityReason.VISION_DISABLED_BY_FLAG,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_DISABLED_BY_FLAG },
    };
  }
  const client = getOpenAIClient();
  if (!client) {
    return {
      ok: false,
      provider: 'openai',
      reason: VisionUnavailabilityReason.VISION_MISSING_KEY,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_MISSING_KEY },
    };
  }
  if (!imageBuffer || !Buffer.isBuffer(imageBuffer) || !imageBuffer.length) {
    return {
      ok: false,
      provider: 'openai',
      reason: VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED },
    };
  }

  const optimized =
    profiler && typeof profiler.time === 'function'
      ? await profiler.time(
          'decode',
          async () =>
            sharp(imageBuffer)
              .rotate()
              .resize({ width: 1024, height: 1024, fit: 'inside', withoutEnlargement: true })
              .jpeg({ quality: 82 })
              .toBuffer(),
          { kind: 'vision_prepare' },
        )
      : await sharp(imageBuffer)
          .rotate()
          .resize({ width: 1024, height: 1024, fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 82 })
          .toBuffer();
  const dataUrl = `data:image/jpeg;base64,${optimized.toString('base64')}`;

  const promptBase = buildSkinVisionPrompt({
    language,
    photoQuality,
    diagnosisPolicy,
    diagnosisV1,
    profileSummary,
    recentLogsSummary,
    promptVersion,
  });

  const attemptResult = await executeVisionWithRetry({
    maxRetries: SKIN_VISION_RETRY_MAX,
    baseDelayMs: SKIN_VISION_RETRY_BASE_MS,
    classifyError: classifyVisionProviderFailure,
    operation: async () => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), SKIN_VISION_TIMEOUT_MS);
      try {
        const callOpenAI = async () =>
          client.chat.completions.create(
            {
              model: SKIN_VISION_MODEL_OPENAI,
              temperature: 0.2,
              max_tokens: 480,
              response_format: { type: 'json_object' },
              messages: [
                { role: 'system', content: 'You produce ONLY JSON.' },
                {
                  role: 'user',
                  content: [
                    {
                      type: 'text',
                      text: `${promptBase}\nSELF-CHECK before responding: output MUST be strict JSON (no markdown/text), match the exact keys, and end strategy with a single direct question mark.\n`,
                    },
                    { type: 'image_url', image_url: { url: dataUrl } },
                  ],
                },
              ],
            },
            { signal: controller.signal },
          );

        const resp =
          profiler && typeof profiler.timeLlmCall === 'function'
            ? await profiler.timeLlmCall({ provider: 'openai', model: SKIN_VISION_MODEL_OPENAI, kind: 'skin_vision' }, callOpenAI)
            : await callOpenAI();

        const content = resp && resp.choices && resp.choices[0] && resp.choices[0].message ? resp.choices[0].message.content : '';
        const jsonOnly = unwrapCodeFence(content);
        const parsedObj = parseJsonOnlyObject(jsonOnly);
        const analysis = normalizeSkinAnalysisFromLLM(parsedObj, { language });
        if (!analysis) {
          const schemaErr = new Error('vision schema invalid');
          schemaErr.__vision_reason = VisionUnavailabilityReason.VISION_SCHEMA_INVALID;
          throw schemaErr;
        }
        return { analysis };
      } finally {
        clearTimeout(timer);
      }
    },
  });

  if (attemptResult && attemptResult.ok && attemptResult.result && attemptResult.result.analysis) {
    return {
      ok: true,
      provider: 'openai',
      analysis: attemptResult.result.analysis,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: attemptResult.retry,
    };
  }

  return {
    ok: false,
    provider: 'openai',
    reason: normalizeVisionReason(attemptResult && attemptResult.reason),
    upstream_status_code: toNullableInt(attemptResult && attemptResult.upstream_status_code),
    error: attemptResult && attemptResult.error_code ? String(attemptResult.error_code) : null,
    latency_ms: Date.now() - startedAt,
    retry:
      (attemptResult && attemptResult.retry) ||
      { attempted: 0, final: 'fail', last_reason: normalizeVisionReason(attemptResult && attemptResult.reason) },
  };
}

async function runGeminiVisionSkinAnalysis({
  imageBuffer,
  language,
  photoQuality,
  diagnosisPolicy,
  diagnosisV1,
  profileSummary,
  recentLogsSummary,
  profiler,
  promptVersion,
} = {}) {
  const startedAt = Date.now();
  if (!SKIN_VISION_ENABLED) {
    return {
      ok: false,
      provider: 'gemini',
      reason: VisionUnavailabilityReason.VISION_DISABLED_BY_FLAG,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_DISABLED_BY_FLAG },
    };
  }

  const gemini = getGeminiClient();
  if (!gemini || !gemini.client) {
    const reason =
      gemini && gemini.init_error ? normalizeVisionReason(gemini.init_error) : VisionUnavailabilityReason.VISION_MISSING_KEY;
    return {
      ok: false,
      provider: 'gemini',
      reason,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: reason },
    };
  }

  if (!imageBuffer || !Buffer.isBuffer(imageBuffer) || !imageBuffer.length) {
    return {
      ok: false,
      provider: 'gemini',
      reason: VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED },
    };
  }

  const optimized =
    profiler && typeof profiler.time === 'function'
      ? await profiler.time(
          'decode',
          async () =>
            sharp(imageBuffer)
              .rotate()
              .resize({ width: 1024, height: 1024, fit: 'inside', withoutEnlargement: true })
              .jpeg({ quality: 82 })
              .toBuffer(),
          { kind: 'vision_prepare' },
        )
      : await sharp(imageBuffer)
          .rotate()
          .resize({ width: 1024, height: 1024, fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 82 })
          .toBuffer();

  const promptBase = buildSkinVisionPrompt({
    language,
    photoQuality,
    diagnosisPolicy,
    diagnosisV1,
    profileSummary,
    recentLogsSummary,
    promptVersion,
  });

  const attemptResult = await executeVisionWithRetry({
    maxRetries: SKIN_VISION_RETRY_MAX,
    baseDelayMs: SKIN_VISION_RETRY_BASE_MS,
    classifyError: classifyVisionProviderFailure,
    operation: async () => {
      const callGemini = async () =>
        withVisionTimeout(
          gemini.client.models.generateContent({
            model: SKIN_VISION_MODEL_GEMINI,
            contents: [
              {
                role: 'user',
                parts: [
                  {
                    inlineData: {
                      mimeType: 'image/jpeg',
                      data: optimized.toString('base64'),
                    },
                  },
                  {
                    text: `${promptBase}\nSELF-CHECK before responding: output MUST be strict JSON (no markdown/text), match the exact keys, and end strategy with a single direct question mark.\n`,
                  },
                ],
              },
            ],
            config: {
              temperature: 0.2,
              responseMimeType: 'application/json',
            },
          }),
          SKIN_VISION_TIMEOUT_MS,
        );

      const resp =
        profiler && typeof profiler.timeLlmCall === 'function'
          ? await profiler.timeLlmCall({ provider: 'gemini', model: SKIN_VISION_MODEL_GEMINI, kind: 'skin_vision' }, callGemini)
          : await callGemini();

      const content = await extractTextFromGeminiResponse(resp);
      const jsonOnly = unwrapCodeFence(content);
      const parsedObj = parseJsonOnlyObject(jsonOnly);
      const analysis = normalizeSkinAnalysisFromLLM(parsedObj, { language });
      if (!analysis) {
        const schemaErr = new Error('vision schema invalid');
        schemaErr.__vision_reason = VisionUnavailabilityReason.VISION_SCHEMA_INVALID;
        throw schemaErr;
      }
      return { analysis };
    },
  });

  if (attemptResult && attemptResult.ok && attemptResult.result && attemptResult.result.analysis) {
    return {
      ok: true,
      provider: 'gemini',
      analysis: attemptResult.result.analysis,
      upstream_status_code: null,
      latency_ms: Date.now() - startedAt,
      retry: attemptResult.retry,
    };
  }

  return {
    ok: false,
    provider: 'gemini',
    reason: normalizeVisionReason(attemptResult && attemptResult.reason),
    upstream_status_code: toNullableInt(attemptResult && attemptResult.upstream_status_code),
    error: attemptResult && attemptResult.error_code ? String(attemptResult.error_code) : null,
    latency_ms: Date.now() - startedAt,
    retry:
      (attemptResult && attemptResult.retry) ||
      { attempted: 0, final: 'fail', last_reason: normalizeVisionReason(attemptResult && attemptResult.reason) },
  };
}

let runGeminiVisionSkinAnalysisImpl = runGeminiVisionSkinAnalysis;
let runOpenAIVisionSkinAnalysisImpl = runOpenAIVisionSkinAnalysis;

function shouldAttemptOpenAiFallbackFromGemini({ photoQuality, llmKillSwitch } = {}) {
  if (llmKillSwitch) return false;
  const grade = String(photoQuality && photoQuality.grade ? photoQuality.grade : '')
    .trim()
    .toLowerCase();
  if (grade === 'fail') return false;
  return true;
}

async function runVisionSkinAnalysis({ provider, llmKillSwitch, photoQuality, ...rest } = {}) {
  const target = String(provider || 'gemini')
    .trim()
    .toLowerCase();
  if (target === 'gemini') {
    const gemini = await runGeminiVisionSkinAnalysisImpl({ photoQuality, ...rest });
    if (gemini && gemini.ok) {
      return {
        ...gemini,
        attempted_providers: ['gemini'],
      };
    }
    if (shouldAttemptOpenAiFallbackFromGemini({ photoQuality, llmKillSwitch })) {
      const openai = await runOpenAIVisionSkinAnalysisImpl({ photoQuality, ...rest });
      if (openai && openai.ok) {
        return {
          ...openai,
          fallback_from: 'gemini',
          primary_failure_reason: normalizeVisionReason(gemini && gemini.reason),
          attempted_providers: ['gemini', 'openai'],
        };
      }
      return {
        ...(openai || {}),
        ok: false,
        provider: 'openai',
        reason: normalizeVisionReason((openai && openai.reason) || (gemini && gemini.reason)),
        fallback_from: 'gemini',
        primary_failure_reason: normalizeVisionReason(gemini && gemini.reason),
        attempted_providers: ['gemini', 'openai'],
      };
    }
    return {
      ...gemini,
      attempted_providers: ['gemini'],
    };
  }
  const openai = await runOpenAIVisionSkinAnalysisImpl({ photoQuality, ...rest });
  return {
    ...openai,
    attempted_providers: ['openai'],
  };
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function toNullableInt(value) {
  if (value === null || value === undefined || value === '') return null;
  const num = Number(value);
  if (!Number.isFinite(num)) return null;
  if (num <= 0) return null;
  return Math.trunc(num);
}

function toNullableNumber(value) {
  if (value === null || value === undefined || value === '') return null;
  const num = Number(value);
  if (!Number.isFinite(num)) return null;
  return num;
}

function secondsUntilIso(iso) {
  if (!iso || typeof iso !== 'string') return null;
  const ms = Date.parse(iso);
  if (!Number.isFinite(ms)) return null;
  return Math.max(0, Math.round((ms - Date.now()) / 1000));
}

function pickUpstreamErrorDetail(data) {
  if (!data) return null;
  if (typeof data === 'string') return data;
  if (data.detail) return data.detail;
  if (data.error) return data.error;
  if (data.message) return data.message;
  return null;
}

function normalizeSkinAnalysisFromLLM(obj, { language } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const o = obj && typeof obj === 'object' && !Array.isArray(obj) ? obj : null;
  if (!o) return null;

  const forbiddenRegex =
    lang === 'CN'
      ? /||||||||A|A||||/i
      : /rosacea|eczema|psoriasis|dermatitis|melanoma|infection|antibiotic|steroid|hydrocortisone|tretinoin|adapalene|isotretinoin|accutane|clindamycin|doxycycline|metronidazole/i;

  function clampText(raw, maxLen) {
    const s = typeof raw === 'string' ? raw.trim() : '';
    if (!s) return '';
    if (s.length <= maxLen) return s;
    return `${s.slice(0, Math.max(0, maxLen - 1))}`;
  }

  const featuresRaw = Array.isArray(o.features) ? o.features : [];
  const features = [];
  for (const raw of featuresRaw) {
    const f = raw && typeof raw === 'object' && !Array.isArray(raw) ? raw : null;
    if (!f) continue;
    const observation = clampText(f.observation, 120);
    if (!observation) continue;
    if (forbiddenRegex.test(observation)) return null;
    const c = typeof f.confidence === 'string' ? f.confidence.trim() : '';
    const confidence = c === 'pretty_sure' || c === 'somewhat_sure' || c === 'not_sure' ? c : 'somewhat_sure';
    features.push({ observation, confidence });
  }

  let strategyRaw = clampText(o.strategy, 420);
  const needsRiskCheckRaw = o.needs_risk_check ?? o.needsRiskCheck;
  const needs_risk_check = typeof needsRiskCheckRaw === 'boolean' ? needsRiskCheckRaw : false;

  const fallbackStrategy = lang === 'CN' ? '/' : 'Quick check: have you had stinging or redness recently?';
  if (strategyRaw) {
    const qIdx = Math.max(strategyRaw.lastIndexOf('?'), strategyRaw.lastIndexOf(''));
    if (qIdx !== -1) strategyRaw = strategyRaw.slice(0, qIdx + 1).trim();
    // Ensure "ONE direct question": replace earlier question marks with sentence punctuation.
    if (strategyRaw) {
      const last = strategyRaw[strategyRaw.length - 1];
      const replaceWith = lang === 'CN' ? '' : '.';
      const body = strategyRaw.slice(0, -1).replace(/[?]/g, replaceWith);
      strategyRaw = `${body}${last}`.trim();
    }
    if (forbiddenRegex.test(strategyRaw)) return null;
  }
  const strategy = strategyRaw || fallbackStrategy;
  if (!/[?]$/.test(strategy)) return null;

  if (features.length < 2 && !strategyRaw) return null;

  return {
    features: features.slice(0, 6),
    strategy,
    needs_risk_check,
  };
}

function mergePhotoFindingsIntoAnalysis({ analysis, diagnosisV1, language, profileSummary } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const base = analysis && typeof analysis === 'object' && !Array.isArray(analysis) ? { ...analysis } : null;
  if (!base) return analysis;
  const diagnosis = diagnosisV1 && typeof diagnosisV1 === 'object' && !Array.isArray(diagnosisV1) ? diagnosisV1 : null;
  if (!diagnosis) return base;

  const normalizeFinding = (raw) => {
    if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
    const issueType = typeof raw.issue_type === 'string' ? raw.issue_type.trim() : '';
    const subtype = typeof raw.subtype === 'string' ? raw.subtype.trim() : '';
    if (!issueType) return null;
    const severity = Number.isFinite(raw.severity) ? Math.max(0, Math.min(4, Math.round(raw.severity))) : 0;
    const confidence = Number.isFinite(raw.confidence) ? Math.max(0, Math.min(1, Number(raw.confidence))) : 0;
    return {
      issue_type: issueType,
      subtype: subtype || null,
      severity,
      confidence,
      evidence: typeof raw.evidence === 'string' ? raw.evidence.trim() : '',
      computed_features: raw.computed_features && typeof raw.computed_features === 'object' ? raw.computed_features : {},
      geometry: raw.geometry && typeof raw.geometry === 'object' ? raw.geometry : null,
      ...(raw.uncertain === true ? { uncertain: true } : {}),
    };
  };

  const normalizeTakeaway = (raw) => {
    if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
    const source = typeof raw.source === 'string' && raw.source.trim() ? raw.source.trim() : 'mixed';
    const textRaw = typeof raw.text === 'string' ? raw.text.trim() : '';
    if (!textRaw) return null;
    const text =
      source === 'photo' && !/^from photo:/i.test(textRaw)
        ? `${lang === 'CN' ? 'From photo: ' : 'From photo: '}${textRaw}`
        : textRaw;
    return {
      source,
      issue_type: typeof raw.issue_type === 'string' && raw.issue_type.trim() ? raw.issue_type.trim() : null,
      text,
      confidence: Number.isFinite(raw.confidence) ? Math.max(0, Math.min(1, Number(raw.confidence))) : 0.5,
    };
  };

  const incomingFindings = [];
  for (const finding of Array.isArray(diagnosis.photo_findings) ? diagnosis.photo_findings : []) {
    const normalized = normalizeFinding(finding);
    if (normalized) incomingFindings.push(normalized);
  }

  const existingFindings = [];
  const existingFromPhoto = Array.isArray(base.photo_findings) ? base.photo_findings : [];
  const existingFromFindings = Array.isArray(base.findings) ? base.findings : [];
  for (const finding of [...existingFromPhoto, ...existingFromFindings]) {
    const normalized = normalizeFinding(finding);
    if (normalized) existingFindings.push(normalized);
  }

  const mergedFindings = [];
  const findingSeen = new Set();
  for (const finding of [...existingFindings, ...incomingFindings]) {
    const key = `${finding.issue_type}::${finding.subtype || ''}`;
    if (findingSeen.has(key)) continue;
    findingSeen.add(key);
    mergedFindings.push(finding);
  }

  if (mergedFindings.length) {
    base.photo_findings = mergedFindings.slice(0, 10);
    base.findings = mergedFindings.slice(0, 10);
  }

  const existingTakeaways = Array.isArray(base.takeaways) ? base.takeaways : [];
  const diagnosisTakeaways = Array.isArray(diagnosis.takeaways) ? diagnosis.takeaways : [];
  const mergedTakeaways = [];
  const takeawaySeen = new Set();

  const addTakeaway = (candidate) => {
    const normalized = normalizeTakeaway(candidate);
    if (!normalized) return;
    const key = `${normalized.source}::${normalized.text.toLowerCase()}`;
    if (takeawaySeen.has(key)) return;
    takeawaySeen.add(key);
    mergedTakeaways.push(normalized);
  };

  for (const takeaway of existingTakeaways) addTakeaway(takeaway);
  for (const takeaway of diagnosisTakeaways) addTakeaway(takeaway);

  const goals = profileSummary && Array.isArray(profileSummary.goals) ? profileSummary.goals.filter((item) => typeof item === 'string') : [];
  if (goals.length) {
    addTakeaway({
      source: 'user',
      issue_type: 'goal',
      text: lang === 'CN' ? `You mentioned your goals: ${goals.slice(0, 3).join(', ')}.` : `You mentioned your goals: ${goals.slice(0, 3).join(', ')}.`,
      confidence: 1,
    });
  }

  if (mergedTakeaways.length) base.takeaways = mergedTakeaways.slice(0, 12);
  return base;
}

function normalizePlanTakeaway(raw, { language } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  const sourceRaw = typeof raw.source === 'string' ? raw.source.trim().toLowerCase() : '';
  const source = sourceRaw === 'photo' || sourceRaw === 'user' || sourceRaw === 'mixed' ? sourceRaw : 'mixed';
  let text = typeof raw.text === 'string' ? raw.text.trim() : '';
  if (!text) return null;
  if (source === 'photo' && !/^from photo:/i.test(text)) text = `${lang === 'CN' ? 'From photo: ' : 'From photo: '}${text}`;
  if (source === 'user' && /^you reported/i.test(text)) text = text.replace(/^you reported/i, 'You mentioned');
  return {
    takeaway_id: typeof raw.takeaway_id === 'string' && raw.takeaway_id.trim() ? raw.takeaway_id.trim() : null,
    source,
    issue_type: typeof raw.issue_type === 'string' && raw.issue_type.trim() ? raw.issue_type.trim() : null,
    text,
    confidence: Number.isFinite(raw.confidence) ? Math.max(0, Math.min(1, Number(raw.confidence))) : 0.55,
    linked_finding_ids: Array.isArray(raw.linked_finding_ids)
      ? raw.linked_finding_ids.filter((item) => typeof item === 'string' && item.trim()).slice(0, 8)
      : [],
    linked_issue_types: Array.isArray(raw.linked_issue_types)
      ? raw.linked_issue_types.filter((item) => typeof item === 'string' && item.trim()).slice(0, 8)
      : [],
  };
}

function renderPlanAsStrategy({ plan, language, photoNotice } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  if (!plan || typeof plan !== 'object') return '';
  const getWhat = (step) => (step && typeof step.what === 'string' ? step.what.trim() : '');
  const am = Array.isArray(plan?.today?.am_steps) ? plan.today.am_steps.map(getWhat).filter(Boolean) : [];
  const pm = Array.isArray(plan?.today?.pm_steps) ? plan.today.pm_steps.map(getWhat).filter(Boolean) : [];
  const pause = Array.isArray(plan?.today?.pause_now) ? plan.today.pause_now.map(getWhat).filter(Boolean) : [];
  const rule = Array.isArray(plan?.next_7_days?.rules) ? plan.next_7_days.rules.filter((item) => typeof item === 'string' && item.trim()).slice(0, 2) : [];
  const lines = [];
  if (photoNotice) lines.push(photoNotice);
  lines.push(lang === 'CN' ? 'Today' : 'Today');
  lines.push(`${lang === 'CN' ? 'AM' : 'AM'}: ${am.length ? am.join(' -> ') : (lang === 'CN' ? '' : 'retake + observe')}`);
  lines.push(`${lang === 'CN' ? 'PM' : 'PM'}: ${pm.length ? pm.join(' -> ') : (lang === 'CN' ? '' : 'retake + observe')}`);
  if (pause.length) lines.push(`${lang === 'CN' ? 'Pause now' : 'Pause now'}: ${pause.join(' / ')}`);
  if (rule.length) lines.push(`${lang === 'CN' ? 'Next 7 days' : 'Next 7 days'}: ${rule.join(' | ')}`);
  const retakeDays = Number.isFinite(plan?.tracking?.retake_after_days) ? Number(plan.tracking.retake_after_days) : 7;
  lines.push(lang === 'CN' ? `Re-evaluate in ${retakeDays} days.` : `Re-evaluate in ${retakeDays} days.`);
  return lines.join('\n').slice(0, 1200);
}

function normalizePhotoFailureCodeForFallback(code) {
  const normalized = String(code || '').trim().toUpperCase();
  if (!normalized) return '';
  if (
    normalized === 'DOWNLOAD_URL_GENERATE_FAILED' ||
    normalized === 'DOWNLOAD_URL_FETCH_4XX' ||
    normalized === 'DOWNLOAD_URL_FETCH_5XX' ||
    normalized === 'DOWNLOAD_URL_TIMEOUT' ||
    normalized === 'DOWNLOAD_URL_EXPIRED' ||
    normalized === 'DOWNLOAD_URL_DNS'
  ) {
    return normalized;
  }
  return '';
}

function buildPhotoFallbackActionCard({
  language,
  qualityFail,
  failureCode,
  photosProvided,
} = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const normalizedFailure = normalizePhotoFailureCodeForFallback(failureCode);
  const reasonByCodeEn = {
    DOWNLOAD_URL_GENERATE_FAILED: "We couldn't generate a secure photo download link.",
    DOWNLOAD_URL_FETCH_4XX: "Photo access was rejected while fetching bytes (4xx).",
    DOWNLOAD_URL_FETCH_5XX: 'Photo storage returned a server error while fetching bytes (5xx).',
    DOWNLOAD_URL_TIMEOUT: 'Photo download timed out before bytes were received.',
    DOWNLOAD_URL_EXPIRED: 'The signed photo link expired before analysis could start.',
    DOWNLOAD_URL_DNS: 'Photo storage host lookup failed (DNS/network resolution).',
  };
  const reasonByCodeZh = {
    DOWNLOAD_URL_GENERATE_FAILED: '',
    DOWNLOAD_URL_FETCH_4XX: '4xx',
    DOWNLOAD_URL_FETCH_5XX: '5xx',
    DOWNLOAD_URL_TIMEOUT: '',
    DOWNLOAD_URL_EXPIRED: '',
    DOWNLOAD_URL_DNS: 'DNS/',
  };

  let primaryReason = '';
  if (qualityFail) {
    primaryReason =
      lang === 'CN'
        ? '//'
        : 'Photo quality failed (lighting/focus/coverage), so image-based analysis is unavailable for this run.';
  } else if (normalizedFailure) {
    primaryReason = lang === 'CN' ? reasonByCodeZh[normalizedFailure] || '' : reasonByCodeEn[normalizedFailure] || '';
  } else if (photosProvided === false) {
    primaryReason = lang === 'CN' ? '' : 'No photo was provided in this run, so image-based analysis is unavailable.';
  } else {
    primaryReason =
      lang === 'CN'
        ? ''
        : "We couldn't read photo bytes for this run, so image-based analysis is unavailable.";
  }

  const guardrailReason =
    lang === 'CN'
      ? '/'
      : 'To avoid misleading conclusions, this run is questionnaire/history-only.';

  const retakeGuide =
    lang === 'CN'
      ? [
          '',
          ' 3050cm 70%',
          '///',
        ]
      : [
          'Use daylight facing a window; avoid backlight and strong shadows.',
          'Keep 3050cm distance, straight-on angle, and face fills about 70% of frame.',
          'Turn off beauty filters, keep sharp focus, and remove obstructions (hair/mask/hand).',
        ];

  const meanwhilePlan =
    lang === 'CN'
      ? [
          ' 57  +  + ',
          '/',
          ' 3  1  12 ',
        ]
      : [
          'If stinging or redness appears: pause potentially irritating actives for 57 days; keep gentle cleanser + moisturizer + daytime SPF only.',
          'If skin feels oily but tight: reduce cleansing intensity/frequency and add a light moisturizer layer.',
          'If stable for 3 straight days: re-introduce only one product at 12 nights/week; stop immediately if irritation returns.',
        ];

  const ask3 =
    lang === 'CN'
      ? [
          ' 72 /',
          ' AM/PM ',
          '///',
        ]
      : [
          'Any stinging or burning in the last 72 hours, and after which routine step?',
          'What exact products are you using in AM/PM, and how often for each?',
          'Any recent environment/lifestyle shift (travel, climate, sleep, stress) affecting your skin?',
        ];

  return {
    why_i_cant_analyze: [primaryReason, guardrailReason].filter(Boolean).slice(0, 2),
    retake_guide: retakeGuide.slice(0, 3),
    meanwhile_plan: meanwhilePlan.slice(0, 3),
    ask_3_questions: ask3.slice(0, 3),
  };
}

function renderPhotoFallbackStrategy({ language, photoNotice, actionCard } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const card = actionCard && typeof actionCard === 'object' ? actionCard : null;
  if (!card) return '';
  const lines = [];
  if (photoNotice) lines.push(photoNotice);
  lines.push(lang === 'CN' ? '' : "Why I can't analyze");
  for (const item of Array.isArray(card.why_i_cant_analyze) ? card.why_i_cant_analyze.slice(0, 2) : []) lines.push(`- ${item}`);
  lines.push(lang === 'CN' ? '' : 'Retake guide');
  for (const item of Array.isArray(card.retake_guide) ? card.retake_guide.slice(0, 3) : []) lines.push(`- ${item}`);
  lines.push(lang === 'CN' ? '7 ' : 'Meanwhile plan (7 days)');
  for (const item of Array.isArray(card.meanwhile_plan) ? card.meanwhile_plan.slice(0, 3) : []) lines.push(`- ${item}`);
  lines.push(lang === 'CN' ? ' 3 ' : 'Ask-3 questions');
  for (const item of Array.isArray(card.ask_3_questions) ? card.ask_3_questions.slice(0, 3) : []) lines.push(`- ${item}`);
  return lines.join('\n').slice(0, 1200);
}

function clampGeometry01(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) return 0;
  if (numeric <= 0) return 0;
  if (numeric >= 1) return 1;
  return numeric;
}

function sanitizeBBoxNorm(rawBBox) {
  if (!rawBBox || typeof rawBBox !== 'object') return { ok: false, clipped: false, bbox: null };
  const raw = {
    x0: Number(rawBBox.x0),
    y0: Number(rawBBox.y0),
    x1: Number(rawBBox.x1),
    y1: Number(rawBBox.y1),
  };
  if (!Number.isFinite(raw.x0) || !Number.isFinite(raw.y0) || !Number.isFinite(raw.x1) || !Number.isFinite(raw.y1)) {
    return { ok: false, clipped: false, bbox: null };
  }

  const clamped = {
    x0: clampGeometry01(raw.x0),
    y0: clampGeometry01(raw.y0),
    x1: clampGeometry01(raw.x1),
    y1: clampGeometry01(raw.y1),
  };
  let clipped =
    clamped.x0 !== raw.x0 ||
    clamped.y0 !== raw.y0 ||
    clamped.x1 !== raw.x1 ||
    clamped.y1 !== raw.y1;

  const ordered = {
    x0: Math.min(clamped.x0, clamped.x1),
    y0: Math.min(clamped.y0, clamped.y1),
    x1: Math.max(clamped.x0, clamped.x1),
    y1: Math.max(clamped.y0, clamped.y1),
  };
  if (ordered.x0 !== clamped.x0 || ordered.y0 !== clamped.y0 || ordered.x1 !== clamped.x1 || ordered.y1 !== clamped.y1) {
    clipped = true;
  }

  if (ordered.x1 - ordered.x0 <= 0.001 || ordered.y1 - ordered.y0 <= 0.001) {
    return { ok: false, clipped: true, bbox: null };
  }
  return { ok: true, clipped, bbox: ordered };
}

function sanitizeGridGeometry(rawGeometry) {
  if (!rawGeometry || typeof rawGeometry !== 'object') return { ok: false, clipped: false, grid: null };
  const rawRows = Number(rawGeometry.rows);
  const rawCols = Number(rawGeometry.cols);
  const rawValues = Array.isArray(rawGeometry.values) ? rawGeometry.values : null;
  if (!Number.isFinite(rawRows) || !Number.isFinite(rawCols) || !rawValues) {
    return { ok: false, clipped: false, grid: null };
  }

  const rows = Math.max(1, Math.min(64, Math.trunc(rawRows)));
  const cols = Math.max(1, Math.min(64, Math.trunc(rawCols)));
  const expected = rows * cols;
  let clipped = rows !== rawRows || cols !== rawCols;
  if (rawValues.length < expected) {
    return { ok: false, clipped: true, grid: null };
  }

  const values = rawValues.slice(0, expected).map((item) => {
    const numeric = Number(item);
    if (!Number.isFinite(numeric)) {
      clipped = true;
      return 0;
    }
    const normalized = clampGeometry01(numeric);
    if (normalized !== numeric) clipped = true;
    return normalized;
  });
  return {
    ok: true,
    clipped,
    grid: {
      type: 'grid',
      rows,
      cols,
      values,
    },
  };
}

function sanitizeFindingGeometry(rawGeometry) {
  if (!rawGeometry || typeof rawGeometry !== 'object') {
    return { geometry: null, checked_n: 0, dropped_n: 0, clipped_n: 0 };
  }

  let checked = 0;
  let dropped = 0;
  let clipped = 0;
  const geometry = {};
  let hasGeometry = false;

  if (rawGeometry.bbox_norm && typeof rawGeometry.bbox_norm === 'object') {
    checked += 1;
    const bbox = sanitizeBBoxNorm(rawGeometry.bbox_norm);
    if (bbox.ok && bbox.bbox) {
      geometry.bbox_norm = bbox.bbox;
      hasGeometry = true;
    } else {
      dropped += 1;
    }
    if (bbox.clipped) clipped += 1;
  }

  if (
    rawGeometry.type === 'grid' ||
    (Number.isFinite(Number(rawGeometry.rows)) && Number.isFinite(Number(rawGeometry.cols)) && Array.isArray(rawGeometry.values))
  ) {
    checked += 1;
    const grid = sanitizeGridGeometry(rawGeometry);
    if (grid.ok && grid.grid) {
      geometry.type = 'grid';
      geometry.rows = grid.grid.rows;
      geometry.cols = grid.grid.cols;
      geometry.values = grid.grid.values;
      hasGeometry = true;
    } else {
      dropped += 1;
    }
    if (grid.clipped) clipped += 1;
  }

  return {
    geometry: hasGeometry ? geometry : null,
    checked_n: checked,
    dropped_n: dropped,
    clipped_n: clipped,
  };
}

function mergeGeometrySanitizerByIssue(target, issueType, stats) {
  const issue = String(issueType || 'unknown').trim().toLowerCase() || 'unknown';
  if (!target[issue]) {
    target[issue] = { checked_n: 0, dropped_n: 0, clipped_n: 0, fixed_n: 0 };
  }
  target[issue].checked_n += Number(stats.checked_n || 0);
  target[issue].dropped_n += Number(stats.dropped_n || 0);
  target[issue].clipped_n += Number(stats.clipped_n || 0);
  target[issue].fixed_n += Number(stats.fixed_n != null ? stats.fixed_n : stats.clipped_n || 0);
}

function buildExecutablePlanForAnalysis({
  analysis,
  language,
  usedPhotos,
  photoQuality,
  profileSummary,
  photoNoticeOverride,
  photoFailureCode,
  photosProvided,
} = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const base = analysis && typeof analysis === 'object' && !Array.isArray(analysis) ? { ...analysis } : null;
  if (!base) return analysis;

  const quality = photoQuality && typeof photoQuality === 'object' ? photoQuality : { grade: 'unknown', reasons: [] };
  const qualityFail = String(quality.grade || '').trim().toLowerCase() === 'fail';
  const fallbackMode = qualityFail || !usedPhotos;
  const defaultPhotoNotice = qualityFail
    ? lang === 'CN'
      ? '/'
      : 'Photo quality failed, so this run uses questionnaire/history only.'
    : usedPhotos
      ? null
      : 'Based on your answers only (photo not analyzed).';
  const overrideNotice = typeof photoNoticeOverride === 'string' ? photoNoticeOverride.trim() : '';
  const photoNotice = overrideNotice ? [overrideNotice, defaultPhotoNotice].filter(Boolean).join(' ') : defaultPhotoNotice;

  const findingsInput = usedPhotos && !qualityFail
    ? Array.isArray(base.photo_findings)
      ? base.photo_findings
      : Array.isArray(base.findings)
        ? base.findings
        : []
    : [];
  const geometrySanitizer = {
    checked_n: 0,
    dropped_n: 0,
    clipped_n: 0,
    fixed_n: 0,
    by_issue: {},
  };
  const photoFindings = [];
  const issueToFindingIds = new Map();
  for (let i = 0; i < findingsInput.length; i += 1) {
    const finding = findingsInput[i];
    if (!finding || typeof finding !== 'object') continue;
    const issueType = typeof finding.issue_type === 'string' ? finding.issue_type.trim() : '';
    if (!issueType) continue;
    const findingIdRaw = typeof finding.finding_id === 'string' && finding.finding_id.trim() ? finding.finding_id.trim() : `pf_${issueType}_${i + 1}`;
    const geometryStats = sanitizeFindingGeometry(finding.geometry);
    geometrySanitizer.checked_n += Number(geometryStats.checked_n || 0);
    geometrySanitizer.dropped_n += Number(geometryStats.dropped_n || 0);
    geometrySanitizer.clipped_n += Number(geometryStats.clipped_n || 0);
    geometrySanitizer.fixed_n += Number(geometryStats.clipped_n || 0);
    if (Number(geometryStats.checked_n || 0) > 0) {
      mergeGeometrySanitizerByIssue(geometrySanitizer.by_issue, issueType, {
        checked_n: geometryStats.checked_n,
        dropped_n: geometryStats.dropped_n,
        clipped_n: geometryStats.clipped_n,
        fixed_n: geometryStats.clipped_n,
      });
    }
    const normalizedFinding = {
      finding_id: findingIdRaw,
      issue_type: issueType,
      subtype: typeof finding.subtype === 'string' && finding.subtype.trim() ? finding.subtype.trim() : null,
      severity: Number.isFinite(finding.severity) ? Math.max(0, Math.min(4, Math.round(finding.severity))) : 0,
      confidence: Number.isFinite(finding.confidence) ? Math.max(0, Math.min(1, Number(finding.confidence))) : 0,
      evidence: typeof finding.evidence === 'string' ? finding.evidence.trim() : '',
      computed_features: finding.computed_features && typeof finding.computed_features === 'object' ? finding.computed_features : {},
      geometry: geometryStats.geometry,
      ...(finding.uncertain === true ? { uncertain: true } : {}),
    };
    photoFindings.push(normalizedFinding);
    const list = issueToFindingIds.get(issueType) || [];
    list.push(findingIdRaw);
    issueToFindingIds.set(issueType, list);
  }
  base.photo_findings = photoFindings;
  base.findings = photoFindings;
  if (usedPhotos && !qualityFail && photoFindings.length) {
    const evidenceRegions = [];
    for (const finding of photoFindings) {
      const geometry = finding && finding.geometry && typeof finding.geometry === 'object' ? finding.geometry : null;
      if (!geometry) continue;
      if (geometry.bbox_norm && typeof geometry.bbox_norm === 'object') {
        evidenceRegions.push({
          concern_type: finding.issue_type,
          severity: finding.severity,
          confidence: finding.confidence,
          region: { kind: 'bbox', bbox_norm: geometry.bbox_norm },
          evidence_text: finding.evidence || '',
        });
      }
      if (
        geometry.type === 'grid' &&
        Number.isFinite(Number(geometry.rows)) &&
        Number.isFinite(Number(geometry.cols)) &&
        Array.isArray(geometry.values)
      ) {
        const rows = Math.max(1, Math.min(64, Math.trunc(Number(geometry.rows))));
        const cols = Math.max(1, Math.min(64, Math.trunc(Number(geometry.cols))));
        const values = geometry.values
          .slice(0, rows * cols)
          .map((value) => (Number.isFinite(Number(value)) ? Math.max(0, Math.min(1, Number(value))) : 0));
        if (values.length === rows * cols) {
          evidenceRegions.push({
            concern_type: finding.issue_type,
            severity: finding.severity,
            confidence: finding.confidence,
            region: { kind: 'heatmap', rows, cols, values },
            evidence_text: finding.evidence || '',
          });
        }
      }
    }
    if (evidenceRegions.length) base.evidence_regions = evidenceRegions.slice(0, 48);
    else delete base.evidence_regions;
  } else {
    delete base.evidence_regions;
  }

  const takeawaysInput = Array.isArray(base.takeaways) ? base.takeaways : [];
  const takeaways = [];
  const seenTakeawayText = new Set();
  for (const item of takeawaysInput) {
    const normalized = normalizePlanTakeaway(item, { language: lang });
    if (!normalized) continue;
    if (fallbackMode && normalized.source === 'photo') continue;
    if (normalized.source === 'photo' && normalized.linked_finding_ids.length === 0 && normalized.issue_type) {
      normalized.linked_finding_ids = (issueToFindingIds.get(normalized.issue_type) || []).slice(0, 8);
    }
    if (normalized.source === 'photo' && normalized.linked_issue_types.length === 0 && normalized.issue_type) {
      normalized.linked_issue_types = [normalized.issue_type];
    }
    const key = `${normalized.source}:${normalized.text.toLowerCase()}`;
    if (seenTakeawayText.has(key)) continue;
    seenTakeawayText.add(key);
    takeaways.push(normalized);
  }

  if (!fallbackMode) {
    const goals = profileSummary && Array.isArray(profileSummary.goals) ? profileSummary.goals.filter((item) => typeof item === 'string' && item.trim()) : [];
    if (goals.length) {
      const text = `You mentioned your goals: ${goals.slice(0, 3).join(', ')}.`;
      const key = `user:${text.toLowerCase()}`;
      if (!seenTakeawayText.has(key)) {
        takeaways.push({
          takeaway_id: 'tw_user_goals_plan',
          source: 'user',
          issue_type: 'goal',
          text,
          confidence: 1,
          linked_finding_ids: [],
          linked_issue_types: ['goal'],
        });
        seenTakeawayText.add(key);
      }
    }
    if (profileSummary && profileSummary.barrierStatus === 'impaired') {
      const text = 'You mentioned stinging/redness and barrier stress recently.';
      const key = `user:${text.toLowerCase()}`;
      if (!seenTakeawayText.has(key)) {
        takeaways.push({
          takeaway_id: 'tw_user_barrier_stress',
          source: 'user',
          issue_type: 'barrier',
          text,
          confidence: 0.9,
          linked_finding_ids: [],
          linked_issue_types: ['barrier'],
        });
        seenTakeawayText.add(key);
      }
    }
  }

  if (usedPhotos && !qualityFail && photoFindings.length) {
    for (const finding of photoFindings) {
      const alreadyLinked = takeaways.some((item) => item.source === 'photo' && item.linked_finding_ids.includes(finding.finding_id));
      if (alreadyLinked) continue;
      takeaways.push({
        takeaway_id: `tw_photo_${finding.finding_id}`,
        source: 'photo',
        issue_type: finding.issue_type,
        text: `From photo: ${finding.issue_type} signal observed in the highlighted area.`,
        confidence: finding.confidence,
        linked_finding_ids: [finding.finding_id],
        linked_issue_types: [finding.issue_type],
      });
    }
  }

  const takeawaysByIssue = new Map();
  for (const item of takeaways) {
    if (!item.issue_type) continue;
    const list = takeawaysByIssue.get(item.issue_type) || [];
    list.push(item.takeaway_id);
    takeawaysByIssue.set(item.issue_type, list);
  }

  const makeStep = ({ what, why, whenToStop, priority, linkedIssueTypes = [], linkedFindingIds = [] } = {}) => ({
    what: String(what || '').trim(),
    why: String(why || '').trim(),
    when_to_stop: String(whenToStop || '').trim(),
    priority: priority === 'P0' || priority === 'P1' || priority === 'P2' ? priority : 'P1',
    linked_issue_types: linkedIssueTypes.filter((item) => typeof item === 'string' && item.trim()).slice(0, 6),
    linked_finding_ids: linkedFindingIds.filter((item) => typeof item === 'string' && item.trim()).slice(0, 8),
    linked_takeaway_ids: linkedIssueTypes
      .flatMap((issueType) => (takeawaysByIssue.get(issueType) || []).filter((item) => typeof item === 'string' && item.trim()))
      .slice(0, 8),
  });

  const requiredCheckboxes = [
    { metric: 'redness_stinging', label: 'redness/stinging', options: ['', '', ''] },
    { metric: 'new_breakouts', label: 'new breakouts', options: ['', '', ''] },
    { metric: 'shine_oil_control', label: 'shine/oil control', options: ['', '', ''] },
  ];

  let plan = null;
  let fallbackActionCard = null;
  if (fallbackMode) {
    fallbackActionCard = buildPhotoFallbackActionCard({
      language: lang,
      qualityFail,
      failureCode: photoFailureCode,
      photosProvided,
    });
    plan = {
      today: {
        am_steps: [],
        pm_steps: [],
        pause_now: [
          makeStep({
            what:
              lang === 'CN'
                ? ''
                : 'Retake one photo using the retake guide (daylight, unobstructed, no filter).',
            why: (fallbackActionCard.why_i_cant_analyze && fallbackActionCard.why_i_cant_analyze[0]) || '',
            whenToStop:
              lang === 'CN'
                ? ' 2 '
                : 'If QC still fails after 2 attempts, continue with questionnaire flow and retry later.',
            priority: 'P0',
            linkedIssueTypes: ['quality'],
            linkedFindingIds: [],
          }),
        ],
      },
      next_7_days: {
        rules:
          lang === 'CN'
            ? [' 7 ', ' QC ']
            : ['Use a conservative 7-day temporary plan while photo evidence is unavailable.', 'Retake as soon as possible and resume photo analysis after QC passes.'],
        steps: [
          makeStep({
            what: fallbackActionCard.meanwhile_plan[0] || '',
            why:
              lang === 'CN'
                ? ''
                : 'Control irritation risk first while evidence is incomplete.',
            whenToStop:
              lang === 'CN'
                ? '/ 3 '
                : 'Move to next step after 3 consecutive days of stable or improved comfort.',
            priority: 'P0',
            linkedIssueTypes: ['fallback'],
            linkedFindingIds: [],
          }),
          makeStep({
            what: fallbackActionCard.meanwhile_plan[1] || '',
            why:
              lang === 'CN'
                ? ''
                : 'Re-balance cleansing and hydration to reduce rebound fluctuations.',
            whenToStop:
              lang === 'CN'
                ? '/'
                : 'If tightness/redness worsens, simplify further and pause new products.',
            priority: 'P1',
            linkedIssueTypes: ['fallback'],
            linkedFindingIds: [],
          }),
          makeStep({
            what: fallbackActionCard.meanwhile_plan[2] || '',
            why:
              lang === 'CN'
                ? ''
                : 'Low-frequency reintroduction helps verify tolerance without stacking changes.',
            whenToStop:
              lang === 'CN'
                ? ''
                : 'If persistent discomfort returns, revert to basic 3-step care and wait for retake results.',
            priority: 'P1',
            linkedIssueTypes: ['fallback'],
            linkedFindingIds: [],
          }),
        ],
      },
      after_calm: {
        entry_criteria:
          lang === 'CN'
            ? [' QC  pass/degraded', '']
            : ['Photo QC reaches pass/degraded.', 'Same lighting and angle are reproducible.'],
        steps: [],
      },
      tracking: {
        checkboxes: requiredCheckboxes,
        retake_prompt:
          lang === 'CN'
            ? '7 /'
            : 'Retake within 7 days with the same lighting/angle and follow the retake guide.',
        retake_after_days: 7,
      },
    };
  } else {
    const rednessFindingIds = issueToFindingIds.get('redness') || [];
    const shineFindingIds = issueToFindingIds.get('shine') || [];
    const textureFindingIds = issueToFindingIds.get('texture') || [];
    const toneFindingIds = issueToFindingIds.get('tone') || [];
    const hasRedness = rednessFindingIds.length > 0;
    const hasShine = shineFindingIds.length > 0;
    const hasTexture = textureFindingIds.length > 0;
    const hasTone = toneFindingIds.length > 0;

    const amSteps = [
      makeStep({
        what: 'Use gentle cleanser, then moisturizer.',
        why: hasRedness ? `Linked evidence: ${rednessFindingIds.join(', ')} (photo redness) and barrier-related takeaways.` : 'Linked evidence: user-input sensitivity/barrier context.',
        whenToStop: 'Stop if burning >10 minutes or persistent stinging.',
        priority: 'P0',
        linkedIssueTypes: hasRedness ? ['redness'] : ['barrier'],
        linkedFindingIds: rednessFindingIds,
      }),
      makeStep({
        what: 'Apply broad-spectrum SPF as last AM step.',
        why: hasTone ? `Linked evidence: ${toneFindingIds.join(', ')} (uneven tone proxy).` : 'Linked evidence: prevention baseline and user goals.',
        whenToStop: 'Stop only if rash or swelling appears.',
        priority: 'P0',
        linkedIssueTypes: hasTone ? ['tone'] : ['goal'],
        linkedFindingIds: toneFindingIds,
      }),
    ];

    const pmSteps = [
      makeStep({
        what: 'Cleanse gently and moisturize; keep PM routine simple for 7 days.',
        why: hasRedness ? `Linked evidence: ${rednessFindingIds.join(', ')} indicates irritation risk.` : 'Linked evidence: user-reported sensitivity context.',
        whenToStop: 'Stop and simplify further if redness/stinging increases for 2 consecutive days.',
        priority: 'P0',
        linkedIssueTypes: hasRedness ? ['redness'] : ['barrier'],
        linkedFindingIds: rednessFindingIds,
      }),
    ];

    if (hasShine || hasTexture) {
      pmSteps.push(
        makeStep({
          what: 'If skin stays calm for 3 nights, add one low-frequency balancing step (2 nights/week).',
          why: `Linked evidence: ${(hasTexture ? textureFindingIds : shineFindingIds).join(', ')} supports oil/texture control.`,
          whenToStop: 'Stop if peeling, burning, or new diffuse redness appears.',
          priority: 'P1',
          linkedIssueTypes: hasTexture ? ['texture'] : ['shine'],
          linkedFindingIds: hasTexture ? textureFindingIds : shineFindingIds,
        }),
      );
    }

    const pauseNow = [];
    if (hasRedness) {
      pauseNow.push(
        makeStep({
          what: 'Pause layering multiple strong actives on the same night.',
          why: `Linked evidence: ${rednessFindingIds.join(', ')} and photo-linked irritation takeaways.`,
          whenToStop: 'Resume only after 3 consecutive days with redness/stinging not increasing.',
          priority: 'P0',
          linkedIssueTypes: ['redness'],
          linkedFindingIds: rednessFindingIds,
        }),
      );
    }

    const nextSteps = [
      makeStep({
        what: 'Keep one-variable-at-a-time changes across the next 7 days.',
        why: 'Linked evidence: mixed uncertainty from photo + user signals requires controlled iteration.',
        whenToStop: 'Stop adding new steps if any metric trends upward for 2 days.',
        priority: 'P0',
        linkedIssueTypes: ['mixed'],
        linkedFindingIds: [...rednessFindingIds, ...shineFindingIds, ...textureFindingIds, ...toneFindingIds].slice(0, 8),
      }),
    ];
    if (hasShine) {
      nextSteps.push(
        makeStep({
          what: 'Track midday shine and reduce occlusive layering if shine worsens.',
          why: `Linked evidence: ${shineFindingIds.join(', ')} (shine/specular proxy).`,
          whenToStop: 'Stop reduction if tightness or flaking increases.',
          priority: 'P1',
          linkedIssueTypes: ['shine'],
          linkedFindingIds: shineFindingIds,
        }),
      );
    }

    const afterCalmSteps = [];
    if (hasTexture || hasTone) {
      afterCalmSteps.push(
        makeStep({
          what: 'After skin is calm, add one targeted step and reassess after 7 days.',
          why: `Linked evidence: ${[...textureFindingIds, ...toneFindingIds].join(', ')} and corresponding takeaways.`,
          whenToStop: 'Stop targeted step if irritation rises or breakouts increase.',
          priority: 'P2',
          linkedIssueTypes: [...(hasTexture ? ['texture'] : []), ...(hasTone ? ['tone'] : [])],
          linkedFindingIds: [...textureFindingIds, ...toneFindingIds],
        }),
      );
    }

    plan = {
      today: {
        am_steps: amSteps,
        pm_steps: pmSteps,
        pause_now: pauseNow,
      },
      next_7_days: {
        rules: [
          'Keep routine changes incremental (one new variable at a time).',
          usedPhotos ? 'Use current photo findings as baseline and compare after retake.' : 'Use symptom trend checkboxes as baseline until photo is provided.',
        ],
        steps: nextSteps,
      },
      after_calm: {
        entry_criteria: ['redness/stinging trend is  or stable for 3 days', 'no sudden breakout spike', 'routine feels tolerable daily'],
        steps: afterCalmSteps,
      },
      tracking: {
        checkboxes: requiredCheckboxes,
        retake_prompt: 'Retake in 7 days with the same lighting, angle, and camera distance; follow QC guidance before submit.',
        retake_after_days: 7,
      },
    };
  }

  base.plan = plan;
  if (fallbackMode) {
    base.photo_findings = [];
    base.findings = [];
    base.takeaways = [];
    base.features = (fallbackActionCard.why_i_cant_analyze || []).map((text, index) => ({
      observation: text,
      confidence: index === 0 ? 'pretty_sure' : 'somewhat_sure',
    }));
    base.next_action_card = fallbackActionCard;
    base.strategy = renderPhotoFallbackStrategy({ language: lang, photoNotice, actionCard: fallbackActionCard });
  } else {
    base.takeaways = takeaways.slice(0, 14);
    delete base.next_action_card;
    base.strategy = renderPlanAsStrategy({ plan, language: lang, photoNotice });
  }
  if (photoNotice) base.photo_notice = photoNotice;
  else delete base.photo_notice;
  if (fallbackMode && Array.isArray(fallbackActionCard.ask_3_questions)) {
    base.ask_3_questions = fallbackActionCard.ask_3_questions.slice(0, 3);
  } else {
    delete base.ask_3_questions;
  }
  if (fallbackMode && Array.isArray(fallbackActionCard.retake_guide)) {
    base.retake_guide = fallbackActionCard.retake_guide.slice(0, 3);
  } else {
    delete base.retake_guide;
  }
  const geometryByIssue = {};
  for (const issueType of Object.keys(geometrySanitizer.by_issue).sort((a, b) => a.localeCompare(b))) {
    const raw = geometrySanitizer.by_issue[issueType] || {};
    geometryByIssue[issueType] = {
      checked_n: Number(raw.checked_n || 0),
      dropped_n: Number(raw.dropped_n || 0),
      clipped_n: Number(raw.clipped_n || 0),
      fixed_n: Number(raw.fixed_n || 0),
    };
  }
  base.__geometry_sanitizer = {
    checked_n: Number(geometrySanitizer.checked_n || 0),
    dropped_n: Number(geometrySanitizer.dropped_n || 0),
    clipped_n: Number(geometrySanitizer.clipped_n || 0),
    fixed_n: Number(geometrySanitizer.fixed_n || 0),
    by_issue: geometryByIssue,
  };
  return base;
}

function buildRuleBasedSkinAnalysis({ profile, recentLogs, language }) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const p = profile || {};
  const goals = Array.isArray(p.goals) ? p.goals : [];
  const routineRaw = p.currentRoutine;
  const routineText =
    typeof routineRaw === 'string'
      ? routineRaw
      : routineRaw && typeof routineRaw === 'object'
        ? JSON.stringify(routineRaw)
        : '';
  const routineTextLower = String(routineText || '').toLowerCase();

  const hasStingingSignal =
    /\bsting\b|\bstinging\b|\bburn\b|\bburning\b|\birritat|\bredness\b|\bflak|\bpeel/.test(routineTextLower);

  const features = [];
  if (p.barrierStatus === 'impaired') {
    features.push({
      observation:
        lang === 'CN'
          ? '/ '
          : 'You mentioned recent barrier stress (stinging/redness) -> prioritize calming + repair first.',
      confidence: 'pretty_sure',
    });
  } else if (hasStingingSignal) {
    features.push({
      observation:
        lang === 'CN'
          ? '//  '
          : 'You mentioned stinging/redness/flaking signals  treat this as barrier stress and simplify first.',
      confidence: 'somewhat_sure',
    });
  }
  if (p.skinType === 'oily' || p.skinType === 'combination') {
    features.push({
      observation:
        lang === 'CN'
          ? '/'
          : 'Oily/combination skin is more clog-prone; avoid over-cleansing (oiliness can still be dehydration).',
      confidence: 'somewhat_sure',
    });
  }
  if (p.sensitivity === 'high') {
    features.push({
      observation:
        lang === 'CN'
          ? '//'
          : 'If sensitivity is high, introduce actives slowly (frequency/strength/stacking should be conservative).',
      confidence: 'pretty_sure',
    });
  }
  const wantsPores = goals.includes('pores');
  const wantsAcne = goals.includes('acne');
  if (wantsPores || wantsAcne) {
    const targetText =
      wantsPores && wantsAcne
        ? lang === 'CN'
          ? '/'
          : 'pores + acne'
        : wantsPores
          ? lang === 'CN'
            ? '/'
            : 'pores/texture'
          : lang === 'CN'
            ? ''
            : 'acne';
    features.push({
      observation:
        lang === 'CN'
          ? `${targetText}   + `
          : `Your goals include ${targetText}  gentle exfoliation + oil control may help later, if tolerated.`,
      confidence: 'somewhat_sure',
    });
  }

  // Very light routine heuristic: only surface broad safety signals (no brand recommendations).
  if (routineTextLower) {
    const hasRetinoid = /\bretinol\b|\badapalene\b|\btretinoin\b|\bretinoid\b/.test(routineTextLower);
    const hasExfoliatingAcid =
      /\bglycolic\b|\blactic\b|\bmandelic\b|\bsalicylic\b|\bbha\b|\baha\b/.test(routineTextLower);
    const hasBpo = /\bbenzoyl\b|\bbpo\b/.test(routineTextLower);
    const hasHighStrengthVitC = /\bascorbic\b|\bl-ascorbic\b|\bvitamin c\b|\bhigh[- ]?strength\b/.test(routineTextLower);
    if (hasRetinoid || hasExfoliatingAcid || hasBpo) {
      const actives = [
        ...(hasRetinoid ? [lang === 'CN' ? 'A' : 'retinoid'] : []),
        ...(hasExfoliatingAcid ? [lang === 'CN' ? '' : 'acids'] : []),
        ...(hasBpo ? [lang === 'CN' ? '(BPO)' : 'benzoyl peroxide (BPO)'] : []),
      ];
      features.push({
        observation:
          lang === 'CN'
            ? ` routine  ${actives.join(' / ')}  `
            : `Your current routine includes ${actives.join(' / ')}  avoid stacking and start low-frequency to reduce irritation risk.`,
        confidence: 'somewhat_sure',
      });
    }

    if (hasRetinoid && hasStingingSignal) {
      features.push({
        observation:
          lang === 'CN'
            ? 'A  //'
            : 'Stinging after a retinoid often means frequency/stacking is too aggressive; pause a few nights and restart lower.',
        confidence: 'somewhat_sure',
      });
    }

    if (hasExfoliatingAcid && hasHighStrengthVitC && (p.barrierStatus === 'impaired' || hasStingingSignal)) {
      features.push({
        observation:
          lang === 'CN'
            ? ' +  VC   '
            : 'Acids + high-strength vitamin C can be harsh during barrier stress  separate days or pause one active.',
        confidence: 'somewhat_sure',
      });
    }
  }

  const latest = Array.isArray(recentLogs) && recentLogs[0] ? recentLogs[0] : null;
  if (latest && (typeof latest.redness === 'number' || typeof latest.acne === 'number' || typeof latest.hydration === 'number')) {
    const redness = typeof latest.redness === 'number' ? latest.redness : null;
    const acne = typeof latest.acne === 'number' ? latest.acne : null;
    const hydration = typeof latest.hydration === 'number' ? latest.hydration : null;
    const parts = [];
    if (redness != null) parts.push(lang === 'CN' ? ` ${redness}/5` : `redness ${redness}/5`);
    if (acne != null) parts.push(lang === 'CN' ? ` ${acne}/5` : `acne ${acne}/5`);
    if (hydration != null) parts.push(lang === 'CN' ? ` ${hydration}/5` : `hydration ${hydration}/5`);
    if (parts.length) {
      features.push({
        observation:
          lang === 'CN'
            ? `${parts.join('  ')}`
            : `Latest check-in: ${parts.join('  ')} (Ill tailor advice to this trend).`,
        confidence: 'pretty_sure',
      });
    }
  }

  const goalText = goals.map((g) => String(g || '').trim().toLowerCase()).filter(Boolean);
  const wantsPoresOrAcne = goalText.includes('pores') || goalText.includes('acne');
  const wantsWrinkles = goalText.includes('wrinkles') || goalText.includes('anti-aging') || goalText.includes('aging');

  const plan = [];
  if (lang === 'CN') {
    plan.push(' +  +  SPF');
    plan.push(
      p.barrierStatus === 'impaired' || hasStingingSignal
        ? '/ 57 / VC/A'
        : ' 1  12  72 '
    );
    plan.push(
      wantsPoresOrAcne
        ? '/ 2 A'
        : wantsWrinkles
          ? '/ SPF + A'
          : ' 34  AM/PM '
    );
  } else {
    plan.push('Keep it minimal: gentle cleanser + moisturizer + daytime SPF.');
    plan.push(
      p.barrierStatus === 'impaired' || hasStingingSignal
        ? 'If stinging/redness: pause strong actives for 57 days (acids/high-strength vitamin C/retinoids) and focus on repair.'
        : 'Introduce only ONE active at a time: start 12/week and watch the 72h response.'
    );
    plan.push(
      wantsPoresOrAcne
        ? 'For pores/texture: wait until calm, then start 2/week; avoid stacking with a retinoid on the same night.'
        : wantsWrinkles
          ? 'For fine lines: prioritize SPF + hydration; consider retinoid only after skin feels stable.'
          : 'If you want, I can draft a minimal 34 step AM/PM framework with minimal new purchases.'
    );
  }

  const question =
    lang === 'CN'
      ? /\bretinol\b|\badapalene\b|\btretinoin\b|\bretinoid\b/.test(routineTextLower)
        ? 'A/VC'
        : ''
      : /\bretinol\b|\badapalene\b|\btretinoin\b|\bretinoid\b/.test(routineTextLower)
        ? 'How many nights/week are you using your retinoid, and are you stacking it with acids/vitamin C?'
        : 'Any stinging or redness recently?';

  const strategy = `${lang === 'CN' ? ' 7 ' : 'Next 7 days:'}\n1) ${plan[0]}\n2) ${plan[1]}\n3) ${plan[2]}\n\n${question}`;

  return {
    features: features.slice(0, 6),
    strategy: strategy.slice(0, 1200),
    needs_risk_check: false,
  };
}

function buildLowConfidenceBaselineSkinAnalysis({ profile, language }) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const p = profile || {};
  const goals = Array.isArray(p.goals) ? p.goals : [];

  const features = [];
  if (p.barrierStatus === 'impaired') {
    features.push({
      observation:
        lang === 'CN'
          ? '  '
          : 'You may have a stressed barrier  prioritize calming + repair first.',
      confidence: 'somewhat_sure',
    });
  }
  if (p.skinType) {
    features.push({
      observation:
        lang === 'CN'
          ? ` ${String(p.skinType)}  `
          : `You mentioned ${String(p.skinType)} skin -> Ill start with low-risk baseline guidance.`,
      confidence: 'somewhat_sure',
    });
  }
  if (goals.length) {
    features.push({
      observation:
        lang === 'CN'
          ? ` ${goals.slice(0, 2).join(' / ')}  `
          : `Your goals include ${goals.slice(0, 2).join(' / ')}  but without more inputs I can only give directional guidance.`,
      confidence: 'not_sure',
    });
  }

  const strategy =
    lang === 'CN'
      ? '/ 7 \n1)  +  +  SPF\n2) // VC/\n3)  12  72 \n\n AM/PM ///SPF'
      : "I don't have your current products/steps yet, so this is a low-confidence baseline:\n1) Keep it minimal: gentle cleanser + moisturizer + daytime SPF.\n2) If stinging/redness: pause strong actives (acids/high-strength vitamin C/retinoids) and focus on repair.\n3) Any new active: start 12/week and watch the 72h response.\n\nTo personalize this safely: please share your current AM/PM products (cleanser/actives/moisturizer/SPF, names or links). If you'd like, you can also add a daylight selfie (optional).";

  return {
    features: features.slice(0, 6),
    strategy: strategy.slice(0, 1200),
    needs_risk_check: false,
  };
}

function buildRetakeSkinAnalysis({ language, photoQuality } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const reasonsRaw = photoQuality && Array.isArray(photoQuality.reasons) ? photoQuality.reasons : [];
  const failedHint = reasonsRaw.includes('qc_failed');

  const features = [
    {
      observation:
        lang === 'CN'
          ? `${failedHint ? '' : ''}`
          : `This photo ${failedHint ? "didn't pass" : 'is too low-quality'}, so I wont make skin conclusions from it (to avoid wrong guesses).`,
      confidence: 'pretty_sure',
    },
    {
      observation:
        lang === 'CN'
          ? '//// 3050cm'
          : 'Retake tips: daylight, straight-on, no obstructions (hair/mask), no beauty filters, sharp focus, ~3050cm distance.',
      confidence: 'pretty_sure',
    },
  ];

  const strategy =
    lang === 'CN'
      ? '\n1) \n2) A//VC\n3)  AM/PM /\n\n//'
      : "To keep this safe and accurate:\n1) Retake a daylight photo using the tips above.\n2) Avoid stacking multiple strong actives on the same night (retinoid/acids/high-strength vitamin C).\n3) If you want, share your current AM/PM products and active frequency and Ill draft a low-irritation temporary plan.\n\nAny stinging/redness/flaking recently?";

  return {
    features: features.slice(0, 6),
    strategy: strategy.slice(0, 1200),
    needs_risk_check: false,
  };
}

function confidenceLevelFromScoreV1(score) {
  const n = Number(score);
  if (!Number.isFinite(n)) return 'low';
  if (n < LOW_CONFIDENCE_THRESHOLD) return 'low';
  if (n <= 0.75) return 'medium';
  return 'high';
}

function normalizeArtifactSourceMix(sources) {
  const out = [];
  const seen = new Set();
  for (const raw of Array.isArray(sources) ? sources : []) {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) continue;
    if (seen.has(token)) continue;
    seen.add(token);
    out.push(token);
    if (out.length >= 12) break;
  }
  return out;
}

function buildArtifactConfidence(score, rationale) {
  const n = Number(score);
  const safe = Number.isFinite(n) ? Math.max(0, Math.min(1, n)) : 0;
  return {
    score: safe,
    level: confidenceLevelFromScoreV1(safe),
    rationale: Array.from(
      new Set(
        (Array.isArray(rationale) ? rationale : [])
          .map((item) => String(item || '').trim())
          .filter(Boolean),
      ),
    ).slice(0, 8),
  };
}

function buildProfileEvidence(fieldKey) {
  return [
    {
      source: 'profile',
      supports: [fieldKey],
      ref: { type: 'profile_field', id: fieldKey },
      reliabilityWeight: 0.75,
    },
  ];
}

function buildArtifactValueNode({ value, confidence, fieldKey } = {}) {
  const v = typeof value === 'string' ? value.trim() : '';
  if (!v) return null;
  return {
    value: v,
    confidence: buildArtifactConfidence(confidence, [`profile_${fieldKey}`]),
    evidence: buildProfileEvidence(fieldKey),
  };
}

function buildArtifactGoalsNode(goals, confidence = 0.7) {
  const values = (Array.isArray(goals) ? goals : [])
    .map((item) => String(item || '').trim())
    .filter(Boolean)
    .slice(0, 6);
  if (!values.length) return null;
  return {
    values,
    confidence: buildArtifactConfidence(confidence, ['profile_goals']),
    evidence: buildProfileEvidence('goals'),
  };
}

function deriveConcernConfidence({ issueType, analysis, defaultScore } = {}) {
  const findings = Array.isArray(analysis && analysis.findings) ? analysis.findings : [];
  for (const finding of findings) {
    if (!finding || typeof finding !== 'object') continue;
    const token = String(finding.issue_type || '').trim().toLowerCase();
    if (!token || token !== String(issueType || '').trim().toLowerCase()) continue;
    const c = Number(finding.confidence);
    if (Number.isFinite(c)) return Math.max(0, Math.min(1, c));
  }
  return Number.isFinite(Number(defaultScore)) ? Math.max(0, Math.min(1, Number(defaultScore))) : 0.58;
}

function deriveConcernsFromAnalysis({ analysis, profileSummary, usedPhotos, analysisSource } = {}) {
  const out = [];
  const seen = new Set();
  const findings = Array.isArray(analysis && analysis.findings) ? analysis.findings : [];
  for (const finding of findings) {
    if (!finding || typeof finding !== 'object') continue;
    const concernId = String(finding.issue_type || '').trim();
    if (!concernId) continue;
    const key = concernId.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    const score = deriveConcernConfidence({ issueType: concernId, analysis, defaultScore: finding.confidence });
    const evidence = [];
    if (usedPhotos) {
      const findingId = typeof finding.finding_id === 'string' ? finding.finding_id.trim() : '';
      evidence.push({
        source: 'photo',
        supports: ['concerns'],
        ...(findingId ? { ref: { type: 'model_run', id: findingId } } : {}),
        reliabilityWeight: 0.78,
      });
    } else {
      evidence.push({
        source: 'rule',
        supports: ['concerns'],
        ref: { type: 'rule_id', id: 'ANALYSIS_RULE_BASELINE' },
        reliabilityWeight: 0.68,
      });
    }
    if (
      analysisSource === 'vision_openai' ||
      analysisSource === 'vision_openai_fallback' ||
      analysisSource === 'vision_gemini' ||
      analysisSource === 'aurora_text'
    ) {
      evidence.push({
        source: 'llm',
        supports: ['concerns'],
        ref: { type: 'model_run', id: `analysis_${analysisSource}` },
        reliabilityWeight: 0.52,
      });
    }
    out.push({
      id: concernId,
      confidence: buildArtifactConfidence(score, [`analysis_${analysisSource || 'rule_based'}`]),
      evidence,
    });
  }

  const profileGoals = Array.isArray(profileSummary && profileSummary.goals) ? profileSummary.goals : [];
  for (const goal of profileGoals) {
    const concernId = String(goal || '').trim();
    if (!concernId) continue;
    const key = concernId.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push({
      id: concernId,
      confidence: buildArtifactConfidence(0.56, ['goal_proxy']),
      evidence: buildProfileEvidence('goals'),
    });
  }
  return out.slice(0, 8);
}

function deriveArtifactOverallConfidence({
  usePhoto,
  usedPhotos,
  photoQuality,
  analysisSource,
  profileSummary,
  concerns,
} = {}) {
  const skinTypePresent = Boolean(profileSummary && profileSummary.skinType);
  const barrierPresent = Boolean(profileSummary && profileSummary.barrierStatus);
  const sensitivityPresent = Boolean(profileSummary && profileSummary.sensitivity);
  const goalsPresent = Boolean(profileSummary && Array.isArray(profileSummary.goals) && profileSummary.goals.length > 0);

  const baseParts = [];
  baseParts.push(skinTypePresent ? 0.74 : 0);
  baseParts.push(barrierPresent ? 0.72 : 0);
  baseParts.push(sensitivityPresent ? 0.7 : 0);
  baseParts.push(goalsPresent ? 0.76 : 0);
  const base = baseParts.reduce((sum, value) => sum + value, 0) / Math.max(1, baseParts.length);

  const concernBoost =
    Array.isArray(concerns) && concerns.length
      ? Math.min(
          0.1,
          concerns.reduce((sum, item) => {
            const node = item && typeof item === 'object' ? item.confidence : null;
            const score = node && typeof node === 'object' ? Number(node.score) : 0;
            return sum + (Number.isFinite(score) ? score : 0);
          }, 0) /
            concerns.length *
            0.12,
        )
      : 0;

  let score = Math.max(0, Math.min(1, base + concernBoost));
  const rationale = ['core4_weighted_mean'];

  const qualityGrade = String(photoQuality && photoQuality.grade || '').trim().toLowerCase();
  if (qualityGrade === 'degraded') {
    score = Math.max(0, score - 0.1);
    rationale.push('photo_qc_degraded');
  } else if (qualityGrade === 'fail') {
    score = Math.min(score, LOW_CONFIDENCE_THRESHOLD - 0.01);
    rationale.push('photo_qc_failed');
  }

  if (usePhoto === false) {
    score = Math.min(score, 0.75);
    rationale.push('photo_skipped');
  } else if (usePhoto && !usedPhotos) {
    score = Math.min(score, LOW_CONFIDENCE_THRESHOLD - 0.01);
    rationale.push('photo_requested_but_not_used');
  }

  const normalizedSource = String(analysisSource || '').trim().toLowerCase();
  if (normalizedSource === 'baseline_low_confidence' || normalizedSource === 'retake') {
    score = Math.min(score, LOW_CONFIDENCE_THRESHOLD - 0.01);
    rationale.push('low_confidence_fallback');
  }

  return buildArtifactConfidence(score, rationale);
}

function buildDiagnosisArtifactV1({
  ctx,
  identity,
  profileSummary,
  recentLogsSummary,
  analysis,
  analysisSource,
  usePhoto,
  usedPhotos,
  photos,
  photoQuality,
} = {}) {
  const concerns = deriveConcernsFromAnalysis({
    analysis,
    profileSummary,
    usedPhotos,
    analysisSource,
  });
  const overallConfidence = deriveArtifactOverallConfidence({
    usePhoto,
    usedPhotos,
    photoQuality,
    analysisSource,
    profileSummary,
    concerns,
  });
  const photoRefs = (Array.isArray(photos) ? photos : [])
    .map((item) => {
      if (!item || typeof item !== 'object') return null;
      const slot = String(item.slot_id || '').trim();
      const photoId = String(item.photo_id || '').trim();
      if (!slot || !photoId) return null;
      const qcStatus = String(item.qc_status || 'unknown').trim();
      return {
        slot,
        photo_id: photoId,
        qc_status: qcStatus,
      };
    })
    .filter(Boolean)
    .slice(0, 4);

  const sourceMix = normalizeArtifactSourceMix([
    usedPhotos ? 'photo' : 'rule',
    recentLogsSummary && recentLogsSummary.length ? 'log' : null,
    profileSummary ? 'profile' : null,
    analysisSource === 'vision_openai' ||
    analysisSource === 'vision_openai_fallback' ||
    analysisSource === 'vision_gemini' ||
    analysisSource === 'aurora_text'
      ? 'llm'
      : null,
  ]);

  const artifact = {
    artifact_id: createArtifactId(),
    created_at: new Date().toISOString(),
    use_photo: Boolean(usePhoto),
    overall_confidence: overallConfidence,
    skinType: buildArtifactValueNode({
      value: profileSummary && profileSummary.skinType,
      confidence: skinTypeConfidence(profileSummary),
      fieldKey: 'skinType',
    }),
    barrierStatus: buildArtifactValueNode({
      value: profileSummary && profileSummary.barrierStatus,
      confidence: barrierConfidence(profileSummary),
      fieldKey: 'barrierStatus',
    }),
    sensitivity: buildArtifactValueNode({
      value: profileSummary && profileSummary.sensitivity,
      confidence: sensitivityConfidence(profileSummary),
      fieldKey: 'sensitivity',
    }),
    goals: buildArtifactGoalsNode(profileSummary && profileSummary.goals, 0.74),
    concerns,
    photos: photoRefs,
    safety: {
      non_medical_disclaimer_version: 'v1',
      red_flags: [],
    },
    analysis_context: {
      analysis_source: String(analysisSource || '').trim() || 'unknown',
      used_photos: Boolean(usedPhotos),
      quality_grade: String(photoQuality && photoQuality.grade || '').trim() || 'unknown',
    },
    source_mix: sourceMix,
    session_patch: {
      next_state: 'S5_ANALYSIS_SUMMARY',
      state: {
        latest_artifact_id: null,
      },
    },
    identity: {
      aurora_uid: identity && identity.auroraUid ? String(identity.auroraUid).trim() : null,
      user_id: identity && identity.userId ? String(identity.userId).trim() : null,
      session_id: ctx && ctx.brief_id ? String(ctx.brief_id).trim() : null,
    },
  };

  return artifact;
}

function buildConfidenceNoticeCardPayload({
  language,
  reason,
  confidence,
  actions,
  severity = 'warn',
  details,
} = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const rationale = Array.isArray(confidence && confidence.rationale) ? confidence.rationale : [];
  const score = Number(confidence && confidence.score);
  const level = String(confidence && confidence.level || '').trim().toLowerCase() || confidenceLevelFromScoreV1(score);
  const messageByReason = {
    artifact_missing:
      lang === 'CN'
        ? ''
        : 'No diagnosis artifact is available yet. Please upload photos or run a low-confidence baseline analysis first.',
    low_confidence:
      lang === 'CN'
        ? ' daylight + indoor_white '
        : 'Diagnosis confidence is low, so this was downgraded to a gentle baseline plan. Retake daylight + indoor_white photos to improve accuracy.',
    safety_block:
      lang === 'CN'
        ? ''
        : 'Potential medical risk signals detected, so product recommendations are blocked.',
    default:
      lang === 'CN' ? '' : 'Current guidance is running in conservative mode.',
  };

  return {
    reason: reason || 'default',
    severity,
    confidence: {
      score: Number.isFinite(score) ? Math.max(0, Math.min(1, score)) : 0,
      level,
      rationale,
    },
    message: messageByReason[reason] || messageByReason.default,
    actions: Array.isArray(actions) ? actions : [],
    details: Array.isArray(details) ? details.slice(0, 6) : [],
  };
}

function skinTypeConfidence(profileSummary) {
  return profileSummary && profileSummary.skinType ? 0.74 : 0;
}

function barrierConfidence(profileSummary) {
  return profileSummary && profileSummary.barrierStatus ? 0.72 : 0;
}

function sensitivityConfidence(profileSummary) {
  return profileSummary && profileSummary.sensitivity ? 0.7 : 0;
}

function extractLatestArtifactIdFromSession(session) {
  if (!session || typeof session !== 'object' || Array.isArray(session)) return null;
  const state = session.state && typeof session.state === 'object' && !Array.isArray(session.state) ? session.state : null;
  if (!state) return null;
  const artifactId = String(state.latest_artifact_id || '').trim();
  return artifactId || null;
}

function appendLatestArtifactToSessionPatch(sessionPatch, artifactId) {
  if (!sessionPatch || typeof sessionPatch !== 'object') return;
  const id = String(artifactId || '').trim();
  if (!id) return;
  const state = isPlainObject(sessionPatch.state) ? { ...sessionPatch.state } : {};
  state.latest_artifact_id = id;
  sessionPatch.state = state;
}

function buildIngredientPlanCard(plan, requestId) {
  return {
    card_id: `ing_plan_${requestId}`,
    type: 'ingredient_plan',
    payload: {
      plan,
      intensity: plan && plan.intensity ? plan.intensity : 'balanced',
      targets: Array.isArray(plan && plan.targets) ? plan.targets : [],
      avoid: Array.isArray(plan && plan.avoid) ? plan.avoid : [],
      conflicts: Array.isArray(plan && plan.conflicts) ? plan.conflicts : [],
      confidence: plan && plan.confidence && typeof plan.confidence === 'object' ? plan.confidence : null,
    },
  };
}

function buildRecoEntryChips(language) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  return [
    {
      chip_id: 'chip.intake.upload_photos',
      label: lang === 'CN' ? ' daylight + indoor_white' : 'Upload daylight + indoor_white',
      kind: 'quick_reply',
      data: {},
    },
    {
      chip_id: 'chip.intake.skip_analysis',
      label: lang === 'CN' ? '' : 'Use low-confidence baseline',
      kind: 'quick_reply',
      data: {},
    },
  ];
}

function requireAuroraUid(ctx) {
  const uid = String(ctx.aurora_uid || '').trim();
  if (!uid) {
    const err = new Error('Missing X-Aurora-UID');
    err.status = 400;
    err.code = 'MISSING_AURORA_UID';
    throw err;
  }
  return uid;
}

async function resolveIdentity(req, ctx) {
  const token = getBearerToken(req);
  if (!token) return { auroraUid: ctx.aurora_uid, userId: null, userEmail: null, token: null, auth_invalid: false };

  let session = null;
  try {
    session = await resolveSessionFromToken(token);
  } catch {
    session = null;
  }

  if (!session) return { auroraUid: ctx.aurora_uid, userId: null, userEmail: null, token: null, auth_invalid: true };

  if (ctx.aurora_uid) {
    try {
      await upsertIdentityLink(ctx.aurora_uid, session.userId);
    } catch {
      // ignore
    }
  }

  return { auroraUid: ctx.aurora_uid, userId: session.userId, userEmail: session.email, token, auth_invalid: false };
}

function parseClarificationIdFromActionId(actionId) {
  const id = String(actionId || '').trim();
  if (!id) return '';
  const parts = id.split('.');
  if (parts.length < 4) return '';
  if (parts[0] !== 'chip' || parts[1] !== 'clarify') return '';
  return String(parts[2] || '').trim();
}

function parseClarificationReplyFromActionId(actionId) {
  const id = String(actionId || '').trim();
  if (!id) return '';
  const parts = id.split('.');
  if (parts.length < 4) return '';
  if (parts[0] !== 'chip' || parts[1] !== 'clarify') return '';
  return String(parts.slice(3).join(' ') || '')
    .replace(/_/g, ' ')
    .trim();
}

function stableHashBase36(raw) {
  const input = String(raw == null ? '' : raw);
  const hex = crypto.createHash('sha1').update(input).digest('hex');
  return BigInt(`0x${hex}`).toString(36);
}

function normalizeClarificationField(raw) {
  const rawText = String(raw == null ? '' : raw).trim();
  const lowered = rawText.toLowerCase();
  let norm = lowered
    .normalize('NFKC')
    .replace(/[^\p{L}\p{N}_:]+/gu, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');

  if (!norm) {
    recordClarificationIdNormalizedEmpty();
    norm = `cid_${stableHashBase36(rawText).slice(0, 12)}`;
  }

  const haystack = `${lowered} ${norm}`;
  if (/(budget|price|spend|||)/.test(haystack)) return 'budgetTier';
  if (/(goal|concern|target|focus|||||)/.test(haystack)) return 'goals';
  if (/(barrier|sting|red|irrit|reactive||||||)/.test(haystack)) return 'barrierStatus';
  if (/(sensit||)/.test(haystack)) return 'sensitivity';
  if (/(skin|||||||oily|dry|combo|combination|mixed|normal)/.test(haystack)) return 'skinType';
  return norm;
}

const FILTERABLE_CLARIFICATION_FIELDS = new Set(['skinType', 'sensitivity', 'barrierStatus', 'goals', 'budgetTier']);
const RESUME_KNOWN_PROFILE_FIELDS = Object.freeze(['skinType', 'sensitivity', 'barrierStatus', 'goals', 'budgetTier']);
const RESUME_PREFIX_KNOWN_FIELD_MAX_VALUE = 40;
const RESUME_PREFIX_KNOWN_GOALS_MAX_ITEMS = 5;

const RESUME_REASK_PATTERNS = Object.freeze({
  skinType: [
    /what(?:'s| is)\s+your\s+skin\s+type/i,
    /which\s+skin\s+type/i,
    /(?:|).{0,8}(?:|).{0,8}(?:|||\?|)/i,
  ],
  barrierStatus: [
    /is\s+your\s+barrier\s+(?:stable|healthy|ok)/i,
    /do\s+you\s+have\s+stinging(?:\/|\s+or\s+)redness/i,
    /stinging\/redness/i,
    /(?:).{0,12}(?:|||).{0,6}(?:|\?|)/i,
  ],
  goals: [
    /what(?:'s| is)\s+your\s+(?:main|top)\s+goal/i,
    /what\s+is\s+your\s+goal/i,
    /(?:|).{0,8}(?:||).{0,8}(?:|).{0,6}(?:||\?|)/i,
  ],
});

function truncateResumeKnownValue(raw) {
  const text = typeof raw === 'string' ? raw.trim() : '';
  if (!text || isUnsureToken(text)) return '';
  if (text.length <= RESUME_PREFIX_KNOWN_FIELD_MAX_VALUE) return text;
  return text.slice(0, RESUME_PREFIX_KNOWN_FIELD_MAX_VALUE);
}

function hasKnownClarificationFieldValue(profileSummary, field) {
  if (!field || !profileSummary || typeof profileSummary !== 'object') return false;
  const norm = (v) => (typeof v === 'string' ? v.trim().toLowerCase() : '');
  if (field === 'skinType') {
    const v = norm(profileSummary.skinType);
    return Boolean(v && v !== 'unknown');
  }
  if (field === 'sensitivity') {
    const v = norm(profileSummary.sensitivity);
    return Boolean(v && v !== 'unknown');
  }
  if (field === 'barrierStatus') {
    const v = norm(profileSummary.barrierStatus);
    return Boolean(v && v !== 'unknown');
  }
  if (field === 'goals') {
    const goals = Array.isArray(profileSummary.goals) ? profileSummary.goals : [];
    return goals.some((g) => norm(g));
  }
  if (field === 'budgetTier') {
    const v = norm(profileSummary.budgetTier);
    return Boolean(v && v !== 'unknown');
  }
  return false;
}

function buildResumeKnownProfileFields(profileSummary) {
  if (!profileSummary || typeof profileSummary !== 'object') return null;
  const out = {};

  if (hasKnownClarificationFieldValue(profileSummary, 'skinType')) {
    const skinType = truncateResumeKnownValue(profileSummary.skinType);
    if (skinType) out.skinType = skinType;
  }

  if (hasKnownClarificationFieldValue(profileSummary, 'sensitivity')) {
    const sensitivity = truncateResumeKnownValue(profileSummary.sensitivity);
    if (sensitivity) out.sensitivity = sensitivity;
  }

  if (hasKnownClarificationFieldValue(profileSummary, 'barrierStatus')) {
    const barrierStatus = truncateResumeKnownValue(profileSummary.barrierStatus);
    if (barrierStatus) out.barrierStatus = barrierStatus;
  }

  if (hasKnownClarificationFieldValue(profileSummary, 'goals')) {
    const goals = (Array.isArray(profileSummary.goals) ? profileSummary.goals : [])
      .map((g) => truncateResumeKnownValue(g))
      .filter(Boolean)
      .slice(0, RESUME_PREFIX_KNOWN_GOALS_MAX_ITEMS);
    if (goals.length) out.goals = goals;
  }

  if (hasKnownClarificationFieldValue(profileSummary, 'budgetTier')) {
    const budgetTier = truncateResumeKnownValue(profileSummary.budgetTier);
    if (budgetTier) out.budgetTier = budgetTier;
  }

  return Object.keys(out).length ? out : null;
}

function classifyResumeResponseMode(answerText) {
  const text = String(answerText || '').trim();
  if (!text) return 'mixed';
  const leading = text.slice(0, 400);
  const leadingNorm = leading.replace(/\s+/g, ' ').trim();
  const questionMarks = (text.match(/[?]/g) || []).length;
  const startsWithIntakePrompt = /^(before i can|before i recommend|i need a quick skin profile)/i.test(leadingNorm);
  const numberedQuestionLines = (leading.match(/(?:^|\n)\s*\d+\s*[\)\.:\uff1a]/g) || []).length >= 2;
  if (questionMarks >= 2 || startsWithIntakePrompt || numberedQuestionLines) return 'question';

  const answerLike = /(am\/pm|routine|plan|onboarding|ingredient|buying criteria|||||)/i.test(text);
  if (answerLike && questionMarks <= 1) return 'answer';
  return 'mixed';
}

function detectResumePlaintextReaskFields(answerText, knownProfileFields) {
  const text = String(answerText || '');
  if (!text || !knownProfileFields || typeof knownProfileFields !== 'object') return [];
  const detected = [];
  for (const field of RESUME_KNOWN_PROFILE_FIELDS) {
    if (!Object.prototype.hasOwnProperty.call(knownProfileFields, field)) continue;
    const patterns = RESUME_REASK_PATTERNS[field];
    if (!Array.isArray(patterns) || !patterns.length) continue;
    if (patterns.some((pattern) => pattern.test(text))) detected.push(field);
  }
  return detected;
}

function filterClarificationQuestionsForChips({ clarification, profileSummary, filterKnown } = {}) {
  if (!clarification || typeof clarification !== 'object') return [];

  const rawQuestions = clarification.questions;
  if (!Array.isArray(rawQuestions)) {
    recordClarificationSchemaInvalid({ reason: 'questions_not_array' });
    return [];
  }

  const questions = [];
  let filteredKnownCount = 0;
  let validQuestionCount = 0;
  for (const rawQuestion of rawQuestions) {
    if (!rawQuestion || typeof rawQuestion !== 'object' || Array.isArray(rawQuestion)) {
      recordClarificationSchemaInvalid({ reason: 'question_not_object' });
      continue;
    }

    const qidRaw = typeof rawQuestion.id === 'string' ? rawQuestion.id.trim() : '';
    const qid = qidRaw || 'clarify';
    if (!qidRaw) {
      recordClarificationSchemaInvalid({ reason: 'question_id_missing' });
    }

    if (!Array.isArray(rawQuestion.options)) {
      recordClarificationSchemaInvalid({ reason: 'question_options_not_array' });
      continue;
    }

    let hasInvalidOptionType = false;
    const options = [];
    for (const rawOption of rawQuestion.options) {
      if (typeof rawOption !== 'string') {
        hasInvalidOptionType = true;
        continue;
      }
      const option = rawOption.trim();
      if (option) options.push(option);
    }
    if (hasInvalidOptionType) {
      recordClarificationSchemaInvalid({ reason: 'question_option_non_string' });
    }
    if (!options.length) {
      recordClarificationSchemaInvalid({ reason: 'question_options_empty' });
      continue;
    }
    const question = typeof rawQuestion.question === 'string' ? rawQuestion.question.trim() : '';

    validQuestionCount += 1;
    const field = normalizeClarificationField(qid);
    const shouldFilterKnown =
      Boolean(filterKnown) &&
      FILTERABLE_CLARIFICATION_FIELDS.has(field) &&
      hasKnownClarificationFieldValue(profileSummary, field);
    if (shouldFilterKnown) {
      filteredKnownCount += 1;
      recordClarificationQuestionFiltered({ field });
      // Keep existing observability for repeated asks, even when we filter the chips.
      recordRepeatedClarifyField({ field });
      continue;
    }

    questions.push({ id: qid, question, options });
  }

  if (Boolean(filterKnown) && validQuestionCount > 0 && filteredKnownCount > 0 && questions.length === 0) {
    recordClarificationAllQuestionsFiltered();
  }

  return questions;
}

const PENDING_CLARIFICATION_SCHEMA_V1 = 1;
const PENDING_CLARIFICATION_MAX_RESUME_USER_TEXT = 800;
const PENDING_CLARIFICATION_MAX_QUEUE = 5;
const PENDING_CLARIFICATION_MAX_OPTIONS = 8;
const PENDING_CLARIFICATION_MAX_QUESTION = 200;
const PENDING_CLARIFICATION_MAX_OPTION = 80;
const PENDING_CLARIFICATION_MAX_HISTORY = 6;

function makeFlowId() {
  const rand = crypto.randomBytes(6).toString('hex').slice(0, 12);
  return `pc_${rand || Math.random().toString(36).slice(2, 10)}`;
}

function truncate(value, maxChars) {
  const text = typeof value === 'string' ? value.trim() : '';
  if (!text) return { value: '', truncated: false };
  if (text.length <= maxChars) return { value: text, truncated: false };
  return { value: text.slice(0, maxChars), truncated: true };
}

function capArray(items, maxCount) {
  const list = Array.isArray(items) ? items : [];
  if (list.length <= maxCount) return { values: list, dropped: 0 };
  return { values: list.slice(0, maxCount), dropped: list.length - maxCount };
}

function normalizePendingClarificationId(rawId) {
  const idRaw = typeof rawId === 'string' ? rawId.trim() : '';
  const id = idRaw || 'clarify';
  const normId = normalizeClarificationField(id);
  return { id, norm_id: normId };
}

function recordPendingClarificationTruncationFields(fields) {
  for (const field of Array.from(fields || [])) {
    recordPendingClarificationTruncated({ field });
  }
}

function normalizeClarificationQuestionForPending(rawQuestion, { recordTruncationMetrics = true, truncationFields } = {}) {
  if (!rawQuestion || typeof rawQuestion !== 'object' || Array.isArray(rawQuestion)) return null;
  if (!Array.isArray(rawQuestion.options)) return null;

  const localTruncationFields = new Set();
  const idInfo = normalizePendingClarificationId(rawQuestion.id);
  const questionTextRaw = typeof rawQuestion.question === 'string' ? rawQuestion.question.trim() : '';
  const questionTrimmed = truncate(questionTextRaw, PENDING_CLARIFICATION_MAX_QUESTION);
  if (questionTrimmed.truncated) localTruncationFields.add('question');

  const options = [];
  for (const rawOption of rawQuestion.options) {
    if (typeof rawOption !== 'string') continue;
    const optionText = rawOption.trim();
    if (!optionText) continue;
    const optionTrimmed = truncate(optionText, PENDING_CLARIFICATION_MAX_OPTION);
    if (optionTrimmed.truncated) localTruncationFields.add('option');
    options.push(optionTrimmed.value);
  }
  if (!options.length) return null;

  const cappedOptions = capArray(options, PENDING_CLARIFICATION_MAX_OPTIONS);
  if (cappedOptions.dropped > 0) localTruncationFields.add('options');

  for (const field of Array.from(localTruncationFields)) {
    if (truncationFields && truncationFields.add) truncationFields.add(field);
  }
  if (recordTruncationMetrics && localTruncationFields.size > 0) {
    recordPendingClarificationTruncationFields(localTruncationFields);
  }

  return {
    id: idInfo.id,
    norm_id: idInfo.norm_id,
    question: questionTrimmed.value,
    options: cappedOptions.values,
  };
}

function isClarifyChipAction(action, { actionId, clarificationId } = {}) {
  const id =
    typeof actionId === 'string'
      ? actionId.trim()
      : typeof action === 'string'
        ? action.trim()
        : action && typeof action === 'object' && typeof action.action_id === 'string'
          ? action.action_id.trim()
          : '';
  if (id.toLowerCase().startsWith('chip.clarify.')) return true;
  if (parseClarificationIdFromActionId(id)) return true;
  return Boolean(typeof clarificationId === 'string' && clarificationId.trim());
}

function hasPendingClarificationStateHint(action) {
  if (!action || typeof action !== 'object' || Array.isArray(action)) return false;
  const data = action.data && typeof action.data === 'object' ? action.data : null;
  if (!data) return false;
  if (Object.prototype.hasOwnProperty.call(data, 'clarification_step')) return true;
  if (typeof data.clarification_question_id === 'string' && data.clarification_question_id.trim()) return true;
  if (typeof data.clarificationQuestionId === 'string' && data.clarificationQuestionId.trim()) return true;
  return false;
}

function extractClarificationQuestionIdFromAction(action) {
  if (!action || typeof action !== 'object' || Array.isArray(action)) return '';
  const data = action.data && typeof action.data === 'object' ? action.data : null;
  if (!data) return '';
  const raw =
    (typeof data.clarification_question_id === 'string' && data.clarification_question_id) ||
    (typeof data.clarificationQuestionId === 'string' && data.clarificationQuestionId) ||
    '';
  return String(raw || '').trim();
}

function sanitizePendingClarification(rawPending, { recordMetrics = true } = {}) {
  if (!rawPending || typeof rawPending !== 'object' || Array.isArray(rawPending)) return null;
  const truncationFields = new Set();

  const createdAtRaw = Number(rawPending.created_at_ms);
  if (!Number.isFinite(createdAtRaw) || createdAtRaw <= 0) return null;
  const createdAtMs = Math.trunc(createdAtRaw);

  const resumeTextRaw = typeof rawPending.resume_user_text === 'string' ? rawPending.resume_user_text.trim() : '';
  if (!resumeTextRaw) return null;
  const resumeText = truncate(resumeTextRaw, PENDING_CLARIFICATION_MAX_RESUME_USER_TEXT);
  if (resumeText.truncated) truncationFields.add('resume_user_text');

  const flowIdRaw = typeof rawPending.flow_id === 'string' ? rawPending.flow_id.trim() : '';
  const flowId = /^pc_[a-z0-9]+$/i.test(flowIdRaw) ? flowIdRaw.slice(0, 32) : makeFlowId();

  const resumeUserHashRaw = typeof rawPending.resume_user_hash === 'string' ? rawPending.resume_user_hash.trim() : '';
  const resumeUserHashSafe = (resumeUserHashRaw || stableHashBase36(resumeText.value).slice(0, 20))
    .replace(/[^a-zA-Z0-9_-]/g, '')
    .slice(0, 24);

  if (!Array.isArray(rawPending.queue)) return null;
  const normalizedQueue = [];
  for (const rawQuestion of rawPending.queue) {
    const normalized = normalizeClarificationQuestionForPending(rawQuestion, {
      recordTruncationMetrics: false,
      truncationFields,
    });
    if (normalized) normalizedQueue.push(normalized);
  }
  if (normalizedQueue.length < rawPending.queue.length) truncationFields.add('queue');
  const cappedQueue = capArray(normalizedQueue, PENDING_CLARIFICATION_MAX_QUEUE);
  if (cappedQueue.dropped > 0) truncationFields.add('queue');

  let current = null;
  if (rawPending.current && typeof rawPending.current === 'object' && !Array.isArray(rawPending.current)) {
    const currentIdRaw = typeof rawPending.current.id === 'string' ? rawPending.current.id.trim() : '';
    if (currentIdRaw) {
      const currentIdInfo = normalizePendingClarificationId(currentIdRaw);
      current = { id: currentIdInfo.id, norm_id: currentIdInfo.norm_id };
    }
  }

  const historyRaw = Array.isArray(rawPending.history) ? rawPending.history : [];
  if (!Array.isArray(rawPending.history) && rawPending.history != null) {
    truncationFields.add('history');
  }
  const normalizedHistory = [];
  for (const entry of historyRaw) {
    if (!entry || typeof entry !== 'object' || Array.isArray(entry)) continue;
    const questionIdRaw = typeof entry.question_id === 'string' ? entry.question_id.trim() : '';
    const optionRaw = typeof entry.option === 'string' ? entry.option.trim() : '';
    const tsMsRaw = Number(entry.ts_ms);
    if (!questionIdRaw || !optionRaw || !Number.isFinite(tsMsRaw) || tsMsRaw <= 0) continue;

    const questionIdInfo = normalizePendingClarificationId(questionIdRaw);
    const optionTrimmed = truncate(optionRaw, PENDING_CLARIFICATION_MAX_OPTION);
    if (optionTrimmed.truncated) truncationFields.add('option');

    normalizedHistory.push({
      question_id: questionIdInfo.id,
      norm_id:
        typeof entry.norm_id === 'string' && entry.norm_id.trim()
          ? entry.norm_id.trim().slice(0, 80)
          : questionIdInfo.norm_id,
      option: optionTrimmed.value,
      ts_ms: Math.trunc(tsMsRaw),
    });
  }
  if (normalizedHistory.length < historyRaw.length) truncationFields.add('history');
  let history = normalizedHistory;
  if (normalizedHistory.length > PENDING_CLARIFICATION_MAX_HISTORY) {
    history = normalizedHistory.slice(-PENDING_CLARIFICATION_MAX_HISTORY);
    truncationFields.add('history');
  }

  const canonical = {
    v: PENDING_CLARIFICATION_SCHEMA_V1,
    flow_id: flowId,
    created_at_ms: createdAtMs,
    resume_user_text: resumeText.value,
    ...(resumeUserHashSafe ? { resume_user_hash: resumeUserHashSafe } : {}),
    step_index: history.length,
    ...(current ? { current } : {}),
    queue: cappedQueue.values,
    history,
  };

  const upgraded = Number(rawPending.v) !== PENDING_CLARIFICATION_SCHEMA_V1;
  if (recordMetrics) {
    if (upgraded) recordPendingClarificationUpgraded({ from: 'legacy' });
    if (truncationFields.size > 0) recordPendingClarificationTruncationFields(truncationFields);
  }

  return { pending: canonical, upgraded };
}

function getPendingClarification(session) {
  const s = session && typeof session === 'object' ? session : null;
  if (!s) return null;
  const state = s.state && typeof s.state === 'object' && !Array.isArray(s.state) ? s.state : null;
  if (!state) return null;
  const raw = state.pending_clarification;
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  return sanitizePendingClarification(raw, { recordMetrics: true });
}

function emitPendingClarificationPatch(sessionPatch, pendingOrNull) {
  if (!sessionPatch || typeof sessionPatch !== 'object') return;
  const state = isPlainObject(sessionPatch.state) ? { ...sessionPatch.state } : {};
  state.pending_clarification = pendingOrNull || null;
  sessionPatch.state = state;
}

function buildChipsForQuestion(question, { stepIndex } = {}) {
  const q = normalizeClarificationQuestionForPending(question);
  if (!q) return [];
  const qid = String(q.id || 'clarify').trim() || 'clarify';
  const step = Number.isFinite(Number(stepIndex)) ? Math.max(1, Math.trunc(Number(stepIndex))) : 1;
  return q.options.slice(0, 8).map((option) => ({
    chip_id: `chip.clarify.${qid}.${option.trim().slice(0, 40).replace(/\s+/g, '_')}`,
    label: option,
    kind: 'quick_reply',
    data: {
      reply_text: option,
      clarification_id: qid,
      clarification_question_id: qid,
      clarification_norm_id: String(q.norm_id || ''),
      clarification_step: step,
    },
  }));
}

function advancePendingClarification(pending, selectedOption, selectedQuestionId) {
  const nowMs = Date.now();
  const option = typeof selectedOption === 'string' ? selectedOption.trim() : '';
  const currentId =
    (typeof selectedQuestionId === 'string' && selectedQuestionId.trim()) ||
    (pending && pending.current && typeof pending.current.id === 'string' && pending.current.id.trim()) ||
    'clarify';
  const currentIdInfo = normalizePendingClarificationId(currentId);
  const optionTrimmed = truncate(option || '(empty)', PENDING_CLARIFICATION_MAX_OPTION);
  if (optionTrimmed.truncated) {
    recordPendingClarificationTruncated({ field: 'option' });
  }
  const entry = {
    question_id: currentIdInfo.id,
    norm_id: currentIdInfo.norm_id,
    option: optionTrimmed.value || '(empty)',
    ts_ms: nowMs,
  };

  const history = Array.isArray(pending && pending.history) ? [...pending.history, entry] : [entry];
  const queue = Array.isArray(pending && pending.queue) ? pending.queue : [];
  const historyState = sanitizePendingClarification(
    {
      v: PENDING_CLARIFICATION_SCHEMA_V1,
      flow_id: pending && typeof pending.flow_id === 'string' ? pending.flow_id : makeFlowId(),
      created_at_ms: Number(pending && pending.created_at_ms) || nowMs,
      resume_user_text: typeof pending?.resume_user_text === 'string' ? pending.resume_user_text : '(no message)',
      ...(pending && typeof pending.resume_user_hash === 'string' ? { resume_user_hash: pending.resume_user_hash } : {}),
      step_index: history.length,
      ...(pending && pending.current ? { current: pending.current } : {}),
      queue,
      history,
    },
    { recordMetrics: true },
  );
  const boundedHistory = historyState ? historyState.pending.history : history.slice(-PENDING_CLARIFICATION_MAX_HISTORY);
  if (!queue.length) {
    return { nextPending: null, nextQuestion: null, history: boundedHistory };
  }

  const nextQuestion = normalizeClarificationQuestionForPending(queue[0], { recordTruncationMetrics: true });
  if (!nextQuestion) return { nextPending: null, nextQuestion: null, history: boundedHistory };
  const nextPendingState = sanitizePendingClarification(
    {
      v: PENDING_CLARIFICATION_SCHEMA_V1,
      flow_id: pending && typeof pending.flow_id === 'string' ? pending.flow_id : makeFlowId(),
      created_at_ms: Number(pending && pending.created_at_ms) || nowMs,
      resume_user_text: typeof pending?.resume_user_text === 'string' ? pending.resume_user_text : '(no message)',
      ...(pending && typeof pending.resume_user_hash === 'string' ? { resume_user_hash: pending.resume_user_hash } : {}),
      step_index: boundedHistory.length,
      current: { id: nextQuestion.id, norm_id: nextQuestion.norm_id },
      queue: queue.slice(1),
      history: boundedHistory,
    },
    { recordMetrics: true },
  );
  if (!nextPendingState || !nextPendingState.pending) {
    return { nextPending: null, nextQuestion: null, history: boundedHistory };
  }
  return { nextPending: nextPendingState.pending, nextQuestion, history: nextPendingState.pending.history };
}

function compactClarificationHistory(history) {
  const out = [];
  const list = Array.isArray(history) ? history : [];
  for (const item of list) {
    if (!item || typeof item !== 'object' || Array.isArray(item)) continue;
    const questionId = typeof item.question_id === 'string' ? item.question_id.trim() : '';
    const option = typeof item.option === 'string' ? item.option.trim() : '';
    if (!questionId || !option) continue;
    out.push({
      question_id: questionId.slice(0, 120),
      option: option.slice(0, 120),
    });
    if (out.length >= 5) break;
  }
  return out;
}

function isUnsureToken(raw) {
  const text = String(raw || '').trim().toLowerCase();
  if (!text) return false;
  return (
    text === 'unknown' ||
    text === 'unsure' ||
    text === 'not sure' ||
    text === 'n/a' ||
    text === 'na' ||
    /||/.test(text)
  );
}

function inferGoalFromClarificationText(raw) {
  const text = String(raw || '').trim().toLowerCase();
  if (!text) return '';
  if (/(acne|breakout|pore|oil||||||)/.test(text)) return 'acne';
  if (/(redness|sensitive|reactive|||||)/.test(text)) return 'redness';
  if (/(dark spot|pigment|bright|tone||||||)/.test(text)) return 'dark_spots';
  if (/(dry|hydrate|moist||||)/.test(text)) return 'dehydration';
  if (/(wrinkle|fine line|firm|anti[- ]?aging|||||)/.test(text)) return 'wrinkles';
  return '';
}

function inferProfilePatchFromClarification({ clarificationId, replyText }) {
  const field = normalizeClarificationField(clarificationId);
  const raw = String(replyText || '').trim();
  const text = raw.toLowerCase();
  if (!field || !raw) return null;

  if (field === 'skinType') {
    if (/\boily\b/.test(text) || /(||)/.test(text)) return { skinType: 'oily' };
    if (/\bdry\b/.test(text) || /(|||)/.test(text)) return { skinType: 'dry' };
    if (/\b(combo|combination|mixed)\b/.test(text) || //.test(text)) return { skinType: 'combination' };
    if (/\bnormal\b/.test(text) || //.test(text)) return { skinType: 'normal' };
    if (/\bsensitive\b/.test(text) || //.test(text)) return { skinType: 'sensitive' };
    if (isUnsureToken(text)) return { skinType: 'unknown' };
    return null;
  }

  if (field === 'barrierStatus') {
    if (/(stable|healthy|normal|ok|good||)/.test(text)) return { barrierStatus: 'healthy' };
    if (/(sting|stinging|red|irrit|burn|reactive|impaired|damaged||||||)/.test(text)) return { barrierStatus: 'impaired' };
    if (isUnsureToken(text)) return { barrierStatus: 'unknown' };
    return null;
  }

  if (field === 'sensitivity') {
    if (/(^|\b)(low|mild)\b||/.test(text)) return { sensitivity: 'low' };
    if (/(^|\b)(medium|mid|moderate)\b|/.test(text)) return { sensitivity: 'medium' };
    if (/(^|\b)(high|severe|very)\b||/.test(text)) return { sensitivity: 'high' };
    if (/(^|\b)yes(\b|$)||/.test(text)) return { sensitivity: 'high' };
    if (/(^|\b)no(\b|$)||/.test(text)) return { sensitivity: 'low' };
    if (isUnsureToken(text)) return { sensitivity: 'unknown' };
    return null;
  }

  if (field === 'goals') {
    if (isUnsureToken(text)) return { goals: ['unknown'] };
    const goal = inferGoalFromClarificationText(text);
    if (goal) return { goals: [goal] };
    const normalized = raw.replace(/\s+/g, ' ').trim().slice(0, 80);
    return normalized ? { goals: [normalized] } : null;
  }

  if (field === 'budgetTier') {
    const budget = normalizeBudgetHint(raw);
    return { budgetTier: budget || raw.slice(0, 40) };
  }

  return null;
}

function parseProfilePatchFromAction(action) {
  if (!action) return null;
  if (typeof action === 'object' && action.data && typeof action.data === 'object') {
    const patch = action.data.profile_patch || action.data.profilePatch;
    if (patch && typeof patch === 'object') return patch;
  }

  const id = typeof action === 'string' ? action : action && action.action_id;
  if (typeof action === 'object' && action && typeof action.data === 'object' && action.data) {
    const clarificationIdRaw =
      action.data.clarification_id || action.data.clarificationId || parseClarificationIdFromActionId(id);
    const replyText = extractReplyTextFromAction(action) || parseClarificationReplyFromActionId(id);
    const patchFromClarification = inferProfilePatchFromClarification({
      clarificationId: clarificationIdRaw,
      replyText,
    });
    if (patchFromClarification) return patchFromClarification;
  }

  // Fallback: parse chip ids like "profile.skinType.oily".
  if (!id || typeof id !== 'string') return null;
  const parts = id.split('.');
  if (parts.length < 3 || parts[0] !== 'profile') return null;
  const key = parts[1];
  const value = parts.slice(2).join('.');
  if (!key || !value) return null;
  if (key === 'goals') return { goals: [value] };
  if (key === 'skinType') return { skinType: value };
  if (key === 'sensitivity') return { sensitivity: value };
  if (key === 'barrierStatus') return { barrierStatus: value };
  return null;
}

function extractProfilePatchFromSession(session) {
  const s = session && typeof session === 'object' ? session : null;
  if (!s) return null;

  const rawProfile =
    (s.profile_patch && typeof s.profile_patch === 'object' ? s.profile_patch : null) ||
    (s.profilePatch && typeof s.profilePatch === 'object' ? s.profilePatch : null) ||
    (s.profile && typeof s.profile === 'object' ? s.profile : null) ||
    null;
  if (!rawProfile) return null;

  const patch = {};

  // Strings
  const copyString = (toKey, ...fromKeys) => {
    for (const k of fromKeys) {
      const v = rawProfile[k];
      if (typeof v !== 'string') continue;
      const t = v.trim();
      if (!t) continue;
      patch[toKey] = t;
      return;
    }
  };
  copyString('skinType', 'skinType', 'skin_type');
  copyString('sensitivity', 'sensitivity');
  copyString('barrierStatus', 'barrierStatus', 'barrier_status');
  copyString('region', 'region');
  copyString('budgetTier', 'budgetTier', 'budget_tier');

  // Arrays
  if (Array.isArray(rawProfile.goals)) {
    const goals = rawProfile.goals
      .map((v) => (typeof v === 'string' ? v.trim() : ''))
      .filter(Boolean)
      .slice(0, 12);
    if (goals.length) patch.goals = goals;
  }
  if (Array.isArray(rawProfile.contraindications)) {
    const contraindications = rawProfile.contraindications
      .map((v) => (typeof v === 'string' ? v.trim() : ''))
      .filter(Boolean)
      .slice(0, 24);
    if (contraindications.length) patch.contraindications = contraindications;
  }

  // Mixed types
  if (rawProfile.currentRoutine != null) patch.currentRoutine = rawProfile.currentRoutine;
  if (rawProfile.current_routine != null) patch.currentRoutine = rawProfile.current_routine;
  if (rawProfile.itinerary != null) patch.itinerary = rawProfile.itinerary;

  const parsed = UserProfilePatchSchema.safeParse(patch);
  if (!parsed.success) return null;
  const clean = parsed.data;
  return Object.keys(clean).length ? clean : null;
}

function shouldPersistProfilePatch(baseProfile, patch) {
  if (!patch || typeof patch !== 'object') return false;
  const keys = Object.keys(patch);
  if (keys.length === 0) return false;
  if (!baseProfile) return true;

  for (const k of keys) {
    const next = patch[k];
    if (next == null) continue;

    const prev = baseProfile[k];
    if (k === 'goals' || k === 'contraindications') {
      const prevArr = Array.isArray(prev) ? prev : [];
      const nextArr = Array.isArray(next) ? next : [];
      if (nextArr.length && prevArr.length === 0) return true;
      continue;
    }

    if (typeof next === 'string') {
      const prevText = typeof prev === 'string' ? prev.trim() : '';
      if (!prevText) return true;
      continue;
    }

    if (prev == null) return true;
  }

  return false;
}

function extractReplyTextFromAction(action) {
  if (!action || typeof action !== 'object') return null;
  const data = action.data && typeof action.data === 'object' ? action.data : null;
  if (!data) return null;
  const raw =
    (typeof data.reply_text === 'string' && data.reply_text) ||
    (typeof data.replyText === 'string' && data.replyText) ||
    (typeof data.text === 'string' && data.text) ||
    null;
  const text = raw ? String(raw).trim() : '';
  return text || null;
}

function coerceBoolean(value) {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value === 1;
  if (typeof value !== 'string') return false;
  const s = value.trim().toLowerCase();
  return s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on';
}

function normalizeChatLlmProvider(value) {
  if (typeof value !== 'string') return null;
  const provider = value.trim().toLowerCase();
  if (provider === 'gemini' || provider === 'openai') return provider;
  return null;
}

function normalizeChatLlmModel(value) {
  if (typeof value !== 'string') return null;
  const model = value.trim();
  if (!model) return null;
  return model.slice(0, 120);
}

function classifyStorageError(err) {
  const code = err && err.code ? String(err.code) : null;
  const sqlState = code && /^[0-9A-Z]{5}$/.test(code) ? code : null;
  const netCodes = new Set(['ECONNREFUSED', 'ETIMEDOUT', 'ECONNRESET', 'EPIPE', 'ENOTFOUND', 'EAI_AGAIN']);

  const dbNotConfigured = code === 'NO_DATABASE';
  const dbSchemaError = sqlState === '42P01' || sqlState === '42703' || sqlState === '42883';
  const dbError = dbNotConfigured || Boolean(sqlState) || netCodes.has(code);
  return { code, sqlState, dbError, dbNotConfigured, dbSchemaError };
}

function extractIncludeAlternativesFromAction(action) {
  if (!action || typeof action !== 'object') return false;
  const data = action.data && typeof action.data === 'object' ? action.data : null;
  if (!data) return false;
  return coerceBoolean(data.include_alternatives ?? data.includeAlternatives);
}

function summarizeProfileForContext(profile) {
  if (!profile) return null;
  const currentRoutineRaw = profile.currentRoutine;
  let currentRoutine = null;
  if (typeof currentRoutineRaw === 'string') {
    const t = currentRoutineRaw.trim();
    currentRoutine = t ? t.slice(0, 4000) : null;
  } else if (currentRoutineRaw && typeof currentRoutineRaw === 'object') {
    try {
      const json = JSON.stringify(currentRoutineRaw);
      currentRoutine = json.length > 5000 ? `${json.slice(0, 5000)}` : json;
    } catch {
      currentRoutine = null;
    }
  }

  const itineraryRaw = profile.itinerary;
  let itinerary = null;
  if (typeof itineraryRaw === 'string') {
    const t = itineraryRaw.trim();
    itinerary = t ? t.slice(0, 1200) : null;
  } else if (itineraryRaw && typeof itineraryRaw === 'object') {
    try {
      const json = JSON.stringify(itineraryRaw);
      itinerary = json.length > 1500 ? `${json.slice(0, 1500)}` : json;
    } catch {
      itinerary = null;
    }
  }

  const contraindications = Array.isArray(profile.contraindications)
    ? profile.contraindications.filter((v) => typeof v === 'string' && v.trim()).slice(0, 12)
    : [];

  return {
    skinType: profile.skinType || null,
    sensitivity: profile.sensitivity || null,
    barrierStatus: profile.barrierStatus || null,
    goals: Array.isArray(profile.goals) ? profile.goals : [],
    region: profile.region || null,
    budgetTier: profile.budgetTier || null,
    currentRoutine,
    itinerary,
    contraindications,
  };
}

function deepHasKey(obj, predicate, depth = 0) {
  if (depth > 6) return false;
  if (!obj) return false;
  if (Array.isArray(obj)) return obj.some((v) => deepHasKey(v, predicate, depth + 1));
  if (typeof obj !== 'object') return false;
  for (const [k, v] of Object.entries(obj)) {
    if (predicate(k)) return true;
    if (deepHasKey(v, predicate, depth + 1)) return true;
  }
  return false;
}

function structuredContainsCommerceLikeFields(structured) {
  const commerceKeys = new Set([
    'recommendations',
    'reco',
    'offers',
    'offer',
    'checkout',
    'purchase_route',
    'purchaseroute',
    'affiliate_url',
    'affiliateurl',
    'internal_checkout',
    'internalcheckout',
  ]);
  return deepHasKey(structured, (k) => commerceKeys.has(String(k || '').trim().toLowerCase()));
}

function getUpstreamStructuredOrJson(upstream) {
  if (upstream && upstream.structured && typeof upstream.structured === 'object' && !Array.isArray(upstream.structured)) {
    return upstream.structured;
  }
  if (upstream && typeof upstream.answer === 'string') return extractJsonObject(upstream.answer);
  return null;
}

function unwrapCodeFence(text) {
  const t = String(text || '').trim();
  if (!t.startsWith('```')) return t;
  const firstNewline = t.indexOf('\n');
  const lastFence = t.lastIndexOf('```');
  if (firstNewline === -1 || lastFence === -1 || lastFence <= firstNewline) return t;
  return t.slice(firstNewline + 1, lastFence).trim();
}

function looksLikeJsonOrCode(text) {
  const t = String(text || '').trim();
  if (!t) return false;
  if ((t.startsWith('{') && t.endsWith('}')) || (t.startsWith('[') && t.endsWith(']'))) return true;

  if (t.startsWith('```')) {
    const firstLine = t.split('\n')[0].toLowerCase();
    if (firstLine.includes('json') || firstLine.includes('typescript') || firstLine.includes('javascript') || firstLine.includes('ts') || firstLine.includes('js')) {
      return true;
    }
    const inner = unwrapCodeFence(t);
    if ((inner.startsWith('{') && inner.endsWith('}')) || (inner.startsWith('[') && inner.endsWith(']'))) return true;
  }

  return false;
}

function stripInternalKbRefsFromText(text) {
  const input = typeof text === 'string' ? text : '';
  if (!input.trim()) return input;

  const withoutKb = input.replace(/\bkb:[a-z0-9_-]+\b/gi, '');

  const cleaned = withoutKb
    .replace(/\(\s*\)/g, '')
    .replace(/[ \t]{2,}/g, ' ')
    .split('\n')
    .map((line) => line.replace(/[ \t]+$/g, '').replace(/^[ \t]+/g, ''))
    .filter((line) => {
      const t = line.trim();
      if (!t) return true;
      if (/^(evidence|citation|citations|source|sources)[:]?\s*$/i.test(t)) return false;
      if (/^(||)[:]?\s*$/.test(t)) return false;
      return true;
    })
    .join('\n')
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  return cleaned;
}

function isInternalKbCitationId(raw) {
  const v = String(raw || '').trim();
  if (!v) return false;
  const lower = v.toLowerCase();
  if (lower.startsWith('kb:')) return true;
  if (/^[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}$/i.test(v)) return true;
  return false;
}

function stripInternalRefsDeep(value, { parentKey } = {}) {
  if (typeof value === 'string') return stripInternalKbRefsFromText(value);
  if (Array.isArray(value)) {
    const key = String(parentKey || '').trim().toLowerCase();
    const isCitationsField = key === 'citations' || key.endsWith('_citations') || key.endsWith('citations');
    if (isCitationsField) {
      const out = [];
      for (const item of value) {
        if (typeof item === 'string') {
          const t = item.trim();
          if (!t) continue;
          if (isInternalKbCitationId(t)) continue;
          out.push(t);
          continue;
        }
        out.push(stripInternalRefsDeep(item));
      }
      return out;
    }
    return value.map((v) => stripInternalRefsDeep(v));
  }
  if (!isPlainObject(value)) return value;
  const out = {};
  for (const [k, v] of Object.entries(value)) {
    out[k] = stripInternalRefsDeep(v, { parentKey: k });
  }
  return out;
}

function sanitizeUpstreamAnswer(answer, { language, hasRenderableCards, stripInternalRefs } = {}) {
  let t = typeof answer === 'string' ? answer : '';
  if (stripInternalRefs) t = stripInternalKbRefsFromText(t);

  const lang = language === 'CN' ? 'CN' : 'EN';

  const noRenderableCardsMessage =
    lang === 'CN'
      ? '/<>'
      : 'I did not receive any renderable structured cards from upstream (only a parse/summary stub). Please retry, or rephrase (e.g. Evaluate: <product name>).';
  const hasRenderableCardsMessage =
    lang === 'CN' ? '' : 'I summarized the key results into structured cards below.';

  const looksLikeCardsBelowTemplate = (() => {
    const raw = String(t || '').trim();
    if (!raw) return false;
    const lower = raw.toLowerCase();

    // EN: "cards below" style.
    if (/\bcards?\s+below\b/.test(lower)) return true;
    if (/\bstructured\s+cards?\s+below\b/.test(lower)) return true;
    if (/\bsee\s+(the\s+)?(structured\s+)?cards?\s+below\b/.test(lower)) return true;
    if (/\bsee\s+the\s+card\s+below\b/.test(lower)) return true;

    // CN: "/".
    if (//.test(raw)) return true;
    if (/.*(|)\b/.test(raw)) return true;
    if (/(|).*.*(|)/.test(raw)) return true;
    return false;
  })();

  if (looksLikeCardsBelowTemplate) {
    return hasRenderableCards ? hasRenderableCardsMessage : noRenderableCardsMessage;
  }

  // If we provide renderable cards, keep assistant_message concise and avoid confusing
  // "templated" multi-part essays (often redundant with the cards).
  //
  // IMPORTANT: do not reference "cards below" unless we are confident the UI will
  // actually render at least one card (e.g. structured citations, env_stress, recos).
  const looksLikeOverlongTemplate =
    t.length > 600 &&
    (/\bpart\s*\d+\s*:/i.test(t) ||
      /\b(budget analysis|am\s*\(|pm\s*\(|am\s*:|pm\s*:)\b/i.test(t) ||
      /(^|\n)#+\s*(am|pm|budget|safety)\b/i.test(t));
  if (looksLikeOverlongTemplate) {
    if (hasRenderableCards) {
      return hasRenderableCardsMessage;
    }
    return noRenderableCardsMessage;
  }

  if (!looksLikeJsonOrCode(t)) return t;

  if (lang === 'CN') {
    return hasRenderableCards ? '' : '';
  }
  return hasRenderableCards ? 'I formatted the result into structured cards below.' : 'Got it.';
}

const REGION_TO_TIMEZONE = {
  CN: 'Asia/Shanghai',
  HK: 'Asia/Hong_Kong',
  TW: 'Asia/Taipei',
  JP: 'Asia/Tokyo',
  KR: 'Asia/Seoul',
  SG: 'Asia/Singapore',
  UK: 'Europe/London',
  EU: 'Europe/Berlin',
  US: 'America/Los_Angeles',
};

function guessTimeZoneForChat({ profile, language } = {}) {
  const regionRaw = profile && typeof profile.region === 'string' ? profile.region.trim().toUpperCase() : '';
  if (regionRaw && REGION_TO_TIMEZONE[regionRaw]) return REGION_TO_TIMEZONE[regionRaw];

  // Conservative fallback: if language is CN and region is missing, assume CN timezone
  // (better UX for most CN users; avoids relying on server locale).
  if (language === 'CN') return REGION_TO_TIMEZONE.CN;
  return null;
}

function hourInTimeZone(now, timeZone) {
  if (!now || !(now instanceof Date)) return null;
  if (!timeZone) return null;
  try {
    const parts = new Intl.DateTimeFormat('en-US', { timeZone, hour: '2-digit', hour12: false }).formatToParts(now);
    const hourStr = parts.find((p) => p && p.type === 'hour')?.value;
    const hour = Number(hourStr);
    return Number.isFinite(hour) ? hour : null;
  } catch {
    return null;
  }
}

function timeOfDayBucket(hour) {
  if (!Number.isFinite(hour)) return null;
  if (hour >= 5 && hour < 11) return 'morning';
  if (hour >= 11 && hour < 17) return 'afternoon';
  if (hour >= 17 && hour < 22) return 'evening';
  return 'night';
}

function detectLeadingGreetingLanguage(text) {
  const raw = String(text || '').trim();
  if (!raw) return null;
  const head = raw.slice(0, 80);
  const lower = head.toLowerCase();

  if (/^(hi|hello|hey|good\s+(morning|afternoon|evening)|morning|evening)\b/i.test(lower)) return 'EN';
  if (/^(||||(|)?||||)/.test(head)) return 'CN';
  return null;
}

function stripMismatchedLeadingGreeting(text, { language } = {}) {
  const raw = typeof text === 'string' ? text : '';
  if (!raw.trim()) return raw;
  const expected = language === 'CN' ? 'CN' : 'EN';
  const lines = raw.split(/\r?\n/);
  if (!lines.length) return raw;
  const firstLine = String(lines[0] || '').trim();
  const detected = detectLeadingGreetingLanguage(firstLine);
  if (!detected || detected === expected) return raw;
  const rest = lines.slice(1).join('\n').replace(/^\s+/, '');
  return rest || raw;
}

function looksLikeGreetingAlready(text, { language } = {}) {
  const detected = detectLeadingGreetingLanguage(text);
  if (!detected) return false;
  if (!language) return true;
  return detected === (language === 'CN' ? 'CN' : 'EN');
}

function stableHashInt(input) {
  const s = String(input == null ? '' : input);
  let hash = 2166136261;
  for (let i = 0; i < s.length; i += 1) {
    hash ^= s.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

const EMOTIONAL_PREAMBLE_OPTIONS = {
  CN: {
    fallback: [
      '',
      '',
      '',
    ],
    morning: [
      '',
      '',
      '',
    ],
    afternoon: [
      '',
      '',
      '',
    ],
    evening: [
      '',
      '',
      '',
    ],
    night: [
      '',
      '',
      '',
    ],
  },
  EN: {
    fallback: [
      'Got it  Ill keep it clear and practical.',
      'Absolutely  lets make this simple and actionable.',
      'Sounds good  well take this step by step.',
    ],
    morning: [
      'Good morning  lets keep your routine easy and steady today.',
      'Good morning  well focus on the highest-impact steps first.',
      'Good morning  Ill keep this practical and skin-friendly.',
    ],
    afternoon: [
      'Good afternoon  quick, clear, and practical steps coming up.',
      'Good afternoon  we can keep this efficient and smooth.',
      'Good afternoon  Ill help you lock in a plan thats easy to follow.',
    ],
    evening: [
      'Good evening  youve done enough today; lets make this easy.',
      'Good evening  well keep things calm, clear, and realistic.',
      'Good evening  Ill help you finish today with an easy routine.',
    ],
    night: [
      'Late-night check-in  Ill keep this short so you can rest.',
      'Its late  lets keep this concise and soothing for your skin.',
      'Quick night plan: simple steps now, better skin tomorrow.',
    ],
  },
};

function normalizePreambleLine(text) {
  return String(text || '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, ' ');
}

function buildKnownPreambleSetByLang() {
  const out = { CN: new Set(), EN: new Set() };
  for (const lang of ['CN', 'EN']) {
    const choices = EMOTIONAL_PREAMBLE_OPTIONS[lang] || {};
    for (const key of Object.keys(choices)) {
      const arr = Array.isArray(choices[key]) ? choices[key] : [];
      for (const line of arr) {
        const normalized = normalizePreambleLine(line);
        if (normalized) out[lang].add(normalized);
      }
    }
  }
  return out;
}

const KNOWN_EMOTIONAL_PREAMBLE_SET = buildKnownPreambleSetByLang();

function hasKnownEmotionalPreamble(text, lang) {
  const lines = String(text || '').split(/\r?\n/);
  for (const line of lines) {
    const normalized = normalizePreambleLine(line);
    if (!normalized) continue;
    const set = KNOWN_EMOTIONAL_PREAMBLE_SET[lang === 'CN' ? 'CN' : 'EN'];
    if (set && set.has(normalized)) return true;
    break;
  }
  return false;
}

function pickPreambleVariant(options, { seed, language, bucket }) {
  const list = Array.isArray(options) ? options.filter((s) => typeof s === 'string' && s.trim()) : [];
  if (!list.length) return '';
  if (list.length === 1) return list[0];
  const index = stableHashInt(`${language || 'EN'}|${bucket || 'fallback'}|${seed || ''}`) % list.length;
  return list[index];
}

function buildEmotionalPreamble({ language, profile, now, seed } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const timeZone = guessTimeZoneForChat({ profile, language: lang });
  const hour = hourInTimeZone(now, timeZone);
  const bucket = timeOfDayBucket(hour);
  const choices = EMOTIONAL_PREAMBLE_OPTIONS[lang] || EMOTIONAL_PREAMBLE_OPTIONS.EN;
  const key = bucket || 'fallback';
  const selected = pickPreambleVariant(choices[key], { seed, language: lang, bucket: key });
  if (selected) return selected;

  const fallback = pickPreambleVariant(choices.fallback, { seed, language: lang, bucket: 'fallback' });
  return fallback || (lang === 'CN' ? '' : 'Got it  Ill keep it clear and practical.');
}

function addEmotionalPreambleToAssistantText(text, { language, profile, seed } = {}) {
  const raw = typeof text === 'string' ? text : '';
  if (!raw.trim()) return raw;
  const lang = language === 'CN' ? 'CN' : 'EN';
  const normalized = stripMismatchedLeadingGreeting(raw, { language: lang });
  if (
    looksLikeGreetingAlready(normalized, { language: lang }) ||
    hasKnownEmotionalPreamble(normalized, lang)
  ) {
    return normalized;
  }

  const pre = buildEmotionalPreamble({ language: lang, profile, now: new Date(), seed });
  if (!pre || !String(pre).trim()) return raw;

  const maxPreLen = lang === 'CN' ? 44 : 120;
  const safePre = String(pre).trim().slice(0, maxPreLen);
  return `${safePre}\n\n${normalized}`;
}

const CHATBOX_UI_RENDERABLE_CARD_TYPES = new Set([
  'recommendations',
  'product_analysis',
  'env_stress',
  'routine_simulation',
  'conflict_heatmap',
  'analysis_summary',
  'diagnosis_gate',
]);

const CHATBOX_UI_HIDDEN_CARD_TYPES = new Set(['gate_notice', 'session_bootstrap', 'budget_gate', 'aurora_context_raw']);

function isRenderableCardForChatboxUi(card, { debug } = {}) {
  if (!card || typeof card !== 'object') return false;
  const type = String(card.type || '').trim().toLowerCase();
  if (!type) return false;
  if (debug) return true;
  if (type === 'aurora_structured') return false; // Renderability depends on citations; handled separately.
  if (CHATBOX_UI_HIDDEN_CARD_TYPES.has(type)) return false;
  return CHATBOX_UI_RENDERABLE_CARD_TYPES.has(type);
}

function structuredLooksLikeParseOnlyStub(value) {
  if (!isPlainObject(value)) return false;
  const allowed = new Set(['schema_version', 'parse', 'conflicts']);
  const keys = Object.keys(value || {}).filter((k) => value[k] != null);
  if (keys.length === 0) return false;
  // Require parse to exist; otherwise this could be any partial structured payload.
  if (!('parse' in value)) return false;
  return keys.every((k) => allowed.has(k));
}

function extractProductInputFromFitCheckText(message) {
  const raw = String(message || '').trim();
  if (!raw) return '';

  // Remove internal test markers if they leaked into user input.
  let t = raw
    .replace(/STRUCTURED_STUB_ONLY_TEST/gi, '')
    .replace(/SHORT_CARDS_BELOW_STUB_TEST/gi, '')
    .replace(/SHORT_CARDS_BELOW_STRIPPED_RECO_TEST/gi, '')
    .replace(/NON_GENERIC_STUB_TEST/gi, '')
    .trim();

  // Prefer suffix after the last ":" / "" (common pattern: "Evaluate: <name>").
  const m = t.match(/[:]\s*([^:]{2,400})\s*$/);
  if (m && m[1]) t = String(m[1]).trim();

  // Strip leading intent phrases; keep the product token(s).
  t = t.replace(
    /^(|||||||)?\s*(|||||check|evaluate|analyze)\s*(||||)?\s*(||serum|product)?\s*(|||||||suitable|safe|okay)?\s*/i,
    '',
  ).trim();

  // If it still looks like a full sentence, keep the tail (often where the product appears).
  if (t.length > 160) t = t.slice(-160).trim();
  return t;
}

function looksLikeProductEvaluationIntentV2(message, actionId) {
  const raw = String(message || '').trim();
  const lower = raw.toLowerCase();
  const action = String(actionId || '').trim().toLowerCase();

  if (
    action === 'chip.action.analyze_product' ||
    action === 'chip_action_analyze_product' ||
    action.includes('evaluate') ||
    action.includes('fit_check') ||
    action.includes('fit-check') ||
    action.includes('product_analysis')
  ) {
    return true;
  }

  if (looksLikeSuitabilityRequest(raw)) return true;

  const recommendationOnlySignal =
    (/\b(recommend|suggest|recommendation)\b/.test(lower) || /(||.*)/.test(raw)) &&
    !/\b(evaluate|evaluation|assess|assessment|analy[sz]e|check|review)\b/.test(lower) &&
    !/(||||||)/.test(raw);
  if (recommendationOnlySignal) return false;

  const enEvaluate =
    /\b(evaluate|evaluation|assess|assessment|analy[sz]e)\b.{0,32}\b(product|this|it)\b/.test(lower) ||
    /\b(check|review)\b.{0,24}\b(this|the)\b.{0,16}\bproduct\b/.test(lower);
  const cnEvaluate =
    /(|||||).{0,20}(||||)/.test(raw) ||
    /(||).{0,20}(||)/.test(raw);
  return enEvaluate || cnEvaluate;
}

const FIT_CHECK_ANCHOR_STOPWORDS = new Set([
  'a',
  'an',
  'the',
  'this',
  'that',
  'it',
  'product',
  'specific',
  'for',
  'me',
  'evaluate',
  'evaluation',
  'assess',
  'assessment',
  'analyze',
  'analyse',
  'check',
  'review',
  'send',
  'link',
  'url',
  'name',
  'please',
  'do',
  'you',
  'have',
]);

function isMeaningfulFitCheckProductInput(value) {
  const raw = String(value || '').trim();
  if (!raw) return false;
  if (/^https?:\/\//i.test(raw)) return true;

  const lower = raw.toLowerCase();
  if (
    /^(this|that|it|product|the product|a product|specific product|evaluate (?:a )?specific product(?: for me)?|evaluate (?:a )?product(?: for me)?|check (?:a )?product|analy[sz]e (?:a )?product|send (?:a )?(?:link|url|product name)|link|url|product name|name)$/i
      .test(lower) ||
    /^(|||||||||||)$/.test(raw)
  ) {
    return false;
  }

  const normalized = lower
    .replace(/[^a-z0-9\u4e00-\u9fff]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  if (!normalized) return false;

  const hasCjk = /[\u4e00-\u9fff]/.test(normalized);
  if (hasCjk && normalized.length >= 2) return true;

  const tokens = normalized.split(' ').filter(Boolean);
  if (!tokens.length) return false;
  const informativeTokens = tokens.filter((token) => !FIT_CHECK_ANCHOR_STOPWORDS.has(token));
  if (informativeTokens.length >= 2) return true;
  if (informativeTokens.length >= 1 && /[0-9]/.test(informativeTokens[0])) return true;
  if (tokens.some((token) => /[0-9]/.test(token)) && informativeTokens.length >= 1) return true;
  return false;
}

function hasMeaningfulFitCheckAnchor({ message, anchorProductId, anchorProductUrl } = {}) {
  if (String(anchorProductId || '').trim()) return true;
  if (String(anchorProductUrl || '').trim()) return true;
  const parsed = extractProductInputFromFitCheckText(message);
  return isMeaningfulFitCheckProductInput(parsed);
}

function buildFitCheckAnchorPrompt(language) {
  const isCn = String(language || '').toUpperCase() === 'CN';
  return {
    prompt: isCn
      ? ''
      : 'I can evaluate it right away, but I need one anchor first: send the product name or a product link.',
    chips: [
      {
        chip_id: 'chip.fitcheck.send_product_name',
        label: isCn ? '' : 'Send product name',
        kind: 'quick_reply',
        data: { reply_text: isCn ? '' : 'Send product name' },
      },
      {
        chip_id: 'chip.fitcheck.send_link',
        label: isCn ? '' : 'Send a link',
        kind: 'quick_reply',
        data: { reply_text: isCn ? '' : 'Send a link' },
      },
    ],
  };
}

function isPlainObject(value) {
  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}

function asStringArray(value, max = 8) {
  const out = [];
  const seen = new Set();
  for (const raw of Array.isArray(value) ? value : []) {
    const s = typeof raw === 'string' ? raw.trim() : raw == null ? '' : String(raw).trim();
    if (!s) continue;
    const key = s.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(s);
    if (out.length >= max) break;
  }
  return out;
}

function hasAnyToken(text, tokens) {
  const haystack = String(text || '').toLowerCase();
  return (Array.isArray(tokens) ? tokens : []).some((t) => haystack.includes(String(t || '').toLowerCase()));
}

const ROUTE_SECTION_HINTS = {
  'fit-check': [
    ['', 'Verdict:'],
    ['', 'Risk points:'],
    ['', 'Safer alternatives:'],
    ['//', 'How to use (frequency/order/timeline):'],
    ['', 'Stop signals:'],
  ],
  reco: [
    ['', 'Goal & context:'],
    ['/', 'Minimum viable routine (AM/PM):'],
    ['Top 3', 'Ingredient directions (Top 3):'],
    ['', 'One-week onboarding plan:'],
    ['', 'Buying criteria (how to choose):'],
    ['', 'Red flags:'],
  ],
  conflict: [
    ['', 'Conflict reason:'],
    ['', 'Safer schedule (alternate use):'],
    ['', 'Priority choices:'],
    ['', 'Stop signals:'],
  ],
  env: [
    ['', 'Environment check:'],
    [' /  / ', 'Add / remove / replace:'],
    ['', 'Frequency adjustment:'],
    ['', 'Temporary minimal plan:'],
    ['/', 'Sun/moisture strategy:'],
  ],
};

function isRouteStructuredAnswer(text, route) {
  const checks = ROUTE_SECTION_HINTS[String(route || '').trim()];
  if (!checks || !checks.length) return true;
  return checks.every((tokens) => hasAnyToken(text, tokens));
}

function looksLikeGenericStructuredNotice(text) {
  const raw = String(text || '').trim();
  if (!raw) return true;
  const lower = raw.toLowerCase();
  return (
    lower.includes('structured cards below') ||
    lower.includes('i did not receive any renderable structured cards') ||
    lower.includes('only a parse/summary stub') ||
    raw.includes('') ||
    raw.includes('') ||
    raw.includes('/')
  );
}

function getCardPayload(card) {
  if (!card || typeof card !== 'object') return null;
  if (isPlainObject(card.payload)) return card.payload;
  return isPlainObject(card) ? card : null;
}

function inferRouteFromCards(cards) {
  const list = Array.isArray(cards) ? cards.filter((c) => c && typeof c === 'object') : [];
  const byType = new Map();
  for (const c of list) {
    const type = String(c.type || '').trim();
    if (!type) continue;
    if (!byType.has(type)) byType.set(type, c);
  }

  if (byType.has('routine_simulation') || byType.has('conflict_heatmap')) {
    const card = byType.get('routine_simulation') || byType.get('conflict_heatmap');
    return { route: 'conflict', payload: getCardPayload(card) };
  }
  if (byType.has('env_stress')) {
    return { route: 'env', payload: getCardPayload(byType.get('env_stress')) };
  }
  if (byType.has('product_analysis')) {
    return { route: 'fit-check', payload: getCardPayload(byType.get('product_analysis')) };
  }
  if (byType.has('recommendations')) {
    return { route: 'reco', payload: getCardPayload(byType.get('recommendations')) };
  }
  return null;
}

function inferRouteFromMessageIntent(message, { allowRecoCards } = {}) {
  if (looksLikeCompatibilityOrConflictQuestion(message)) return { route: 'conflict', payload: {} };
  if (looksLikeWeatherOrEnvironmentQuestion(message)) return { route: 'env', payload: {} };
  if (looksLikeSuitabilityRequest(message)) return { route: 'fit-check', payload: {} };
  if (allowRecoCards && looksLikeRecommendationRequest(message)) return { route: 'reco', payload: {} };
  return null;
}

function resolveRouteHint(fromCards, fromMessage) {
  const cardRoute = String(fromCards?.route || '').trim();
  const messageRoute = String(fromMessage?.route || '').trim();
  if (!cardRoute) return fromMessage || null;
  if (!messageRoute) return fromCards || null;

  const explicitMessageRoutes = new Set(['fit-check', 'conflict', 'env']);
  if (explicitMessageRoutes.has(messageRoute)) {
    if (cardRoute === 'reco') return fromMessage;
    if (cardRoute === messageRoute) return fromCards;
  }
  return fromCards;
}

function summarizeProfileForAnswer(profile, lang) {
  const p = isPlainObject(profile) ? profile : {};
  const skinType = typeof p.skinType === 'string' ? p.skinType.trim() : '';
  const sensitivity = typeof p.sensitivity === 'string' ? p.sensitivity.trim() : '';
  const barrier = typeof p.barrierStatus === 'string' ? p.barrierStatus.trim() : '';
  const goals = asStringArray(p.goals, 4);
  if (lang === 'CN') {
    const left = [skinType || '', sensitivity ? `${sensitivity}` : '', barrier || ''];
    const goalText = goals.length ? `${goals.join('')}` : '';
    return `${left.join(' / ')}${goalText}`;
  }
  const left = [skinType || 'skin type pending', sensitivity ? `${sensitivity} sensitivity` : 'sensitivity pending', barrier || 'barrier pending'];
  const goalText = goals.length ? `Goals: ${goals.join(', ')}` : 'Goals: pending';
  return `${left.join(' / ')}; ${goalText}.`;
}

function pickRecoNames(payload, max = 3) {
  const recos = Array.isArray(payload && payload.recommendations) ? payload.recommendations : [];
  const out = [];
  const seen = new Set();
  for (const r of recos) {
    if (!r || typeof r !== 'object') continue;
    const sku = isPlainObject(r.sku) ? r.sku : isPlainObject(r.product) ? r.product : null;
    const brand = typeof sku?.brand === 'string' ? sku.brand.trim() : '';
    const name = typeof sku?.name === 'string' ? sku.name.trim() : '';
    const title = [brand, name].filter(Boolean).join(' ').trim() || (typeof r.title === 'string' ? r.title.trim() : '');
    if (!title) continue;
    const key = title.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(title);
    if (out.length >= max) break;
  }
  return out;
}

function buildRouteAwareAssistantText({ route, payload, language, profile }) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const p = isPlainObject(payload) ? payload : {};
  const profileLine = summarizeProfileForAnswer(profile, lang);

  if (route === 'fit-check') {
    const assessment = isPlainObject(p.assessment) ? p.assessment : {};
    const verdict = String(assessment.verdict || '').trim() || (lang === 'CN' ? '' : 'Cautious to try');
    const reasons = asStringArray(assessment.reasons, 6);
    const riskLines = reasons.filter((r) => /||||risk|irritat|sting|burn/i.test(r));
    const fitLines = reasons.filter((r) => !riskLines.includes(r));
    const risk = (riskLines.length ? riskLines : reasons).slice(0, 2);
    const fit = (fitLines.length ? fitLines : reasons).slice(0, 2);

    if (lang === 'CN') {
      return [
        `${verdict}`,
        `${profileLine}`,
        '',
        ...(risk.length ? risk.map((r) => `- ${r}`) : ['- /']),
        '',
        ...(fit.length ? fit.map((r) => `- ${r}`) : ['- ']),
        '//',
        '-  2-3  2-4 ',
        '- SPF30+/',
        ' 3-5 ',
      ].join('\n');
    }

    return [
      `Verdict: ${verdict} (start cautiously, then scale only if tolerated).`,
      `Your profile: ${profileLine}`,
      'Risk points:',
      ...(risk.length ? risk.map((r) => `- ${r}`) : ['- If stinging/peeling is active, reduce frequency and prioritize barrier repair.']),
      'Safer alternatives:',
      ...(fit.length ? fit.map((r) => `- Consider: ${r}`) : ['- Prefer low-irritation, simple, fragrance-free options first.']),
      'How to use (frequency/order/timeline):',
      '- Start at 2-3 nights/week; reassess after 2-4 weeks before increasing.',
      '- Use sunscreen every morning (SPF30+), and avoid stacking multiple strong actives in one night.',
      'Stop signals: pause if persistent stinging/redness/peeling, switch to barrier repair only, and seek dermatology care if worsening.',
    ].join('\n');
  }

  if (route === 'reco') {
    const names = pickRecoNames(p, 3);
    const topNames = names.length ? names : [lang === 'CN' ? '' : 'gentle barrier-support serum'];
    if (lang === 'CN') {
      return [
        `${profileLine}`,
        '/',
        '- AM  / ',
        '- PM   ',
        'Top 3',
        `-  1/`,
        `-  2/`,
        `-  3//`,
        `${topNames.join('')}`,
        '',
        '-  1-3 ++',
        '-  4-7  2-3 ',
        '-  2-4 //',
        '',
        '- ',
        '- ',
        '',
        '-  3-5 ',
      ].join('\n');
    }

    return [
      `Goal & context: ${profileLine}`,
      'Minimum viable routine (AM/PM):',
      '- AM: gentle cleanse  treatment/hydration  sunscreen.',
      '- PM: gentle cleanse  one core active (low frequency)  barrier moisturizer.',
      'Ingredient directions (Top 3):',
      '- Direction 1: niacinamide/ceramide for brightening + barrier support.',
      '- Direction 2: azelaic-acid-friendly, low-irritation anti-redness path.',
      '- Direction 3: hydration-soothing base (glycerin/HA/squalane).',
      `Sample options to review first: ${topNames.join(', ')}.`,
      'One-week onboarding plan:',
      '- Days 1-3: keep only cleanse + moisturizer + sunscreen to stabilize tolerance.',
      '- Days 4-7: introduce one active at 2-3 nights/week; keep recovery nights in between.',
      '- Reassess after 2-4 weeks and scale only if skin stays stable.',
      'Buying criteria (how to choose):',
      '- Look for low-irritation, simple formulas and one clear active aligned to your goal.',
      '- Prioritize tolerability and consistency before stacking more products.',
      'Red flags:',
      '- Pause new actives if persistent stinging/redness/peeling appears; switch to barrier repair and seek care if worsening.',
    ].join('\n');
  }

  if (route === 'conflict') {
    const conflicts = Array.isArray(p.conflicts) ? p.conflicts : [];
    const safe = Boolean(p.safe);
    const conflictMessages = asStringArray(conflicts.map((c) => (isPlainObject(c) ? c.message : null)), 3);
    if (lang === 'CN') {
      return [
        safe ? '' : '',
        '',
        ...(conflictMessages.length
          ? conflictMessages.map((m) => `- ${m}`)
          : ['- /']),
        '',
        '- AM    ',
        '- PM A  B / A/ B',
        '-  2-3 ',
        '',
        '-  2-4 ',
        '- ',
        '',
      ].join('\n');
    }

    return [
      safe ? 'Conflict check: no major conflict detected right now.' : 'Conflict check: potential active-stacking risk detected.',
      'Conflict reason:',
      ...(conflictMessages.length
        ? conflictMessages.map((m) => `- ${m}`)
        : ['- Layering strong actives in the same night can increase irritation and reduce tolerance.']),
      'Safer schedule (alternate use):',
      '- AM: gentle cleanse  moisturizer  sunscreen.',
      '- PM: alternate active A and active B on different nights; keep recovery nights between them.',
      '- Start at 2-3 active nights/week, then increase only after stable tolerance.',
      'Priority choices:',
      '- Keep one core active first for 2-4 weeks before adding a second active.',
      '- Prioritize lower stacking load before increasing concentration.',
      'Stop signals: pause new actives if persistent stinging/redness/peeling appears; switch to barrier repair only and seek care if worsening.',
    ].join('\n');
  }

  if (route === 'env') {
    const tier = typeof p.tier === 'string' ? p.tier.trim() : '';
    const ess = Number.isFinite(Number(p.ess)) ? Number(p.ess) : null;
    const notes = asStringArray(p.notes, 3);
    if (lang === 'CN') {
      return [
        ` ${tier || ''}${ess != null ? `ESS ${Math.round(ess)}` : ''}`,
        notes.length ? `${notes.join('')}` : '',
        ' /  / ',
        '- ',
        '- ',
        '- ',
        '',
        '-  2-3 ',
        '-  3-7 ',
        '',
        '-  + ',
        '/',
        '-  SPF30+ ',
      ].join('\n');
    }

    return [
      `Environment check: stress level is ${tier || 'pending'}${ess != null ? ` (ESS ${Math.round(ess)})` : ''}.`,
      notes.length ? `Context clues: ${notes.join('; ')}` : 'Context clues: keep adjustments conservative while conditions shift.',
      'Add / remove / replace:',
      '- Add: barrier-support hydration and soothing layers.',
      '- Remove: same-night multi-active stacking and frequent strong exfoliation.',
      '- Replace: high-irritation steps with lower-frequency, gentler options.',
      'Frequency adjustment:',
      '- Reduce actives to 2-3 nights/week; keep recovery-focused nights in between.',
      '- Stabilize for 3-7 days during weather swings before ramping back up.',
      'Temporary minimal plan:',
      '- Keep cleanse + barrier moisturizer AM/PM, and hold high-irritation actives during unstable weather days.',
      'Sun/moisture strategy:',
      '- Keep daily SPF30+ and reapply as needed; increase moisturizer support in dry indoor air.',
    ].join('\n');
  }

  return '';
}

function coerceNumber(value) {
  if (value == null) return null;
  if (typeof value === 'number') return Number.isFinite(value) ? value : null;
  if (typeof value === 'string') {
    const n = Number(value);
    return Number.isFinite(n) ? n : null;
  }
  return null;
}

function clamp0to100(value) {
  if (!Number.isFinite(value)) return 0;
  return Math.max(0, Math.min(100, value));
}

function titleCase(value) {
  const t = String(value || '').trim();
  if (!t) return t;
  return t.charAt(0).toUpperCase() + t.slice(1);
}

function buildEnvStressUiModelFromUpstream(value, { language } = {}) {
  if (!isPlainObject(value)) return null;
  const schema = typeof value.schema_version === 'string' ? value.schema_version : '';

  if (schema === 'aurora.ui.env_stress.v1') return value;
  if (schema !== 'aurora.env_stress.v1') return null;

  const essRaw = coerceNumber(value.ess);
  const ess = essRaw == null ? null : clamp0to100(essRaw);
  const tier = typeof value.tier === 'string' ? value.tier.trim() || null : null;

  const contributors = Array.isArray(value.contributors) ? value.contributors : [];
  const weights = contributors.map((c) => {
    if (!isPlainObject(c)) return null;
    const w = coerceNumber(c.weight);
    return w == null || w < 0 ? null : w;
  });

  const weightSum = weights.reduce((acc, w) => acc + (w ?? 0), 0);
  const denom = weightSum > 0 ? weightSum : contributors.length;

  const radar = [];
  for (let i = 0; i < contributors.length; i += 1) {
    const c = contributors[i];
    if (!isPlainObject(c)) continue;
    const axisRaw = typeof c.key === 'string' ? c.key.trim() : '';
    if (!axisRaw) continue;
    const w = weightSum > 0 ? (weights[i] ?? 0) / denom : 1 / denom;
    const v = ess == null ? 0 : clamp0to100(Math.round(ess * w));
    radar.push({ axis: titleCase(axisRaw).slice(0, 40), value: v });
    if (radar.length >= 8) break;
  }

  const notes = [];
  const missing = Array.isArray(value.missing_inputs) ? value.missing_inputs : [];
  const missingFlat = missing.map((m) => String(m || '').trim()).filter(Boolean);
  if (missingFlat.length) {
    notes.push(
      language === 'CN'
        ? `${missingFlat.slice(0, 4).join(' / ')}`
        : `Missing: ${missingFlat.slice(0, 4).join(' / ')}`,
    );
  }

  for (const c of contributors) {
    if (!isPlainObject(c)) continue;
    const note = typeof c.note === 'string' ? c.note.trim() : '';
    if (!note) continue;
    notes.push(note.slice(0, 220));
    if (notes.length >= 4) break;
  }

  return {
    schema_version: 'aurora.ui.env_stress.v1',
    ess,
    tier,
    radar,
    notes,
  };
}

function looksLikeWeatherOrEnvironmentQuestion(message) {
  const t = String(message || '').trim();
  if (!t) return false;

  const lower = t.toLowerCase();

  // English
  if (
    /\b(snow|rain|weather|humidity|uv|climate|wind|dry air|cold|heat|sun exposure|travel|itinerary|destination|flight|ski)\b/i.test(
      lower,
    )
  )
    return true;

  // Chinese (keep focused on environment, not general skin symptoms)
  if (
    /(|||||||||UV|||||||(|)?|||||||||||)/.test(
      t,
    )
  )
    return true;

  return false;
}

function extractWeatherScenario(message) {
  const t = String(message || '').trim();
  if (!t) return 'unknown';
  const lower = t.toLowerCase();

  if (/(||)/.test(t) || /\bsnow|ski\b/i.test(lower)) return 'snow';
  if (/(||)/.test(t) || /\brain|storm\b/i.test(lower)) return 'rain';
  if (/(|UV|||)/.test(t) || /\buv|sun|sunlight\b/i.test(lower)) return 'uv';
  if (/(||)/.test(t) || /\bhumid|humidity\b/i.test(lower)) return 'humid';
  if (/(||)/.test(t) || /\bdry air|dry|dehydrating\b/i.test(lower)) return 'dry';
  if (/(||)/.test(t) || /\bcold|freez(e|ing)\b/i.test(lower)) return 'cold';
  if (/(|||)/.test(t) || /\bwind|windy\b/i.test(lower)) return 'wind';
  if (/(|||||)/.test(t) || /\btravel|flight|itinerary|destination\b/i.test(lower)) return 'travel';
  return 'unknown';
}

function extractKnownActivesFromText(text) {
  const t = String(text || '').trim();
  if (!t) return [];
  const lower = t.toLowerCase();
  // Some CN inputs may contain spaces between characters (e.g. " ", " A").
  // Keep an additional whitespace-stripped view for conservative CN matching.
  const compact = t.replace(/\s+/g, '');
  const out = [];

  const push = (token) => {
    const key = String(token || '').trim().toLowerCase();
    if (!key) return;
    if (!out.includes(key)) out.push(key);
  };

  // NOTE: This is used for routing + local compatibility simulation. Keep it conservative but multilingual.
  // EN: tretinoin/adapalene/retinal/retinol/retinoid
  // CN:  / A()/A /  / / / A/A
  if (
    /(tretinoin|adapalene|retinal|retinol|retinoid)/i.test(lower) ||
    /(|a|a|a|||||a|a)/i.test(compact)
  ) {
    push('retinoid');
  }
  // Strong acids: BHA (salicylic) / AHA (glycolic/lactic/mandelic) / PHA.
  // CN:  / (//) / PHA()
  // Treat PHA as "aha" for conflict heuristics (retinoid_x_acids includes AHA/BHA/PHA).
  if (/(benzoyl\s*peroxide|bpo)/i.test(lower)) push('benzoyl_peroxide');
  if (/()/i.test(compact)) push('benzoyl_peroxide');
  if (/(salicylic|bha)/i.test(lower) || /()/i.test(compact)) push('bha');
  if (
    /(glycolic|lactic|mandelic|aha|pha|gluconolactone)/i.test(lower) ||
    /(|||||)/i.test(compact)
  ) {
    push('aha');
  }
  if (/(vitamin\s*c|ascorbic|l-ascorbic|ascorbate)/i.test(lower)) push('vitamin_c');
  if (/(c|c|)/i.test(compact)) push('vitamin_c');
  if (/(niacinamide)/i.test(lower) || /()/i.test(compact)) push('niacinamide');
  if (/(azelaic)/i.test(lower) || /()/i.test(compact)) push('azelaic_acid');
  if (/(tranexamic)/i.test(lower) || /(|)/i.test(compact)) push('tranexamic_acid');

  return out;
}

function collectKnownActivesFromRoutine(routine) {
  const routineObj = routine && typeof routine === 'object' ? routine : {};
  const am = Array.isArray(routineObj.am) ? routineObj.am : [];
  const pm = Array.isArray(routineObj.pm) ? routineObj.pm : [];
  const out = [];
  const seen = new Set();

  const push = (token) => {
    const key = String(token || '').trim().toLowerCase();
    if (!key) return;
    if (seen.has(key)) return;
    seen.add(key);
    out.push(key);
  };

  const scanText = (raw) => {
    const tokens = extractKnownActivesFromText(String(raw || ''));
    for (const t of tokens) push(t);
  };

  const scanItem = (item) => {
    if (!item) return;
    if (typeof item === 'string') {
      scanText(item);
      return;
    }
    if (typeof item !== 'object' || Array.isArray(item)) return;

    const actives = item.key_actives || item.keyActives || item.actives;
    if (Array.isArray(actives)) {
      for (const a of actives) scanText(a);
    }

    const fields = [
      item.step,
      item.category,
      item.slot_step,
      item.slotStep,
      item.title,
      item.name,
      item.display_name,
      item.displayName,
      item.product,
    ];
    for (const f of fields) {
      if (typeof f === 'string' && f.trim()) scanText(f);
    }
  };

  for (const item of am) scanItem(item);
  for (const item of pm) scanItem(item);

  return out;
}

function looksLikeCompatibilityOrConflictQuestion(message) {
  const t = String(message || '').trim();
  if (!t) return false;
  const lower = t.toLowerCase();

  const hasCompatVerbEn =
    /\b(conflict|conflicts|compatible|incompatible|pair|layer|stack|mix|combine|together|same routine|same night|can i add|should i add|with)\b/i.test(
      lower,
    );
  const hasCompatVerbZh = /(|||||||||)/.test(t);
  if (!(hasCompatVerbEn || hasCompatVerbZh)) return false;

  // Avoid triggering on generic conflict questions without any known skincare actives.
  const actives = extractKnownActivesFromText(t);
  return actives.length > 0;
}

function buildLocalCompatibilitySimulationInput({ message, profile } = {}) {
  const text = String(message || '').trim();
  if (!text) return null;

  const clauses = text
    .split(/[.?!\n]+/)
    .map((s) => s.trim())
    .filter(Boolean)
    .slice(0, 8);

  let routineText = '';
  let testText = '';
  for (const clause of clauses) {
    const lower = clause.toLowerCase();
    const isRoutineContextEn = /\b(my|i use|i'm using|currently|routine|am|pm|at night|morning)\b/i.test(lower);
    const isRoutineContextZh = /((||||)|()?(||routine)|)/.test(clause);
    const isTestContextEn = /\b(add|can i|layer|stack|mix|combine|together|with|conflict|compatible)\b/i.test(lower);
    const isTestContextZh = /(||||||||)/.test(clause);

    if (isRoutineContextEn || isRoutineContextZh) routineText = `${routineText} ${clause}`.trim();
    if (isTestContextEn || isTestContextZh) testText = `${testText} ${clause}`.trim();
  }

  const all = extractKnownActivesFromText(text);
  const routineActives = routineText ? extractKnownActivesFromText(routineText) : [];
  const testActives = testText ? extractKnownActivesFromText(testText) : [];

  const setEq = (a, b) => {
    const aa = new Set((a || []).map((v) => String(v).toLowerCase()));
    const bb = new Set((b || []).map((v) => String(v).toLowerCase()));
    if (aa.size !== bb.size) return false;
    for (const v of aa) if (!bb.has(v)) return false;
    return true;
  };

  let routineTokens = routineActives;
  let testTokens = testActives;

  if (!routineTokens.length || !testTokens.length || setEq(routineTokens, testTokens)) {
    const has = (tok) => all.includes(tok);
    if (has('retinoid') && (has('aha') || has('bha'))) {
      routineTokens = ['retinoid'];
      testTokens = [...new Set([...(has('aha') ? ['aha'] : []), ...(has('bha') ? ['bha'] : [])])];
    } else if (has('retinoid') && has('benzoyl_peroxide')) {
      routineTokens = ['retinoid'];
      testTokens = ['benzoyl_peroxide'];
    } else if (has('vitamin_c') && (has('aha') || has('bha'))) {
      routineTokens = ['vitamin_c'];
      testTokens = [...new Set([...(has('aha') ? ['aha'] : []), ...(has('bha') ? ['bha'] : [])])];
    } else if (all.length >= 2) {
      routineTokens = [all[0]];
      testTokens = [all[1]];
    } else {
      // If we cant confidently form a pair from text, dont short-circuit.
      return null;
    }
  }

  const routineFromProfile =
    profile &&
    profile.currentRoutine &&
    typeof profile.currentRoutine === 'object' &&
    !Array.isArray(profile.currentRoutine) &&
    (Array.isArray(profile.currentRoutine.am) || Array.isArray(profile.currentRoutine.pm))
      ? profile.currentRoutine
      : null;

  const profileRoutineActives = routineFromProfile ? collectKnownActivesFromRoutine(routineFromProfile) : [];
  const shouldUseProfileRoutine = Boolean(
    routineFromProfile && routineTokens.some((t) => profileRoutineActives.includes(String(t || '').toLowerCase())),
  );

  const routine = shouldUseProfileRoutine ? routineFromProfile : {
    am: [],
    pm: routineTokens.length ? [{ step: 'Treatment', key_actives: routineTokens }] : [],
  };

  const testProduct = {
    step: 'Add-on',
    name: testTokens.join(' + ') || 'Test product',
    key_actives: testTokens,
  };

  if (!Array.isArray(testProduct.key_actives) || testProduct.key_actives.length === 0) return null;

  return { routine, testProduct };
}

function buildEnvStressUiModelFromLocal({ profile, recentLogs, message, language } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';

  const barrier = String(profile && profile.barrierStatus ? profile.barrierStatus : '').trim().toLowerCase();
  const sensitivity = String(profile && profile.sensitivity ? profile.sensitivity : '').trim().toLowerCase();

  let ess = 35;
  if (barrier === 'impaired' || barrier === 'damaged') ess = 75;
  else if (barrier === 'healthy' || barrier === 'stable') ess = 20;
  else if (barrier) ess = 35;

  if (sensitivity === 'high' || sensitivity === 'sensitive') ess += 10;

  const scenario = extractWeatherScenario(message);
  const bumpMap = {
    snow: 18,
    cold: 15,
    wind: 12,
    dry: 15,
    uv: 15,
    rain: 8,
    humid: 8,
    travel: 12,
    unknown: 6,
  };
  ess += bumpMap[scenario] ?? 6;
  ess = clamp0to100(ess);

  const tier = ess <= 30 ? 'Low' : ess <= 60 ? 'Medium' : 'High';

  const barrierScore = barrier === 'impaired' || barrier === 'damaged' ? 80 : barrier === 'healthy' || barrier === 'stable' ? 20 : 40;
  const weatherScore = scenario === 'snow' || scenario === 'cold' || scenario === 'dry' || scenario === 'wind' ? 70 : scenario === 'rain' || scenario === 'humid' ? 45 : scenario === 'travel' ? 55 : 35;
  const uvScore = scenario === 'uv' || scenario === 'snow' ? 65 : 30;

  const radar = [
    { axis: 'Barrier', value: clamp0to100(barrierScore) },
    { axis: 'Weather', value: clamp0to100(weatherScore) },
    { axis: 'UV', value: clamp0to100(uvScore) },
  ];

  const missing = [];
  if (!String(profile && profile.sensitivity ? profile.sensitivity : '').trim()) missing.push('profile.sensitivity');
  if (!Array.isArray(recentLogs) || recentLogs.length === 0) missing.push('recent_logs');

  const notes = [];
  if (missing.length) {
    notes.push(lang === 'CN' ? `${missing.slice(0, 4).join(' / ')}` : `Missing: ${missing.slice(0, 4).join(' / ')}`);
  }
  if (barrier) notes.push(`barrier_status=${barrier}`.slice(0, 220));
  if (scenario && scenario !== 'unknown') notes.push((lang === 'CN' ? `${scenario}` : `Scenario: ${scenario} (inferred)`).slice(0, 220));

  return {
    schema_version: 'aurora.ui.env_stress.v1',
    ess,
    tier,
    radar,
    notes: notes.slice(0, 4),
  };
}

function buildWeatherAdviceMessage({ language, scenario, profile } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const skin = String(profile && profile.skinType ? profile.skinType : '').trim();

  const skinLine =
    skin && lang === 'CN'
      ? `${skin}`
      : skin && lang === 'EN'
        ? `Your skin type: ${skin}.`
        : '';

  if (lang === 'CN') {
    if (scenario === 'snow') {
      return [
        ' +  +  +  UV/',
        skinLine,
        '',
        '****',
        '1) ** + **//',
        '2) ****/ SPF30+',
        '3) ****//',
        '4) ****/',
        '5) ****A/A',
        '',
        '**/**',
        '- /',
        '- /',
        '- /',
        '-  SPF30+',
        '-  + ',
        '',
        ' AM/PM ',
      ]
        .filter(Boolean)
        .join('\n');
    }

    if (scenario === 'uv') {
      return [
        '//',
        skinLine,
        '',
        '****',
        '1)  SPF30+',
        '2) ',
        '3) //A',
      ]
        .filter(Boolean)
        .join('\n');
    }

    return [
      '/',
      skinLine,
      '',
      '****',
      '1) /',
      '2) //A',
      '3) ',
      '',
      '/',
    ]
      .filter(Boolean)
      .join('\n');
  }

  // EN
  if (scenario === 'snow') {
    return [
      'Snowy days usually stress skin via: cold + dry air + wind + higher UV exposure from snow reflection.',
      skinLine,
      '',
      '**Skincare priorities**',
      '1) **Moisturize + seal**: use a richer moisturizer; consider a thin occlusive layer on dry-prone areas.',
      '2) **Sunscreen**: SPF 30+ even on cloudy/snowy days. If youre outdoors on snow for longer, go higher and reapply.',
      '3) **Physical protection**: scarf/mask/hat for wind; gloves if hands crack easily.',
      '4) **Gentle cleanse**: avoid harsh cleansing or scrubs.',
      '5) **Reduce actives**: if you use retinoids/acids, avoid stacking them on the same nightsnowy weather increases irritation risk.',
      '',
      '**Product-type checklist**',
      '- Gentle cleanser',
      '- Barrier-support moisturizer',
      '- Occlusive (petrolatum/ointment) for dry spots',
      '- Broad-spectrum SPF 30+',
      '- Lip balm + hand cream',
      '',
      'Want me to adapt this into a simple AM/PM snow day routine for what you already use?',
    ]
      .filter(Boolean)
      .join('\n');
  }

  return [
    'Im treating this as a weather / environment stress question for skin.',
    skinLine,
    '',
    '**General guidance**',
    '1) Prioritize barrier support (moisturizer, gentle routine).',
    '2) If you feel stinging/flaking, reduce strong actives (acids/retinoids).',
    '3) Use sunscreen for outdoor exposure.',
  ]
    .filter(Boolean)
    .join('\n');
}

function mergeExternalVerificationIntoStructured(structured, contextRaw) {
  const s = isPlainObject(structured) ? structured : null;
  if (!s) return structured;

  const hasExt = isPlainObject(s.external_verification) || isPlainObject(s.externalVerification);
  if (hasExt) return structured;

  const ctx = isPlainObject(contextRaw) ? contextRaw : null;
  if (!ctx) return structured;

  const ext = isPlainObject(ctx.external_verification) ? ctx.external_verification : isPlainObject(ctx.externalVerification) ? ctx.externalVerification : null;
  if (!ext) return structured;

  return { ...s, external_verification: ext };
}

function buildProductInputText(inputObj, url) {
  if (typeof url === 'string' && url.trim()) return url.trim();
  const o = inputObj && typeof inputObj === 'object' && !Array.isArray(inputObj) ? inputObj : null;
  if (!o) return null;
  const brand = typeof o.brand === 'string' ? o.brand.trim() : '';
  const name = typeof o.name === 'string' ? o.name.trim() : '';
  const display = typeof o.display_name === 'string' ? o.display_name.trim() : typeof o.displayName === 'string' ? o.displayName.trim() : '';
  const sku = typeof o.sku_id === 'string' ? o.sku_id.trim() : typeof o.skuId === 'string' ? o.skuId.trim() : '';
  const pid = typeof o.product_id === 'string' ? o.product_id.trim() : typeof o.productId === 'string' ? o.productId.trim() : '';
  const bestName = display || name;
  if (brand && bestName) return joinBrandAndName(brand, bestName);
  if (bestName) return bestName;
  if (sku) return sku;
  if (pid) return pid;
  return null;
}

function pickFirstTrimmed(...values) {
  for (const raw of values) {
    const s = typeof raw === 'string' ? raw.trim() : '';
    if (s) return s;
  }
  return '';
}

function joinBrandAndName(brandRaw, nameRaw) {
  const brand = String(brandRaw || '').trim();
  const name = String(nameRaw || '').trim();
  if (!brand) return name;
  if (!name) return brand;
  const brandLower = brand.toLowerCase();
  const nameLower = name.toLowerCase();
  if (nameLower === brandLower || nameLower.startsWith(`${brandLower} `)) return name;
  return `${brand} ${name}`.trim();
}

function isUuidLikeString(value) {
  return typeof value === 'string' && /^[0-9a-f]{8}(?:-[0-9a-f]{4}){3}-[0-9a-f]{12}$/i.test(String(value || '').trim());
}

function normalizeCanonicalProductRef(input, { requireMerchant = true, allowOpaqueProductId = true } = {}) {
  const ref = input && typeof input === 'object' && !Array.isArray(input) ? input : null;
  if (!ref) return null;
  const productId = pickFirstTrimmed(ref.product_id, ref.productId);
  const merchantId = pickFirstTrimmed(ref.merchant_id, ref.merchantId);
  if (!productId) return null;
  if (!allowOpaqueProductId && isUuidLikeString(productId)) return null;
  if (requireMerchant && !merchantId) return null;
  return {
    product_id: productId,
    ...(merchantId ? { merchant_id: merchantId } : {}),
  };
}

const RECO_TEST_SEED_ID_SET = new Set([
  'a39dd7a3-5d80-4cb3-82e1-3bf2707f65fc',
  'a39dd7a35d804cb382e13bf2707f65fc',
  'e7c90e06-8673-4c97-835d-074a26ab2162',
  'e7c90e0686734c97835d074a26ab2162',
  'c231aaaa-8b00-4145-a704-684931049303',
  'c231aaaa8b004145a704684931049303',
  'to_copper_peptides',
]);

const RECO_TEST_SEED_NAME_SET = new Set([
  'winona soothing repair serum',
  'ipsa time reset aqua',
  'the ordinary buffet plus copper peptides 1 percent',
  'the ordinary niacinamide 10 percent plus zinc 1 percent',
]);

function normalizeRecoSeedToken(value) {
  return String(value || '')
    .trim()
    .toLowerCase()
    .replace(/&/g, ' and ')
    .replace(/\+/g, ' plus ')
    .replace(/%/g, ' percent ')
    .replace(/[^a-z0-9\u4e00-\u9fff]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function buildRecoDiversityHistoryKey(ctx) {
  const uid = pickFirstTrimmed(ctx?.aurora_uid, ctx?.brief_id);
  if (uid) return `uid:${uid.toLowerCase()}`;
  return '';
}

function buildRecoDiversityToken(item) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : {};
  const sku =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : {};
  const productId = pickFirstTrimmed(sku.product_id, sku.productId, base.product_id, base.productId, sku.sku_id, sku.skuId);
  if (productId) return `id:${String(productId).trim().toLowerCase()}`;

  const brand = pickFirstTrimmed(sku.brand, base.brand);
  const name = pickFirstTrimmed(
    sku.display_name,
    sku.displayName,
    sku.name,
    base.display_name,
    base.displayName,
    base.title,
  );
  const joined = joinBrandAndName(brand, name);
  const token = normalizeRecoSeedToken(joined || name);
  return token ? `name:${token}` : '';
}

function getRecoRecentExposureState(historyKey, nowMs = Date.now()) {
  const key = String(historyKey || '').trim();
  if (!key) return { tokens: [], round: 0 };
  const entry = recoRecentExposureState.get(key);
  if (!entry || typeof entry !== 'object') return { tokens: [], round: 0 };

  const expiresAt = Number(entry.expiresAt || 0);
  if (!Number.isFinite(expiresAt) || expiresAt <= nowMs) {
    recoRecentExposureState.delete(key);
    return { tokens: [], round: 0 };
  }

  const tokens = Array.isArray(entry.tokens) ? entry.tokens : [];
  const round = Number.isFinite(Number(entry.round)) ? Math.max(0, Math.trunc(Number(entry.round))) : 0;
  return {
    round,
    tokens: tokens
    .map((token) => String(token || '').trim())
    .filter(Boolean)
    .slice(-RECO_DIVERSITY_HISTORY_MAX_ITEMS),
  };
}

function getRecoRecentExposureTokens(historyKey, nowMs = Date.now()) {
  return getRecoRecentExposureState(historyKey, nowMs).tokens;
}

function updateRecoRecentExposureTokens(historyKey, nextTokens, nowMs = Date.now()) {
  const key = String(historyKey || '').trim();
  if (!key) return;
  const currentState = getRecoRecentExposureState(key, nowMs);
  const current = currentState.tokens;
  const incoming = (Array.isArray(nextTokens) ? nextTokens : [])
    .map((token) => String(token || '').trim())
    .filter(Boolean);
  if (!incoming.length && !current.length) return;

  const merged = [...current, ...incoming].slice(-RECO_DIVERSITY_HISTORY_MAX_ITEMS);
  const roundIncrement = incoming.length > 0 ? 1 : 0;
  recoRecentExposureState.delete(key);
  recoRecentExposureState.set(key, {
    tokens: merged,
    round: Math.max(0, Math.trunc(Number(currentState.round || 0))) + roundIncrement,
    expiresAt: nowMs + RECO_DIVERSITY_HISTORY_TTL_MS,
  });

  while (recoRecentExposureState.size > 800) {
    const oldestKey = recoRecentExposureState.keys().next().value;
    if (!oldestKey) break;
    recoRecentExposureState.delete(oldestKey);
  }
}

function applyRecoRecentDiversityGuard(recommendations, {
  historyTokens = [],
  maxRepeatPerResponse = RECO_DIVERSITY_MAX_REPEAT_PER_RESPONSE,
  minTotal = RECO_DIVERSITY_MIN_TOTAL,
  rotationRound = 0,
} = {}) {
  const list = Array.isArray(recommendations) ? recommendations : [];
  if (!list.length) {
    return {
      recommendations: list,
      repeated_before: 0,
      repeated_after: 0,
      filtered_count: 0,
      applied: false,
    };
  }

  const historySet = new Set(
    (Array.isArray(historyTokens) ? historyTokens : [])
      .map((token) => String(token || '').trim())
      .filter(Boolean),
  );
  if (!historySet.size) {
    return {
      recommendations: list,
      repeated_before: 0,
      repeated_after: 0,
      filtered_count: 0,
      applied: false,
    };
  }

  const annotated = list.map((item, idx) => {
    const token = buildRecoDiversityToken(item);
    const repeated = Boolean(token && historySet.has(token));
    return { idx, item, token, repeated };
  });
  const lastSeenPosByToken = new Map();
  const historyOrdered = (Array.isArray(historyTokens) ? historyTokens : [])
    .map((token) => String(token || '').trim())
    .filter(Boolean);
  for (let idx = 0; idx < historyOrdered.length; idx += 1) {
    const token = historyOrdered[idx];
    lastSeenPosByToken.set(token, idx);
  }
  const rankForNovelty = (rows) =>
    rows
      .slice()
      .sort((a, b) => {
        if (a.repeated !== b.repeated) return a.repeated ? 1 : -1;
        if (!a.repeated && !b.repeated) return a.idx - b.idx;
        const aPos = Number.isFinite(Number(lastSeenPosByToken.get(a.token)))
          ? Number(lastSeenPosByToken.get(a.token))
          : -1;
        const bPos = Number.isFinite(Number(lastSeenPosByToken.get(b.token)))
          ? Number(lastSeenPosByToken.get(b.token))
          : -1;
        if (aPos !== bPos) return aPos - bPos;
        return a.idx - b.idx;
      });
  const repeatedBefore = annotated.filter((row) => row.repeated).length;
  if (!repeatedBefore) {
    return {
      recommendations: list,
      repeated_before: 0,
      repeated_after: 0,
      filtered_count: 0,
      applied: false,
    };
  }

  const freshCount = annotated.filter((row) => !row.repeated).length;
  const maxRepeat = Math.max(0, Math.min(4, Number.isFinite(Number(maxRepeatPerResponse)) ? Math.trunc(Number(maxRepeatPerResponse)) : RECO_DIVERSITY_MAX_REPEAT_PER_RESPONSE));
  const minKeepTotal = Math.max(1, Math.min(8, Number.isFinite(Number(minTotal)) ? Math.trunc(Number(minTotal)) : RECO_DIVERSITY_MIN_TOTAL));
  const repeatKeepFloor = Math.max(0, minKeepTotal - freshCount);
  const allowedRepeats = Math.min(repeatedBefore, Math.max(maxRepeat, repeatKeepFloor));

  if (allowedRepeats >= repeatedBefore) {
    const noveltyRanked = rankForNovelty(annotated).map((row) => row.item);
    let rotated = noveltyRanked.slice();
    if (repeatedBefore === annotated.length && rotated.length > 1) {
      const normalizedRound = Number.isFinite(Number(rotationRound)) ? Math.max(0, Math.trunc(Number(rotationRound))) : 0;
      const offset = normalizedRound % rotated.length;
      if (offset > 0) {
        rotated = [...rotated.slice(offset), ...rotated.slice(0, offset)];
      }
    }
    const reRanked = rotated.some((item, idx) => item !== list[idx]);
    return {
      recommendations: rotated,
      repeated_before: repeatedBefore,
      repeated_after: repeatedBefore,
      filtered_count: 0,
      applied: reRanked,
    };
  }

  const keep = [];
  let repeatKept = 0;
  for (const row of annotated) {
    if (!row.repeated) {
      keep.push(row.item);
      continue;
    }
    if (repeatKept < allowedRepeats) {
      keep.push(row.item);
      repeatKept += 1;
    }
  }

  return {
    recommendations: keep,
    repeated_before: repeatedBefore,
    repeated_after: repeatKept,
    filtered_count: repeatedBefore - repeatKept,
    applied: repeatedBefore > repeatKept,
  };
}

function buildRecoSeedCandidateTokens(item) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : {};
  const sku =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : {};
  const brand = pickFirstTrimmed(sku.brand, base.brand);
  const name = pickFirstTrimmed(sku.name, base.name);
  const displayName = pickFirstTrimmed(sku.display_name, sku.displayName, base.display_name, base.displayName, name);
  const joined = joinBrandAndName(brand, displayName || name);
  return uniqCaseInsensitiveStrings(
    [
      displayName,
      joined,
      pickFirstTrimmed(base.title, base.product_name, base.productTitle),
      name,
      brand,
    ].map((x) => normalizeRecoSeedToken(x)),
    10,
  );
}

function isRecoKnownTestSeedItem(item) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : {};
  const sku =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : {};

  const ids = uniqCaseInsensitiveStrings(
    [
      pickFirstTrimmed(sku.product_id, sku.productId),
      pickFirstTrimmed(sku.sku_id, sku.skuId),
      pickFirstTrimmed(base.product_id, base.productId),
      pickFirstTrimmed(base.sku_id, base.skuId),
    ].map((x) => String(x || '').trim().toLowerCase()),
    10,
  );
  if (ids.some((id) => RECO_TEST_SEED_ID_SET.has(id))) return true;

  const tokens = buildRecoSeedCandidateTokens(base);
  if (tokens.some((token) => RECO_TEST_SEED_NAME_SET.has(token))) return true;
  return false;
}

function limitRecoKnownTestSeedRecommendations(recommendations, {
  maxSeedItems = RECO_TEST_SEED_MAX_PER_RESPONSE,
  minTotal = RECO_TEST_SEED_MIN_TOTAL,
} = {}) {
  const list = Array.isArray(recommendations) ? recommendations : [];
  if (!list.length) {
    return {
      recommendations: list,
      seed_count_before: 0,
      seed_count_after: 0,
      filtered_count: 0,
      applied: false,
    };
  }

  const maxSeed = Math.max(0, Math.min(4, Number.isFinite(Number(maxSeedItems)) ? Math.trunc(Number(maxSeedItems)) : RECO_TEST_SEED_MAX_PER_RESPONSE));
  const minKeepTotal = Math.max(1, Math.min(8, Number.isFinite(Number(minTotal)) ? Math.trunc(Number(minTotal)) : RECO_TEST_SEED_MIN_TOTAL));
  if (maxSeed >= list.length) {
    return {
      recommendations: list,
      seed_count_before: 0,
      seed_count_after: 0,
      filtered_count: 0,
      applied: false,
    };
  }

  const seedIndexes = [];
  const nonSeedIndexes = [];
  for (let i = 0; i < list.length; i += 1) {
    if (isRecoKnownTestSeedItem(list[i])) seedIndexes.push(i);
    else nonSeedIndexes.push(i);
  }

  if (!seedIndexes.length || seedIndexes.length <= maxSeed || !nonSeedIndexes.length) {
    return {
      recommendations: list,
      seed_count_before: seedIndexes.length,
      seed_count_after: seedIndexes.length,
      filtered_count: 0,
      applied: false,
    };
  }

  const nonSeedCount = nonSeedIndexes.length;
  const seedKeepFloor = Math.max(0, minKeepTotal - nonSeedCount);
  const allowedSeedCount = Math.min(seedIndexes.length, Math.max(maxSeed, seedKeepFloor));
  if (allowedSeedCount >= seedIndexes.length) {
    return {
      recommendations: list,
      seed_count_before: seedIndexes.length,
      seed_count_after: seedIndexes.length,
      filtered_count: 0,
      applied: false,
    };
  }

  const seedIndexSet = new Set(seedIndexes);
  const allowedSeedIndexSet = new Set(seedIndexes.slice(0, allowedSeedCount));
  const filtered = [];
  for (let i = 0; i < list.length; i += 1) {
    if (!seedIndexSet.has(i)) {
      filtered.push(list[i]);
      continue;
    }
    if (allowedSeedIndexSet.has(i)) filtered.push(list[i]);
  }

  return {
    recommendations: filtered,
    seed_count_before: seedIndexes.length,
    seed_count_after: allowedSeedCount,
    filtered_count: seedIndexes.length - allowedSeedCount,
    applied: seedIndexes.length > allowedSeedCount,
  };
}

function extractRecoPdpDirectKeys(base, skuCandidate) {
  const candidates = [base, skuCandidate].filter((v) => Boolean(v) && typeof v === 'object' && !Array.isArray(v));
  const subjectCandidates = [];
  for (const source of candidates) {
    if (source.subject && typeof source.subject === 'object' && !Array.isArray(source.subject)) {
      subjectCandidates.push(source.subject);
    }
  }

  let subjectProductGroupId = '';
  for (const subject of subjectCandidates) {
    const type = pickFirstTrimmed(subject.type).toLowerCase();
    const asId = pickFirstTrimmed(subject.id);
    const asPgid = pickFirstTrimmed(subject.product_group_id, subject.productGroupId);
    if (type === 'product_group' && asId) {
      subjectProductGroupId = asId;
      break;
    }
    if (asPgid) {
      subjectProductGroupId = asPgid;
      break;
    }
  }

  if (!subjectProductGroupId) {
    subjectProductGroupId = pickFirstTrimmed(
      base?.product_group_id,
      base?.productGroupId,
      skuCandidate?.product_group_id,
      skuCandidate?.productGroupId,
      base?.pdp_open?.subject?.product_group_id,
      base?.pdp_open?.subject?.id,
      base?.pdpOpen?.subject?.product_group_id,
      base?.pdpOpen?.subject?.id,
    );
  }

  const canonicalRefCandidates = [
    base?.canonical_product_ref,
    base?.canonicalProductRef,
    skuCandidate?.canonical_product_ref,
    skuCandidate?.canonicalProductRef,
    base?.product_ref,
    base?.productRef,
    skuCandidate?.product_ref,
    skuCandidate?.productRef,
  ];

  let directProductRef = null;
  for (const refRaw of canonicalRefCandidates) {
    const ref = normalizeCanonicalProductRef(refRaw, { requireMerchant: true, allowOpaqueProductId: false });
    if (ref) {
      directProductRef = ref;
      break;
    }
  }

  const rawProductId = pickFirstTrimmed(
    skuCandidate?.product_id,
    skuCandidate?.productId,
    base?.product_id,
    base?.productId,
  );
  const rawMerchantId = pickFirstTrimmed(
    skuCandidate?.merchant_id,
    skuCandidate?.merchantId,
    base?.merchant_id,
    base?.merchantId,
  );

  if (!directProductRef) {
    const fallbackRef = normalizeCanonicalProductRef(
      {
        product_id: rawProductId,
        merchant_id: rawMerchantId,
      },
      { requireMerchant: true, allowOpaqueProductId: false },
    );
    if (fallbackRef) directProductRef = fallbackRef;
  }

  return {
    subjectProductGroupId,
    directProductRef,
    rawProductId,
    rawMerchantId,
  };
}

function buildRecoResolveHints({ base, skuCandidate, rawProductId, rawMerchantId, brand, name, displayName }) {
  const aliases = [];
  const seen = new Set();
  const pushAlias = (value) => {
    const s = String(value || '').trim();
    if (!s) return;
    const key = s.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    aliases.push(s);
  };

  pushAlias(displayName);
  pushAlias(name);
  if (brand && displayName) pushAlias(joinBrandAndName(brand, displayName));
  if (brand && name) pushAlias(joinBrandAndName(brand, name));
  pushAlias(base?.title);

  const hints = {};
  const canonicalHintRef = normalizeCanonicalProductRef(
    {
      product_id: rawProductId,
      merchant_id: rawMerchantId,
    },
    { requireMerchant: false, allowOpaqueProductId: false },
  );
  if (canonicalHintRef) {
    hints.product_ref = canonicalHintRef;
  }
  if (brand) hints.brand = brand;
  if (aliases.length) hints.aliases = aliases.slice(0, 8);
  return hints;
}

function normalizeResolveReasonCode(raw, fallback = 'no_candidates') {
  const code = String(raw || '').trim().toLowerCase();
  if (code === 'db_error' || code === 'upstream_timeout' || code === 'no_candidates') return code;
  return fallback;
}

function normalizePdpOpenMode(raw, fallback = 'external') {
  const mode = String(raw || '').trim().toLowerCase();
  if (mode === 'group' || mode === 'ref' || mode === 'resolve' || mode === 'external') return mode;
  return fallback;
}

function normalizePdpOpenPath(raw, fallback = 'external') {
  const path = String(raw || '').trim().toLowerCase();
  if (path === 'internal' || path === 'external') return path;
  if (path === 'group' || path === 'ref' || path === 'resolve') return 'internal';
  return fallback;
}

function mapResolveFailureCode({ resolveBody, statusCode, error } = {}) {
  const explicit = normalizeResolveReasonCode(
    resolveBody?.reason_code || resolveBody?.reasonCode || resolveBody?.metadata?.resolve_reason_code,
    '',
  );

  const reason = String(resolveBody?.reason || '').trim().toLowerCase();
  const sources = Array.isArray(resolveBody?.metadata?.sources) ? resolveBody.metadata.sources : [];
  const sourceReasons = sources
    .map((item) => String(item && item.reason ? item.reason : '').trim().toLowerCase())
    .filter(Boolean);
  const sourceDerivedReason =
    sourceReasons.some((r) => r.startsWith('db_') || r === 'products_cache_missing')
      ? 'db_error'
      : sourceReasons.some((r) => r.includes('timeout') || r.startsWith('upstream_'))
        ? 'upstream_timeout'
        : null;

  if (explicit === 'db_error' || explicit === 'upstream_timeout') return explicit;
  if (sourceDerivedReason) return sourceDerivedReason;
  if (explicit === 'no_candidates') return explicit;

  if (reason === 'no_candidates' || reason === 'low_confidence' || reason === 'empty_query') return 'no_candidates';
  if (reason.startsWith('db_') || reason === 'products_cache_missing') return 'db_error';
  if (reason.includes('timeout') || reason.startsWith('upstream_') || reason === 'upstream_error') return 'upstream_timeout';

  if (sourceReasons.some((r) => r.startsWith('db_') || r === 'products_cache_missing')) return 'db_error';
  if (sourceReasons.some((r) => r.includes('timeout') || r.startsWith('upstream_'))) return 'upstream_timeout';

  const status = Number(statusCode || 0);
  if (status >= 500 || status === 429) return 'upstream_timeout';

  const errText = String(error?.code || error?.message || error || '').trim().toLowerCase();
  if (errText.includes('timeout') || errText.includes('econnaborted') || errText.includes('etimedout')) {
    return 'upstream_timeout';
  }
  if (errText.includes('db_') || errText.includes('database') || errText.includes('postgres')) {
    return 'db_error';
  }
  return 'no_candidates';
}

function shouldAttemptLocalRecoFallback(reasonCode, error) {
  if (reasonCode === 'no_candidates') {
    return RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_NO_CANDIDATES;
  }
  if (reasonCode === 'upstream_timeout') return RECO_PDP_LOCAL_INVOKE_FALLBACK_ON_UPSTREAM_TIMEOUT;
  if (reasonCode === 'db_error') return true;
  if (error) return true;
  return false;
}

function getRecoPdpResolveTimeoutMs({ strictInternal = false, requestedTimeoutMs = null } = {}) {
  const requested = Number.isFinite(Number(requestedTimeoutMs)) ? Math.trunc(Number(requestedTimeoutMs)) : RECO_PDP_RESOLVE_TIMEOUT_MS;
  const baseline = Math.max(300, Math.min(12000, requested));
  if (!strictInternal) return baseline;
  return Math.max(baseline, RECO_PDP_RESOLVE_TIMEOUT_STRICT_MIN_MS);
}

function extractCanonicalFromOffersResolveBody(body) {
  const payload = body && typeof body === 'object' && !Array.isArray(body) ? body : null;
  const mapping = payload && payload.mapping && typeof payload.mapping === 'object' && !Array.isArray(payload.mapping)
    ? payload.mapping
    : null;
  let canonicalProductGroupId = pickFirstTrimmed(
    mapping?.canonical_product_group_id,
    mapping?.canonicalProductGroupId,
    mapping?.canonical_product_group?.id,
    mapping?.canonical_product_group?.product_group_id,
  );

  const canonicalRefCandidates = [
    mapping?.canonical_ref,
    mapping?.canonical_product_ref,
    payload?.canonical_product_ref,
  ];
  let canonicalProductRef = null;
  for (const candidate of canonicalRefCandidates) {
    const normalized = normalizeCanonicalProductRef(candidate, {
      requireMerchant: true,
      allowOpaqueProductId: false,
    });
    if (normalized) {
      canonicalProductRef = normalized;
      break;
    }
  }

  if (!canonicalProductRef) {
    const canonicalProduct =
      mapping?.canonical_product && typeof mapping.canonical_product === 'object' && !Array.isArray(mapping.canonical_product)
        ? mapping.canonical_product
        : null;
    const fallbackRef = normalizeCanonicalProductRef(
      {
        product_id: pickFirstTrimmed(canonicalProduct?.product_id, canonicalProduct?.id),
        merchant_id: pickFirstTrimmed(
          canonicalProduct?.merchant_id,
          canonicalProduct?.merchantId,
          canonicalProduct?.merchant?.merchant_id,
        ),
      },
      { requireMerchant: true, allowOpaqueProductId: false },
    );
    if (fallbackRef) canonicalProductRef = fallbackRef;
  }

  const pdpTargets = [
    payload?.pdp_target?.v1,
    payload?.pdpTarget?.v1,
    mapping?.pdp_target?.v1,
    mapping?.pdpTarget?.v1,
  ].filter((candidate) => Boolean(candidate) && typeof candidate === 'object' && !Array.isArray(candidate));

  for (const target of pdpTargets) {
    if (!canonicalProductGroupId) {
      const fromSubject = pickFirstTrimmed(
        target?.subject?.product_group_id,
        target?.subject?.productGroupId,
        target?.subject?.id,
        target?.product_group_id,
        target?.productGroupId,
      );
      if (fromSubject) canonicalProductGroupId = fromSubject;
    }

    if (!canonicalProductRef) {
      const fromTargetRef =
        normalizeCanonicalProductRef(target?.canonical_product_ref, {
          requireMerchant: true,
          allowOpaqueProductId: false,
        }) ||
        normalizeCanonicalProductRef(target?.product_ref, {
          requireMerchant: true,
          allowOpaqueProductId: false,
        });
      if (fromTargetRef) canonicalProductRef = fromTargetRef;
    }
  }

  return { canonicalProductRef, canonicalProductGroupId };
}

function resolveRecoStableAliasRefByQuery(queryText) {
  if (!resolveKnownStableProductRef) return null;
  const raw = String(queryText || '').trim();
  if (!raw) return null;

  const normalizedQuery = normalizeTextForStableResolver(raw);
  const queryTokens = tokenizeStableResolverQuery(normalizedQuery);
  if (!normalizedQuery || !Array.isArray(queryTokens) || queryTokens.length === 0) return null;

  const match = resolveKnownStableProductRef({
    query: raw,
    normalizedQuery,
    queryTokens,
  });
  if (!match || !match.product_ref || typeof match.product_ref !== 'object') return null;

  const canonicalProductRef = normalizeCanonicalProductRef(match.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (!canonicalProductRef) return null;

  return {
    canonicalProductRef,
    matchId: String(match.id || '').trim() || null,
    matchedAlias: String(match.matched_alias || '').trim() || null,
    reason: String(match.reason || '').trim() || 'stable_alias_ref',
    score: Number.isFinite(Number(match.score)) ? Number(match.score) : null,
  };
}

async function resolveRecoPdpByStableIds({
  productId,
  skuId,
  brand,
  name,
  displayName,
  merchantId,
  logger,
  allowLocalInvokeFallback = true,
} = {}) {
  const normalizedProductId = String(productId || '').trim();
  const normalizedSkuId = String(skuId || '').trim();
  const normalizedBrand = String(brand || '').trim();
  const normalizedName = String(name || '').trim();
  const normalizedDisplayName = String(displayName || '').trim();
  const normalizedMerchantId = String(merchantId || '').trim();
  const stableQueryText = pickFirstTrimmed(
    normalizedBrand && normalizedDisplayName
      ? joinBrandAndName(normalizedBrand, normalizedDisplayName)
      : '',
    normalizedBrand && normalizedName ? joinBrandAndName(normalizedBrand, normalizedName) : '',
    normalizedDisplayName,
    normalizedName,
    normalizedSkuId,
    normalizedProductId,
  );

  const stableAliasMatch = resolveRecoStableAliasRefByQuery(stableQueryText);
  if (stableAliasMatch?.canonicalProductRef) {
    logger?.info(
      {
        product_id: normalizedProductId || null,
        sku_id: normalizedSkuId || null,
        match_id: stableAliasMatch.matchId,
        matched_alias: stableAliasMatch.matchedAlias,
        score: stableAliasMatch.score,
      },
      'aurora bff: reco stable-id resolved via local stable alias',
    );
    return {
      ok: true,
      canonicalProductRef: stableAliasMatch.canonicalProductRef,
      requestIds: null,
      localFallbackAttempted: false,
      resolveAttempted: false,
      reasonCode: 'stable_alias_ref',
    };
  }

  if (!PIVOTA_BACKEND_BASE_URL || (!normalizedProductId && !normalizedSkuId)) {
    return { ok: false, reasonCode: 'no_candidates' };
  }

  const stableIdCandidates = [normalizedProductId, normalizedSkuId].filter(Boolean);
  const hasOnlyOpaqueStableIds = stableIdCandidates.length > 0 && stableIdCandidates.every((v) => isUuidLikeString(v));
  if (RECO_PDP_SKIP_OPAQUE_STABLE_IDS && hasOnlyOpaqueStableIds && !normalizedMerchantId) {
    logger?.info(
      {
        product_id: normalizedProductId || null,
        sku_id: normalizedSkuId || null,
        merchant_id: null,
      },
      'aurora bff: reco stable-id offers.resolve skipped for opaque ids without merchant',
    );
    return {
      ok: false,
      reasonCode: 'no_candidates',
      requestIds: null,
      localFallbackAttempted: false,
      resolveAttempted: false,
    };
  }

  let responseBody = null;
  let statusCode = 0;
  let responseError = null;
  let primaryRequestId = null;
  let localRequestId = null;
  let localFallbackAttempted = false;
  const primaryInvokeUrl = `${String(PIVOTA_BACKEND_BASE_URL || '').replace(/\/+$/, '')}/agent/shop/v1/invoke`;
  try {
    const resolvePayload = {
      product: {
        ...(normalizedProductId ? { product_id: normalizedProductId } : {}),
        ...(normalizedSkuId ? { sku_id: normalizedSkuId } : {}),
        ...(normalizedMerchantId ? { merchant_id: normalizedMerchantId } : {}),
        ...(normalizedBrand ? { brand: normalizedBrand } : {}),
        ...(normalizedName ? { name: normalizedName } : {}),
        ...(normalizedDisplayName ? { display_name: normalizedDisplayName } : {}),
        ...(stableQueryText ? { query: stableQueryText } : {}),
      },
      ...(normalizedProductId ? { product_id: normalizedProductId } : {}),
      ...(normalizedSkuId ? { sku_id: normalizedSkuId } : {}),
      ...(stableQueryText ? { query: stableQueryText } : {}),
    };
    const resp = await axios.post(
      primaryInvokeUrl,
      {
        operation: 'offers.resolve',
        payload: resolvePayload,
      },
      {
        headers: buildPivotaBackendAgentHeaders(),
        timeout: RECO_PDP_OFFERS_RESOLVE_TIMEOUT_MS,
        validateStatus: () => true,
      },
    );
    responseBody = resp && typeof resp.data === 'object' ? resp.data : null;
    statusCode = Number(resp?.status || 0);
    primaryRequestId = pickFirstTrimmed(
      responseBody?.metadata?.request_id,
      responseBody?.metadata?.requestId,
      resp?.headers?.['x-request-id'],
      resp?.headers?.['X-Request-Id'],
    );
  } catch (err) {
    responseError = err;
  }

  if (statusCode === 200 && responseBody && String(responseBody.status || '').trim().toLowerCase() === 'success') {
    const { canonicalProductRef, canonicalProductGroupId } = extractCanonicalFromOffersResolveBody(responseBody);
    if (canonicalProductGroupId || canonicalProductRef) {
      return {
        ok: true,
        canonicalProductGroupId,
        canonicalProductRef,
        requestIds:
          primaryRequestId
        ? { primary: primaryRequestId }
        : null,
        localFallbackAttempted: false,
        resolveAttempted: true,
      };
    }
  }

  let reasonCode = mapOfferResolveFailureCode({
    responseBody,
    statusCode,
    error: responseError,
  });

  const localInvokeUrl = `${String(RECO_PDP_LOCAL_INVOKE_BASE_URL || '').replace(/\/+$/, '')}/agent/shop/v1/invoke`;
  const shouldAttemptLocalFallback =
    allowLocalInvokeFallback &&
    RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
    RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED &&
    localInvokeUrl &&
    localInvokeUrl !== primaryInvokeUrl &&
    shouldAttemptLocalRecoFallback(reasonCode, responseError);
  if (
    shouldAttemptLocalFallback
  ) {
    recordRecoPdpInternalRetryAttempt(1);
    localFallbackAttempted = true;
    let localBody = null;
    let localStatusCode = 0;
    let localError = null;
    try {
      const resp = await axios.post(
        localInvokeUrl,
        {
          operation: 'offers.resolve',
          payload: {
            product: {
              ...(normalizedProductId ? { product_id: normalizedProductId } : {}),
              ...(normalizedSkuId ? { sku_id: normalizedSkuId } : {}),
              ...(normalizedMerchantId ? { merchant_id: normalizedMerchantId } : {}),
              ...(normalizedBrand ? { brand: normalizedBrand } : {}),
              ...(normalizedName ? { name: normalizedName } : {}),
              ...(normalizedDisplayName ? { display_name: normalizedDisplayName } : {}),
              ...(stableQueryText ? { query: stableQueryText } : {}),
            },
            ...(normalizedProductId ? { product_id: normalizedProductId } : {}),
            ...(normalizedSkuId ? { sku_id: normalizedSkuId } : {}),
            ...(stableQueryText ? { query: stableQueryText } : {}),
          },
        },
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS,
          validateStatus: () => true,
        },
      );
      localBody = resp && typeof resp.data === 'object' ? resp.data : null;
      localStatusCode = Number(resp?.status || 0);
      localRequestId = pickFirstTrimmed(
        localBody?.metadata?.request_id,
        localBody?.metadata?.requestId,
        resp?.headers?.['x-request-id'],
        resp?.headers?.['X-Request-Id'],
      );
    } catch (err) {
      localError = err;
    }

    if (localStatusCode === 200 && localBody && String(localBody.status || '').trim().toLowerCase() === 'success') {
      const { canonicalProductRef, canonicalProductGroupId } = extractCanonicalFromOffersResolveBody(localBody);
      if (canonicalProductGroupId || canonicalProductRef) {
        logger?.info(
          {
            product_id: normalizedProductId || null,
            sku_id: normalizedSkuId || null,
            primary_reason_code: reasonCode,
            local_status_code: localStatusCode,
            primary_request_id: primaryRequestId || null,
            local_request_id: localRequestId || null,
          },
          'aurora bff: reco stable-id resolved via local invoke fallback',
        );
        return {
          ok: true,
          canonicalProductGroupId,
          canonicalProductRef,
          requestIds:
            (primaryRequestId || localRequestId)
              ? {
                  ...(primaryRequestId ? { primary: primaryRequestId } : {}),
                  ...(localRequestId ? { local: localRequestId } : {}),
                }
              : null,
          localFallbackAttempted,
          resolveAttempted: true,
        };
      }
    }

    const localReasonCode = mapOfferResolveFailureCode({
      responseBody: localBody,
      statusCode: localStatusCode,
      error: localError,
    });
    logger?.warn(
      {
        product_id: normalizedProductId || null,
        sku_id: normalizedSkuId || null,
        primary_reason_code: reasonCode,
        local_reason_code: localReasonCode,
        local_status_code: localStatusCode || null,
        primary_request_id: primaryRequestId || null,
        local_request_id: localRequestId || null,
        local_err: localError ? localError.message || String(localError) : null,
      },
      'aurora bff: reco stable-id local invoke fallback unresolved',
    );
    if (reasonCode === 'no_candidates' && localReasonCode && localReasonCode !== 'no_candidates') {
      reasonCode = localReasonCode;
    }
  }

  if (!responseError) {
    logger?.warn(
      {
        status_code: statusCode || null,
        product_id: normalizedProductId || null,
        sku_id: normalizedSkuId || null,
        reason_code: reasonCode,
        response_status: responseBody?.status || null,
        primary_request_id: primaryRequestId || null,
        local_fallback_attempted: localFallbackAttempted,
      },
      'aurora bff: reco stable-id offers.resolve unresolved',
    );
  }
  if (responseError) {
    logger?.warn(
      {
        err: responseError?.message || String(responseError),
        product_id: normalizedProductId || null,
        sku_id: normalizedSkuId || null,
        reason_code: reasonCode,
        primary_request_id: primaryRequestId || null,
        local_fallback_attempted: localFallbackAttempted,
      },
      'aurora bff: reco stable-id offers.resolve failed',
    );
  }
  return {
    ok: false,
    reasonCode,
    requestIds:
      (primaryRequestId || localRequestId)
        ? {
            ...(primaryRequestId ? { primary: primaryRequestId } : {}),
            ...(localRequestId ? { local: localRequestId } : {}),
          }
        : null,
    localFallbackAttempted,
    resolveAttempted: true,
  };
}

async function resolveRecoPdpByLocalResolver({
  queryText,
  hints = null,
  logger,
  timeoutMs = null,
} = {}) {
  const q = String(queryText || '').trim();
  if (!q) return { ok: false, reasonCode: 'no_candidates' };

  const resolveTimeoutMs = getRecoPdpResolveTimeoutMs({
    strictInternal: true,
    requestedTimeoutMs: timeoutMs,
  });
  const localResolveUrl = `${String(RECO_PDP_LOCAL_INVOKE_BASE_URL || '').replace(/\/+$/, '')}/agent/v1/products/resolve`;
  const localHttpTimeoutMs = Math.max(RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS, resolveTimeoutMs);
  const canUseLocalHttpFallback = Boolean(localResolveUrl && /^https?:\/\//i.test(localResolveUrl));

  const runLocalHttpResolveFallback = async () => {
    if (!canUseLocalHttpFallback) {
      return { responseBody: null, responseStatusCode: null, responseError: new Error('local_resolver_unavailable') };
    }
    try {
      const resp = await axios.post(
        localResolveUrl,
        {
          query: q,
          lang: 'en',
          ...(hints && typeof hints === 'object' && !Array.isArray(hints) ? { hints } : {}),
          options: {
            search_all_merchants: true,
            timeout_ms: resolveTimeoutMs,
            upstream_retries: 0,
            stable_alias_short_circuit: true,
            allow_stable_alias_for_uuid: true,
            allow_external_seed: false,
          },
          caller: 'aurora_chatbox',
        },
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: localHttpTimeoutMs,
          validateStatus: () => true,
        },
      );
      return {
        responseBody: resp && typeof resp.data === 'object' ? resp.data : null,
        responseStatusCode: Number.isFinite(Number(resp?.status)) ? Math.trunc(Number(resp.status)) : null,
        responseError: null,
      };
    } catch (err) {
      return { responseBody: null, responseStatusCode: null, responseError: err };
    }
  };

  let responseBody = null;
  let responseStatusCode = null;
  let responseError = null;
  let fallbackMode = 'direct';
  if (typeof resolveProductRefDirectImpl === 'function') {
    try {
      responseBody = await resolveProductRefDirectImpl({
        query: q,
        lang: 'en',
        ...(hints && typeof hints === 'object' && !Array.isArray(hints) ? { hints } : {}),
        options: {
          search_all_merchants: true,
          timeout_ms: resolveTimeoutMs,
          upstream_retries: 0,
          stable_alias_short_circuit: true,
          allow_stable_alias_for_uuid: true,
        },
        caller: 'aurora_chatbox',
      });
    } catch (err) {
      responseError = err;
    }
  } else {
    const fallbackOut = await runLocalHttpResolveFallback();
    responseBody = fallbackOut.responseBody;
    responseStatusCode = fallbackOut.responseStatusCode;
    responseError = fallbackOut.responseError;
    fallbackMode = 'local_http';
  }

  const resolvedProductRef = normalizeCanonicalProductRef(responseBody?.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (responseBody?.resolved === true && resolvedProductRef) {
    return {
      ok: true,
      canonicalProductRef: resolvedProductRef,
      reasonCode: null,
    };
  }

  const reasonCode = mapResolveFailureCode({
    resolveBody: responseBody,
    statusCode: responseStatusCode,
    error: responseError,
  });
  let finalReasonCode = reasonCode;

  const shouldAttemptLocalHttpAfterDirect =
    fallbackMode === 'direct' &&
    canUseLocalHttpFallback &&
    (
      finalReasonCode === 'upstream_timeout' ||
      finalReasonCode === 'db_error' ||
      Boolean(responseError)
    );
  if (shouldAttemptLocalHttpAfterDirect) {
    recordRecoPdpInternalRetryAttempt(1);
    const fallbackOut = await runLocalHttpResolveFallback();
    const fallbackResolvedProductRef = normalizeCanonicalProductRef(fallbackOut.responseBody?.product_ref, {
      requireMerchant: true,
      allowOpaqueProductId: false,
    });
    if (fallbackOut.responseBody?.resolved === true && fallbackResolvedProductRef) {
      return {
        ok: true,
        canonicalProductRef: fallbackResolvedProductRef,
        reasonCode: null,
      };
    }
    const fallbackReasonCode = mapResolveFailureCode({
      resolveBody: fallbackOut.responseBody,
      statusCode: fallbackOut.responseStatusCode,
      error: fallbackOut.responseError,
    });
    if (fallbackReasonCode && fallbackReasonCode !== 'upstream_timeout' && fallbackReasonCode !== 'db_error') {
      finalReasonCode = fallbackReasonCode;
    } else if (
      (finalReasonCode === 'upstream_timeout' || finalReasonCode === 'db_error') &&
      fallbackReasonCode === 'no_candidates'
    ) {
      finalReasonCode = 'no_candidates';
    }
    responseBody = fallbackOut.responseBody || responseBody;
    responseStatusCode = fallbackOut.responseStatusCode || responseStatusCode;
    responseError = fallbackOut.responseError || responseError;
    fallbackMode = 'local_http_after_direct';
  }

  if (responseError || reasonCode !== 'no_candidates') {
    logger?.warn(
      {
        query: q.slice(0, 120),
        reason_code: finalReasonCode,
        status_code: responseStatusCode,
        fallback_mode: fallbackMode,
        err: responseError ? responseError.message || String(responseError) : null,
      },
      'aurora bff: reco pdp local resolver fallback unresolved',
    );
  }
  return {
    ok: false,
    reasonCode: finalReasonCode,
  };
}

async function resolveRecoPdpByCatalogSearch({
  queryText,
  logger,
  timeoutMs = RECO_CATALOG_SEARCH_TIMEOUT_MS,
  forceLocalSearchFallback = false,
} = {}) {
  const q = String(queryText || '').trim();
  if (!q) return { ok: false, reasonCode: 'no_candidates' };

  const searchOut = await searchPivotaBackendProducts({
    query: q,
    limit: 4,
    logger,
    timeoutMs,
    searchAllMerchants: true,
    forceLocalSearchFallback,
  });

  const products = Array.isArray(searchOut?.products) ? searchOut.products : [];
  for (const product of products) {
    if (!product || typeof product !== 'object' || Array.isArray(product)) continue;
    const { subjectProductGroupId, directProductRef } = extractRecoPdpDirectKeys(product, product);
    if (subjectProductGroupId || directProductRef) {
      return {
        ok: true,
        canonicalProductGroupId: subjectProductGroupId || null,
        canonicalProductRef: directProductRef || null,
        reasonCode: null,
      };
    }
  }

  return {
    ok: false,
    reasonCode: normalizeResolveReasonCode(searchOut?.reason || '', 'no_candidates'),
  };
}

function buildExternalGoogleSearchUrl(query) {
  const q = String(query || '').trim();
  if (!q) return 'https://www.google.com/';
  return `https://www.google.com/search?q=${encodeURIComponent(q)}`;
}

function withRecoPdpMetadata(base, {
  path,
  subject = null,
  canonicalProductRef = null,
  queryText = '',
  resolveReasonCode = null,
  resolveAttempted = false,
  resolvedViaQuery = null,
  timeToPdpMs = null,
  stableResolveRequestIds = null,
  stableResolveLocalFallbackAttempted = false,
}) {
  const nextMode = normalizePdpOpenMode(path, 'external');
  const nextPath = nextMode === 'external' ? 'external' : 'internal';
  const metadataBase = isPlainObject(base?.metadata) ? { ...base.metadata } : {};
  const normalizedFailReason =
    resolveReasonCode != null && resolveReasonCode !== ''
      ? normalizeResolveReasonCode(resolveReasonCode)
      : null;
  const normalizedTimeToPdp =
    Number.isFinite(Number(timeToPdpMs)) && Number(timeToPdpMs) >= 0
      ? Math.max(0, Math.round(Number(timeToPdpMs)))
      : null;
  const nextMetadata = {
    ...metadataBase,
    pdp_open_path: nextPath,
    pdp_open_mode: nextMode,
    ...(resolveAttempted ? { pdp_open_resolve_attempted: true } : {}),
    ...(normalizedFailReason
      ? {
          resolve_reason_code: normalizedFailReason,
          pdp_open_fail_reason: normalizedFailReason,
          resolve_fail_reason: normalizedFailReason,
        }
      : {}),
    ...(normalizedTimeToPdp != null ? { time_to_pdp_ms: normalizedTimeToPdp } : {}),
    ...(stableResolveRequestIds ? { stable_resolve_request_ids: stableResolveRequestIds } : {}),
    ...(stableResolveRequestIds || stableResolveLocalFallbackAttempted
      ? { stable_resolve_local_fallback_attempted: Boolean(stableResolveLocalFallbackAttempted) }
      : {}),
  };

  const nextSku =
    base && base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? { ...base.sku }
      : null;
  if (nextSku && subject?.product_group_id) {
    nextSku.product_group_id = String(subject.product_group_id);
  }
  if (nextSku && canonicalProductRef) {
    nextSku.canonical_product_ref = canonicalProductRef;
    nextSku.product_id = canonicalProductRef.product_id;
    nextSku.productId = canonicalProductRef.product_id;
    nextSku.sku_id = canonicalProductRef.product_id;
    nextSku.skuId = canonicalProductRef.product_id;
    if (canonicalProductRef.merchant_id) {
      nextSku.merchant_id = canonicalProductRef.merchant_id;
      nextSku.merchantId = canonicalProductRef.merchant_id;
    }
  }

  if (nextMode === 'group' && subject) {
    const productGroupId = String(subject.product_group_id || subject.id || '').trim();
    const normalizedSubject = { type: 'product_group', id: productGroupId, product_group_id: productGroupId };
    return {
      ...base,
      ...(nextSku ? { sku: nextSku } : {}),
      subject: normalizedSubject,
      metadata: nextMetadata,
      pdp_open: {
        path: 'group',
        subject: normalizedSubject,
        get_pdp_v2_payload: { subject: { type: 'product_group', id: productGroupId } },
      },
    };
  }

  if ((nextMode === 'ref' || nextMode === 'resolve') && canonicalProductRef) {
    return {
      ...base,
      ...(nextSku ? { sku: nextSku } : {}),
      canonical_product_ref: canonicalProductRef,
      metadata: nextMetadata,
      pdp_open: {
        path: nextMode,
        product_ref: canonicalProductRef,
        get_pdp_v2_payload: { product_ref: canonicalProductRef },
        ...(resolvedViaQuery ? { resolved_via_query: resolvedViaQuery } : {}),
      },
    };
  }

  const externalUrl = buildExternalGoogleSearchUrl(queryText);
  return {
    ...base,
    ...(nextSku ? { sku: nextSku } : {}),
    metadata: nextMetadata,
    pdp_open: {
      path: 'external',
      external: {
        provider: 'google',
        target: '_blank',
        url: externalUrl,
        query: String(queryText || '').trim() || null,
      },
      ...(normalizedFailReason ? { resolve_reason_code: normalizedFailReason } : {}),
    },
  };
}

async function enrichRecoItemWithPdpOpenContract(item, { logger, allowLocalInvokeFallback = true } = {}) {
  const startedAt = Date.now();
  const elapsedMs = () => Math.max(0, Date.now() - startedAt);
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
  if (!base) return item;

  const skuCandidate =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : null;

  const brand = pickFirstTrimmed(skuCandidate?.brand, base.brand);
  const name = pickFirstTrimmed(skuCandidate?.name, base.name);
  const displayName = pickFirstTrimmed(
    skuCandidate?.display_name,
    skuCandidate?.displayName,
    base.display_name,
    base.displayName,
    name,
  );

  const { subjectProductGroupId, directProductRef, rawProductId, rawMerchantId } = extractRecoPdpDirectKeys(
    base,
    skuCandidate,
  );

  if (subjectProductGroupId) {
    return withRecoPdpMetadata(base, {
      path: 'group',
      subject: { type: 'product_group', id: subjectProductGroupId, product_group_id: subjectProductGroupId },
      canonicalProductRef: directProductRef,
      timeToPdpMs: elapsedMs(),
    });
  }

  if (directProductRef) {
    return withRecoPdpMetadata(base, {
      path: 'ref',
      canonicalProductRef: directProductRef,
      timeToPdpMs: elapsedMs(),
    });
  }

  const stableProductId = pickFirstTrimmed(
    rawProductId,
    skuCandidate?.product_id,
    skuCandidate?.productId,
    base?.product_id,
    base?.productId,
  );
  const stableSkuId = pickFirstTrimmed(
    skuCandidate?.sku_id,
    skuCandidate?.skuId,
    base?.sku_id,
    base?.skuId,
    stableProductId,
  );
  const stableQueryText = pickFirstTrimmed(
    brand && displayName ? joinBrandAndName(brand, displayName) : '',
    brand && name ? joinBrandAndName(brand, name) : '',
    displayName,
    name,
    stableSkuId,
    stableProductId,
  );
  const stableAliasMatch = resolveRecoStableAliasRefByQuery(stableQueryText);
  if (stableAliasMatch?.canonicalProductRef) {
    return withRecoPdpMetadata(base, {
      path: 'ref',
      canonicalProductRef: stableAliasMatch.canonicalProductRef,
      resolveAttempted: false,
      timeToPdpMs: elapsedMs(),
    });
  }
  let stableResolveReasonCode = null;
  let stableResolveRequestIds = null;
  let stableResolveLocalFallbackAttempted = false;
  if (
    PIVOTA_BACKEND_BASE_URL &&
    (stableProductId || stableSkuId) &&
    (RECO_PDP_RESOLVE_ENABLED || RECO_PDP_STRICT_INTERNAL_FIRST)
  ) {
    const stableResolved = await resolveRecoPdpByStableIds({
      productId: stableProductId,
      skuId: stableSkuId,
      brand,
      name,
      displayName,
      merchantId: rawMerchantId,
      logger,
      allowLocalInvokeFallback,
    });
    stableResolveRequestIds =
      stableResolved?.requestIds && typeof stableResolved.requestIds === 'object'
        ? stableResolved.requestIds
        : null;
    stableResolveLocalFallbackAttempted = Boolean(stableResolved?.localFallbackAttempted);
    if (stableResolved.ok && stableResolved.canonicalProductGroupId) {
      return withRecoPdpMetadata(base, {
        path: 'group',
        subject: {
          type: 'product_group',
          id: stableResolved.canonicalProductGroupId,
          product_group_id: stableResolved.canonicalProductGroupId,
        },
        canonicalProductRef: stableResolved.canonicalProductRef || null,
        resolveAttempted: stableResolved.resolveAttempted === true,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    if (stableResolved.ok && stableResolved.canonicalProductRef) {
      return withRecoPdpMetadata(base, {
        path: 'ref',
        canonicalProductRef: stableResolved.canonicalProductRef,
        resolveAttempted: stableResolved.resolveAttempted === true,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    stableResolveReasonCode = stableResolved.reasonCode || null;
  }

  const queryText =
    buildProductInputText(skuCandidate || base, typeof base.url === 'string' ? base.url : null) ||
    stableQueryText;
  const stableResolveFailureCode = normalizeResolveReasonCode(stableResolveReasonCode || '', null);
  const shouldSkipNoCandidateQueryResolve =
    RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_NO_CANDIDATES &&
    !RECO_PDP_STRICT_INTERNAL_FIRST;
  const shouldSkipQueryResolveForStableFailure =
    RECO_PDP_SKIP_QUERY_RESOLVE_ON_STABLE_FAILURE &&
    Boolean(stableResolveFailureCode) &&
    (
      stableResolveFailureCode === 'no_candidates'
        ? shouldSkipNoCandidateQueryResolve
        : RECO_PDP_FAST_EXTERNAL_FALLBACK_ENABLED
    );
  if (
    shouldSkipQueryResolveForStableFailure
  ) {
    recordRecoPdpExternalFallback(stableResolveFailureCode);
    return withRecoPdpMetadata(base, {
      path: 'external',
      queryText,
      resolveReasonCode: stableResolveFailureCode,
      resolveAttempted: true,
      timeToPdpMs: elapsedMs(),
      stableResolveRequestIds,
      stableResolveLocalFallbackAttempted,
    });
  }

  const hints = buildRecoResolveHints({
    base,
    skuCandidate,
    rawProductId,
    rawMerchantId,
    brand,
    name,
    displayName,
  });
  const queryResolveTimeoutMs = getRecoPdpResolveTimeoutMs({
    strictInternal: RECO_PDP_STRICT_INTERNAL_FIRST,
  });

  if (!queryText) {
    recordRecoPdpExternalFallback(stableResolveReasonCode || 'no_candidates');
    return withRecoPdpMetadata(base, {
      path: 'external',
      queryText,
      resolveReasonCode: stableResolveReasonCode || 'no_candidates',
      resolveAttempted: false,
      timeToPdpMs: elapsedMs(),
      stableResolveRequestIds,
      stableResolveLocalFallbackAttempted,
    });
  }

  if (!PIVOTA_BACKEND_BASE_URL && RECO_PDP_STRICT_INTERNAL_FIRST) {
    const localResolved = await resolveRecoPdpByLocalResolver({
      queryText,
      hints,
      logger,
      timeoutMs: queryResolveTimeoutMs,
    });
    if (localResolved.ok && localResolved.canonicalProductRef) {
      return withRecoPdpMetadata(base, {
        path: 'resolve',
        canonicalProductRef: localResolved.canonicalProductRef,
        resolveAttempted: true,
        resolvedViaQuery: queryText,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    if (!stableResolveReasonCode && localResolved.reasonCode) {
      stableResolveReasonCode = localResolved.reasonCode;
    }
  }

  const shouldAttemptQueryResolve =
    Boolean(PIVOTA_BACKEND_BASE_URL) &&
    (RECO_PDP_RESOLVE_ENABLED || RECO_PDP_STRICT_INTERNAL_FIRST);
  if (!shouldAttemptQueryResolve) {
    const skipReasonCode = stableResolveReasonCode || 'db_error';
    recordRecoPdpExternalFallback(skipReasonCode);
    return withRecoPdpMetadata(base, {
      path: 'external',
      queryText,
      resolveReasonCode: skipReasonCode,
      resolveAttempted: false,
      timeToPdpMs: elapsedMs(),
      stableResolveRequestIds,
      stableResolveLocalFallbackAttempted,
    });
  }

  // Avoid opaque UUID-only lookups; they frequently produce unstable cross-merchant misses.
  const isOpaqueUuidOnlyQuery = isUuidLikeString(queryText) && (!hints.aliases || hints.aliases.length === 0);
  if (isOpaqueUuidOnlyQuery) {
    recordRecoPdpExternalFallback(stableResolveReasonCode || 'no_candidates');
    return withRecoPdpMetadata(base, {
      path: 'external',
      queryText,
      resolveReasonCode: stableResolveReasonCode || 'no_candidates',
      resolveAttempted: false,
      timeToPdpMs: elapsedMs(),
      stableResolveRequestIds,
      stableResolveLocalFallbackAttempted,
    });
  }

  let resolveBody = null;
  let resolveStatus = 0;
  let resolveError = null;
  const primaryResolveUrl = `${PIVOTA_BACKEND_BASE_URL}/agent/v1/products/resolve`;
  const queryResolvePayload = {
    query: queryText,
    lang: 'en',
    hints,
    options: {
      search_all_merchants: true,
      timeout_ms: queryResolveTimeoutMs,
      upstream_retries: 0,
      ...(rawMerchantId ? { prefer_merchants: [rawMerchantId] } : {}),
    },
    caller: 'aurora_chatbox',
  };
  try {
    const resp = await axios.post(
      primaryResolveUrl,
      queryResolvePayload,
      {
        headers: buildPivotaBackendAgentHeaders(),
        timeout: queryResolveTimeoutMs,
        validateStatus: () => true,
      },
    );
    resolveBody = resp && typeof resp.data === 'object' ? resp.data : null;
    resolveStatus = Number(resp?.status || 0);
  } catch (err) {
    resolveError = err;
  }

  const resolvedProductRef = normalizeCanonicalProductRef(resolveBody?.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (resolveStatus === 200 && resolveBody?.resolved === true && resolvedProductRef) {
    return withRecoPdpMetadata(base, {
      path: 'resolve',
      canonicalProductRef: resolvedProductRef,
      resolveAttempted: true,
      resolvedViaQuery: queryText,
      timeToPdpMs: elapsedMs(),
    });
  }

  let reasonCode = mapResolveFailureCode({
    resolveBody,
    statusCode: resolveStatus,
    error: resolveError,
  });
  const localResolveUrl = `${String(RECO_PDP_LOCAL_INVOKE_BASE_URL || '').replace(/\/+$/, '')}/agent/v1/products/resolve`;
  const shouldAttemptLocalResolveFallback =
    allowLocalInvokeFallback &&
    RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED &&
    RECO_PDP_LOCAL_INVOKE_FALLBACK_ENABLED &&
    localResolveUrl &&
    localResolveUrl !== primaryResolveUrl &&
    shouldAttemptLocalRecoFallback(reasonCode, resolveError);
  if (shouldAttemptLocalResolveFallback) {
    recordRecoPdpInternalRetryAttempt(1);
    let localResolveBody = null;
    let localResolveStatus = 0;
    let localResolveError = null;
    try {
      const resp = await axios.post(
        localResolveUrl,
        queryResolvePayload,
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: RECO_PDP_LOCAL_INVOKE_TIMEOUT_MS,
          validateStatus: () => true,
        },
      );
      localResolveBody = resp && typeof resp.data === 'object' ? resp.data : null;
      localResolveStatus = Number(resp?.status || 0);
    } catch (err) {
      localResolveError = err;
    }

    const localResolvedProductRef = normalizeCanonicalProductRef(localResolveBody?.product_ref, {
      requireMerchant: true,
      allowOpaqueProductId: false,
    });
    if (localResolveStatus === 200 && localResolveBody?.resolved === true && localResolvedProductRef) {
      logger?.info(
        {
          query: queryText.slice(0, 120),
          primary_reason_code: reasonCode,
          local_status_code: localResolveStatus,
        },
        'aurora bff: reco pdp resolved via local products.resolve fallback',
      );
      return withRecoPdpMetadata(base, {
        path: 'resolve',
        canonicalProductRef: localResolvedProductRef,
        resolveAttempted: true,
        resolvedViaQuery: queryText,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }

    const localReasonCode = mapResolveFailureCode({
      resolveBody: localResolveBody,
      statusCode: localResolveStatus,
      error: localResolveError,
    });
    if (reasonCode === 'no_candidates' && localReasonCode && localReasonCode !== 'no_candidates') {
      reasonCode = localReasonCode;
    }
    logger?.warn(
      {
        query: queryText.slice(0, 120),
        primary_reason_code: reasonCode,
        local_reason_code: localReasonCode,
        local_status_code: localResolveStatus || null,
        local_err: localResolveError ? localResolveError.message || String(localResolveError) : null,
      },
      'aurora bff: reco pdp local products.resolve fallback unresolved',
    );
  }
  const stableIdCandidates = [stableProductId, stableSkuId]
    .map((value) => String(value || '').trim())
    .filter(Boolean);
  const hasOnlyOpaqueStableIdsWithoutMerchant =
    !rawMerchantId &&
    stableIdCandidates.length > 0 &&
    stableIdCandidates.every((value) => isUuidLikeString(value));
  const hasStrongNamedQueryForCatalogFallback = Boolean(
    (brand && (displayName || name)) ||
      (displayName && String(displayName).trim().split(/\s+/).filter(Boolean).length >= 2) ||
      (name && String(name).trim().split(/\s+/).filter(Boolean).length >= 2),
  );
  const shouldAttemptDeterministicLocalResolver =
    RECO_PDP_STRICT_INTERNAL_FIRST &&
    (
      reasonCode === 'upstream_timeout' ||
      reasonCode === 'db_error' ||
      (
        reasonCode === 'no_candidates' &&
        (hasOnlyOpaqueStableIdsWithoutMerchant || hasStrongNamedQueryForCatalogFallback)
      )
    );
  if (shouldAttemptDeterministicLocalResolver) {
    recordRecoPdpInternalRetryAttempt(1);
    const localResolved = await resolveRecoPdpByLocalResolver({
      queryText,
      hints,
      logger,
      timeoutMs: queryResolveTimeoutMs,
    });
    if (localResolved.ok && localResolved.canonicalProductRef) {
      logger?.info(
        {
          query: queryText.slice(0, 120),
          primary_reason_code: reasonCode,
          fallback: 'local_resolver',
        },
        'aurora bff: reco pdp resolved via deterministic local resolver',
      );
      return withRecoPdpMetadata(base, {
        path: 'resolve',
        canonicalProductRef: localResolved.canonicalProductRef,
        resolveAttempted: true,
        resolvedViaQuery: queryText,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    if (
      localResolved.reasonCode &&
      localResolved.reasonCode !== 'upstream_timeout' &&
      localResolved.reasonCode !== 'db_error'
    ) {
      reasonCode = localResolved.reasonCode;
    }
  }
  const shouldAttemptCatalogSearchFallback =
    RECO_PDP_STRICT_INTERNAL_FIRST &&
    (
      (
        reasonCode === 'no_candidates' &&
        (hasOnlyOpaqueStableIdsWithoutMerchant || hasStrongNamedQueryForCatalogFallback)
      ) ||
      (
        (reasonCode === 'upstream_timeout' || reasonCode === 'db_error') &&
        (hasOnlyOpaqueStableIdsWithoutMerchant || hasStrongNamedQueryForCatalogFallback)
      )
    );
  if (shouldAttemptCatalogSearchFallback) {
    const transientReasonForCatalog = reasonCode === 'upstream_timeout' || reasonCode === 'db_error';
    const reasonCodeBeforeCatalog = reasonCode;
    const catalogResolved = await resolveRecoPdpByCatalogSearch({
      queryText,
      logger,
      timeoutMs: Math.max(RECO_CATALOG_SEARCH_TIMEOUT_MS, queryResolveTimeoutMs),
      forceLocalSearchFallback: transientReasonForCatalog,
    });
    if (catalogResolved.ok && catalogResolved.canonicalProductGroupId) {
      return withRecoPdpMetadata(base, {
        path: 'group',
        subject: {
          type: 'product_group',
          id: catalogResolved.canonicalProductGroupId,
          product_group_id: catalogResolved.canonicalProductGroupId,
        },
        canonicalProductRef: catalogResolved.canonicalProductRef || null,
        resolveAttempted: true,
        resolvedViaQuery: queryText,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    if (catalogResolved.ok && catalogResolved.canonicalProductRef) {
      return withRecoPdpMetadata(base, {
        path: 'ref',
        canonicalProductRef: catalogResolved.canonicalProductRef,
        resolveAttempted: true,
        resolvedViaQuery: queryText,
        timeToPdpMs: elapsedMs(),
        stableResolveRequestIds,
        stableResolveLocalFallbackAttempted,
      });
    }
    if (catalogResolved.reasonCode && catalogResolved.reasonCode !== 'no_candidates') {
      const catalogReasonIsTransient =
        catalogResolved.reasonCode === 'upstream_timeout' || catalogResolved.reasonCode === 'db_error';
      // If local deterministic resolver already downgraded to no_candidates, do not re-upgrade on catalog transient.
      if (!(reasonCodeBeforeCatalog === 'no_candidates' && catalogReasonIsTransient)) {
        reasonCode = catalogResolved.reasonCode;
      }
    } else if (
      (reasonCodeBeforeCatalog === 'upstream_timeout' || reasonCodeBeforeCatalog === 'db_error') &&
      catalogResolved.reasonCode === 'no_candidates'
    ) {
      // Transient resolve failures should not force fast external fallback when catalog search can determine emptiness.
      reasonCode = 'no_candidates';
    }
  }
  if (resolveError) {
    logger?.warn(
      {
        err: resolveError?.message || String(resolveError),
        query: queryText.slice(0, 120),
        pdp_open_path: 'external',
        fail_reason: reasonCode,
        resolve_reason_code: reasonCode,
      },
      'aurora bff: reco pdp resolve failed; using external fallback',
    );
  }
  recordRecoPdpExternalFallback(reasonCode || 'no_candidates');
  return withRecoPdpMetadata(base, {
    path: 'external',
    queryText,
    resolveReasonCode: reasonCode,
    resolveAttempted: true,
    timeToPdpMs: elapsedMs(),
    stableResolveRequestIds,
    stableResolveLocalFallbackAttempted,
  });
}

function tallyPdpOpenPathStats(recommendations) {
  const stats = { group: 0, ref: 0, resolve: 0, external: 0 };
  for (const item of Array.isArray(recommendations) ? recommendations : []) {
    const mode = normalizePdpOpenMode(
      item?.pdp_open?.path || item?.metadata?.pdp_open_mode || item?.metadata?.pdp_open_path,
      'external',
    );
    if (mode === 'group' || mode === 'ref' || mode === 'resolve' || mode === 'external') {
      stats[mode] += 1;
    } else {
      stats.external += 1;
    }
  }
  return stats;
}

function tallyResolveFailReasonCounts(recommendations) {
  const counts = { db_error: 0, upstream_timeout: 0, no_candidates: 0 };
  for (const item of Array.isArray(recommendations) ? recommendations : []) {
    const code = normalizeResolveReasonCode(
      item?.metadata?.pdp_open_fail_reason ||
        item?.metadata?.resolve_reason_code ||
        item?.metadata?.resolve_fail_reason ||
        item?.pdp_open?.resolve_reason_code,
      '',
    );
    if (code === 'db_error' || code === 'upstream_timeout' || code === 'no_candidates') {
      counts[code] += 1;
    }
  }
  return counts;
}

function summarizeTimeToPdpStats(items) {
  const values = [];
  for (const item of Array.isArray(items) ? items : []) {
    const raw = item?.metadata?.time_to_pdp_ms;
    const num = Number(raw);
    if (!Number.isFinite(num) || num < 0) continue;
    values.push(Math.round(num));
  }
  values.sort((a, b) => a - b);

  if (!values.length) {
    return { count: 0, mean: 0, p50: 0, p90: 0, max: 0 };
  }

  const pickPercentile = (p) => {
    const idx = Math.min(values.length - 1, Math.max(0, Math.ceil(values.length * p) - 1));
    return values[idx];
  };
  const sum = values.reduce((acc, v) => acc + v, 0);
  return {
    count: values.length,
    mean: Math.round(sum / values.length),
    p50: pickPercentile(0.5),
    p90: pickPercentile(0.9),
    max: values[values.length - 1],
  };
}

function mapOfferResolveFailureCode({ responseBody, statusCode, error } = {}) {
  const explicit = normalizeResolveReasonCode(
    responseBody?.reason_code || responseBody?.reasonCode || responseBody?.metadata?.reason_code || responseBody?.metadata?.resolve_reason_code,
    '',
  );
  if (explicit) return explicit;

  const reason = String(
    responseBody?.reason ||
      responseBody?.error ||
      responseBody?.code ||
      responseBody?.message ||
      '',
  )
    .trim()
    .toLowerCase();
  if (reason.startsWith('db_') || reason.includes('database') || reason.includes('postgres')) return 'db_error';
  if (reason.includes('timeout') || reason.startsWith('upstream_') || reason === 'upstream_error') return 'upstream_timeout';
  if (reason === 'no_candidates' || reason === 'not_found' || reason === 'not_found_in_cache') return 'no_candidates';

  const status = Number(statusCode || 0);
  if (status >= 500 || status === 429 || status === 408) return 'upstream_timeout';

  const errText = String(error?.code || error?.message || error || '').trim().toLowerCase();
  if (errText.includes('timeout') || errText.includes('econnaborted') || errText.includes('etimedout')) {
    return 'upstream_timeout';
  }
  if (errText.includes('db_') || errText.includes('database') || errText.includes('postgres')) {
    return 'db_error';
  }
  return 'no_candidates';
}

function applyOfferItemPdpOpenContract(item, { failReasonCode = null, resolveAttempted = false, timeToPdpMs = null } = {}) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : {};
  const product = base.product && typeof base.product === 'object' && !Array.isArray(base.product) ? { ...base.product } : {};
  const offer = base.offer && typeof base.offer === 'object' && !Array.isArray(base.offer) ? { ...base.offer } : base.offer;
  const failReason =
    failReasonCode != null && failReasonCode !== ''
      ? normalizeResolveReasonCode(failReasonCode)
      : null;
  const { subjectProductGroupId, directProductRef } = extractRecoPdpDirectKeys(product, product);

  const metadataBase = isPlainObject(base.metadata) ? { ...base.metadata } : {};
  const normalizedTimeToPdp =
    Number.isFinite(Number(timeToPdpMs)) && Number(timeToPdpMs) >= 0
      ? Math.max(0, Math.round(Number(timeToPdpMs)))
      : null;
  const metadata = {
    ...metadataBase,
    ...(resolveAttempted ? { offer_resolve_attempted: true } : {}),
    ...(normalizedTimeToPdp != null ? { time_to_pdp_ms: normalizedTimeToPdp } : {}),
  };

  if (subjectProductGroupId) {
    const subject = {
      type: 'product_group',
      id: subjectProductGroupId,
      product_group_id: subjectProductGroupId,
    };
    product.product_group_id = subjectProductGroupId;
    if (directProductRef) product.canonical_product_ref = directProductRef;
    metadata.pdp_open_path = 'internal';
    metadata.pdp_open_mode = 'group';
    if (failReason) {
      metadata.pdp_open_fail_reason = failReason;
      metadata.resolve_reason_code = failReason;
      metadata.resolve_fail_reason = failReason;
    }
    return {
      ...base,
      product,
      ...(offer && typeof offer === 'object' ? { offer } : {}),
      metadata,
      pdp_open: {
        path: 'group',
        subject,
        get_pdp_v2_payload: { subject: { type: 'product_group', id: subjectProductGroupId } },
      },
    };
  }

  if (directProductRef) {
    product.canonical_product_ref = directProductRef;
    metadata.pdp_open_path = 'internal';
    metadata.pdp_open_mode = 'ref';
    if (failReason) {
      metadata.pdp_open_fail_reason = failReason;
      metadata.resolve_reason_code = failReason;
      metadata.resolve_fail_reason = failReason;
    }
    return {
      ...base,
      product,
      ...(offer && typeof offer === 'object' ? { offer } : {}),
      metadata,
      pdp_open: {
        path: 'ref',
        product_ref: directProductRef,
        get_pdp_v2_payload: { product_ref: directProductRef },
      },
    };
  }

  const offerUrl =
    (offer && typeof offer === 'object' && typeof offer.affiliate_url === 'string' && offer.affiliate_url.trim()) ||
    (offer && typeof offer === 'object' && typeof offer.affiliateUrl === 'string' && offer.affiliateUrl.trim()) ||
    (offer && typeof offer === 'object' && typeof offer.url === 'string' && offer.url.trim()) ||
    '';
  const queryText = buildProductInputText(product, offerUrl) || pickFirstTrimmed(product.display_name, product.name, product.brand);
  metadata.pdp_open_path = 'external';
  metadata.pdp_open_mode = 'external';
  if (failReason) {
    metadata.pdp_open_fail_reason = failReason;
    metadata.resolve_reason_code = failReason;
    metadata.resolve_fail_reason = failReason;
  }

  return {
    ...base,
    product,
    ...(offer && typeof offer === 'object' ? { offer } : {}),
    metadata,
    pdp_open: {
      path: 'external',
      external: {
        provider: 'google',
        target: '_blank',
        url: buildExternalGoogleSearchUrl(queryText),
        query: queryText || null,
      },
      ...(failReason ? { resolve_reason_code: failReason } : {}),
    },
  };
}

function summarizeOfferPdpOpen(items) {
  const stats = { internal: 0, external: 0 };
  const failReasonCounts = { db_error: 0, upstream_timeout: 0, no_candidates: 0 };
  for (const item of Array.isArray(items) ? items : []) {
    const path = normalizePdpOpenPath(item?.metadata?.pdp_open_path || item?.pdp_open?.path, 'external');
    if (path === 'internal') stats.internal += 1;
    else stats.external += 1;

    const failReason = normalizeResolveReasonCode(
      item?.metadata?.pdp_open_fail_reason || item?.metadata?.resolve_reason_code || item?.pdp_open?.resolve_reason_code,
      '',
    );
    if (failReason === 'db_error' || failReason === 'upstream_timeout' || failReason === 'no_candidates') {
      failReasonCounts[failReason] += 1;
    }
  }
  return {
    path_stats: stats,
    fail_reason_counts: failReasonCounts,
    time_to_pdp_ms_stats: summarizeTimeToPdpStats(items),
  };
}

function normalizePdpPrefetchReason(reason) {
  const normalized = String(reason || '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9:_-]+/g, '_')
    .replace(/^_+|_+$/g, '');
  return normalized || 'unknown';
}

function getPdpPrefetchReasonBucket(reason) {
  const key = normalizePdpPrefetchReason(reason);
  if (!pdpPrefetchStats.by_reason[key]) {
    pdpPrefetchStats.by_reason[key] = {
      total: 0,
      ok: 0,
      non_200: 0,
      failed: 0,
    };
  }
  return { key, bucket: pdpPrefetchStats.by_reason[key] };
}

function recordPdpPrefetchResult({ reason, status = 0, ok = false, failed = false, key = '', durationMs = 0, error = '' } = {}) {
  const { key: reasonKey, bucket } = getPdpPrefetchReasonBucket(reason);
  pdpPrefetchStats.totals.total += 1;
  bucket.total += 1;
  if (ok) {
    pdpPrefetchStats.totals.ok += 1;
    bucket.ok += 1;
  } else if (failed) {
    pdpPrefetchStats.totals.failed += 1;
    bucket.failed += 1;
  } else {
    pdpPrefetchStats.totals.non_200 += 1;
    bucket.non_200 += 1;
  }
  pdpPrefetchStats.last_prefetch = {
    at: new Date().toISOString(),
    reason: reasonKey,
    key: key || null,
    status: Number(status || 0),
    ok: Boolean(ok),
    failed: Boolean(failed),
    duration_ms: Number(durationMs || 0),
    error: error ? String(error).slice(0, 400) : null,
  };
}

function getNormalizedPdpHotsetPrewarmPayloads() {
  return (Array.isArray(AURORA_BFF_PDP_HOTSET_PREWARM_ITEMS) ? AURORA_BFF_PDP_HOTSET_PREWARM_ITEMS : [])
    .map((item) => normalizePdpCorePrefetchPayload(item))
    .filter(Boolean);
}

function getPdpPrefetchStateSnapshot() {
  return {
    config: {
      prefetch_enabled: AURORA_BFF_PDP_CORE_PREFETCH_ENABLED,
      prefetch_include: AURORA_BFF_PDP_CORE_PREFETCH_INCLUDE,
      prefetch_timeout_ms: AURORA_BFF_PDP_CORE_PREFETCH_TIMEOUT_MS,
      prefetch_dedup_ttl_ms: AURORA_BFF_PDP_CORE_PREFETCH_DEDUP_TTL_MS,
      hotset_prewarm_enabled: AURORA_BFF_PDP_HOTSET_PREWARM_ENABLED,
      hotset_size: getNormalizedPdpHotsetPrewarmPayloads().length,
      hotset_concurrency: AURORA_BFF_PDP_HOTSET_PREWARM_CONCURRENCY,
      hotset_interval_ms: AURORA_BFF_PDP_HOTSET_PREWARM_INTERVAL_MS,
      hotset_initial_delay_ms: AURORA_BFF_PDP_HOTSET_PREWARM_INITIAL_DELAY_MS,
      hotset_bootstrap_rounds: AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_ROUNDS,
      hotset_bootstrap_gap_ms: AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_GAP_MS,
    },
    runtime: {
      started: pdpHotsetPrewarmStarted,
      in_flight: pdpHotsetPrewarmInFlight,
      totals: { ...pdpPrefetchStats.totals },
      by_reason: { ...pdpPrefetchStats.by_reason },
      last_prefetch: pdpPrefetchStats.last_prefetch ? { ...pdpPrefetchStats.last_prefetch } : null,
      hotset_runs: { ...pdpPrefetchStats.hotset_runs },
      hotset_last: pdpPrefetchStats.hotset_last ? { ...pdpPrefetchStats.hotset_last } : null,
    },
  };
}

function getPdpHotsetPrewarmAdminToken(req) {
  if (!req || typeof req.get !== 'function') return '';
  return String(req.get('X-Aurora-Admin-Key') || req.get('x-aurora-admin-key') || '').trim();
}

function hasPdpHotsetPrewarmAdminAccess(req) {
  if (!AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY) return false;
  const provided = getPdpHotsetPrewarmAdminToken(req);
  if (!provided) return false;
  const expectedBuf = Buffer.from(AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY);
  const providedBuf = Buffer.from(provided);
  if (expectedBuf.length !== providedBuf.length) return false;
  try {
    return crypto.timingSafeEqual(expectedBuf, providedBuf);
  } catch {
    return false;
  }
}

function hasRecoPrelabelAdminAccess(req) {
  if (!AURORA_BFF_RECO_PRELABEL_ADMIN_KEY) return false;
  const provided = getPdpHotsetPrewarmAdminToken(req);
  if (!provided) return false;
  const expectedBuf = Buffer.from(AURORA_BFF_RECO_PRELABEL_ADMIN_KEY);
  const providedBuf = Buffer.from(provided);
  if (expectedBuf.length !== providedBuf.length) return false;
  try {
    return crypto.timingSafeEqual(expectedBuf, providedBuf);
  } catch {
    return false;
  }
}

function normalizePdpCorePrefetchPayload(raw) {
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  const productRef = normalizeCanonicalProductRef(raw.product_ref, {
    requireMerchant: true,
    allowOpaqueProductId: false,
  });
  if (productRef) return { product_ref: productRef };

  const subject = raw.subject && typeof raw.subject === 'object' && !Array.isArray(raw.subject) ? raw.subject : null;
  const subjectType = String(subject?.type || '').trim().toLowerCase();
  const subjectId = pickFirstTrimmed(subject?.id, subject?.product_group_id);
  if (subjectType === 'product_group' && subjectId) {
    return {
      subject: {
        type: 'product_group',
        id: subjectId,
      },
    };
  }

  return null;
}

function extractPdpCorePrefetchPayloadFromItem(item) {
  const fromContract = normalizePdpCorePrefetchPayload(item?.pdp_open?.get_pdp_v2_payload);
  if (fromContract) return fromContract;

  const mode = normalizePdpOpenMode(item?.pdp_open?.path || item?.metadata?.pdp_open_mode, '');
  if (mode === 'group') {
    const subjectId = pickFirstTrimmed(item?.pdp_open?.subject?.id, item?.pdp_open?.subject?.product_group_id);
    if (subjectId) {
      return {
        subject: {
          type: 'product_group',
          id: subjectId,
        },
      };
    }
    return null;
  }
  if (mode === 'ref' || mode === 'resolve') {
    const productRef = normalizeCanonicalProductRef(item?.pdp_open?.product_ref, {
      requireMerchant: true,
      allowOpaqueProductId: false,
    });
    if (productRef) return { product_ref: productRef };
  }

  return null;
}

function makePdpCorePrefetchKey(payload) {
  const normalized = normalizePdpCorePrefetchPayload(payload);
  if (!normalized) return '';
  if (normalized.subject?.type === 'product_group' && normalized.subject.id) {
    return `subject:product_group:${normalized.subject.id}`;
  }
  if (normalized.product_ref?.merchant_id && normalized.product_ref?.product_id) {
    return `ref:${normalized.product_ref.merchant_id}:${normalized.product_ref.product_id}`;
  }
  return '';
}

function shouldRunPdpCorePrefetch(key) {
  if (!key) return false;
  const now = Date.now();
  const prev = Number(pdpPrefetchRecentMap.get(key) || 0);
  if (prev > 0 && now - prev < AURORA_BFF_PDP_CORE_PREFETCH_DEDUP_TTL_MS) return false;
  pdpPrefetchRecentMap.set(key, now);
  if (pdpPrefetchRecentMap.size > 300) {
    const oldest = pdpPrefetchRecentMap.keys().next().value;
    if (oldest) pdpPrefetchRecentMap.delete(oldest);
  }
  return true;
}

async function invokePdpCorePrefetch(payload, { logger, reason = null } = {}) {
  if (!PIVOTA_BACKEND_BASE_URL) return { skipped: true, skip_reason: 'missing_base_url' };
  const normalized = normalizePdpCorePrefetchPayload(payload);
  if (!normalized) return { skipped: true, skip_reason: 'invalid_payload' };
  const invokeUrl = `${String(PIVOTA_BACKEND_BASE_URL || '').replace(/\/+$/, '')}/agent/shop/v1/invoke`;
  const reasonKey = normalizePdpPrefetchReason(reason);
  const prefetchKey = makePdpCorePrefetchKey(normalized) || null;
  const startedAt = Date.now();
  try {
    const resp = await axios.post(
      invokeUrl,
      {
        operation: 'get_pdp_v2',
        payload: {
          ...normalized,
          include: AURORA_BFF_PDP_CORE_PREFETCH_INCLUDE,
          capabilities: {
            client: 'aurora_bff_prefetch',
            client_version: 'v1',
          },
        },
      },
      {
        headers: buildPivotaBackendAgentHeaders(),
        timeout: AURORA_BFF_PDP_CORE_PREFETCH_TIMEOUT_MS,
        validateStatus: () => true,
      },
    );
    const status = Number(resp?.status || 0);
    const durationMs = Date.now() - startedAt;
    if (status >= 400) {
      recordPdpPrefetchResult({
        reason: reasonKey,
        status,
        ok: false,
        failed: false,
        key: prefetchKey || '',
        durationMs,
      });
      logger?.warn(
        {
          reason: reasonKey,
          status,
          key: prefetchKey,
          duration_ms: durationMs,
        },
        'aurora bff: pdp core prefetch non-200',
      );
      return { ok: false, status, duration_ms: durationMs, key: prefetchKey };
    }
    recordPdpPrefetchResult({
      reason: reasonKey,
      status,
      ok: true,
      failed: false,
      key: prefetchKey || '',
      durationMs,
    });
    return { ok: true, status, duration_ms: durationMs, key: prefetchKey };
  } catch (err) {
    const durationMs = Date.now() - startedAt;
    const errMessage = err?.message || String(err);
    recordPdpPrefetchResult({
      reason: reasonKey,
      status: 0,
      ok: false,
      failed: true,
      key: prefetchKey || '',
      durationMs,
      error: errMessage,
    });
    logger?.warn(
      {
        reason: reasonKey,
        err: errMessage,
        key: prefetchKey,
        duration_ms: durationMs,
      },
      'aurora bff: pdp core prefetch failed',
    );
    return { ok: false, status: 0, duration_ms: durationMs, key: prefetchKey, error: errMessage };
  }
}

function schedulePdpCorePrefetchFromItems(items, { logger, reason = null, maxItems = AURORA_BFF_PDP_CORE_PREFETCH_MAX_ITEMS } = {}) {
  if (!AURORA_BFF_PDP_CORE_PREFETCH_ENABLED || !PIVOTA_BACKEND_BASE_URL) return;
  const list = Array.isArray(items) ? items : [];
  if (!list.length) return;

  const targets = [];
  const limit = Math.max(1, Math.min(12, Number(maxItems) || AURORA_BFF_PDP_CORE_PREFETCH_MAX_ITEMS));
  for (const item of list) {
    const payload = extractPdpCorePrefetchPayloadFromItem(item);
    if (!payload) continue;
    const key = makePdpCorePrefetchKey(payload);
    if (!shouldRunPdpCorePrefetch(key)) continue;
    targets.push({ payload, key });
    if (targets.length >= limit) break;
  }
  if (!targets.length) return;

  void mapWithConcurrency(targets, 2, async (target) => {
    await invokePdpCorePrefetch(target.payload, { logger, reason });
  });
}

async function runPdpHotsetPrewarmBatch({ logger, reason = 'hotset_prewarm', allowWhenDisabled = false } = {}) {
  const reasonKey = normalizePdpPrefetchReason(reason);
  if (!PIVOTA_BACKEND_BASE_URL) {
    pdpPrefetchStats.hotset_runs.skipped_unavailable += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: false,
      skipped: true,
      skip_reason: 'missing_base_url',
      duration_ms: 0,
      hotset_size: 0,
    };
    return { ok: false, skipped: true, skip_reason: 'missing_base_url', hotset_size: 0, duration_ms: 0 };
  }
  if (!allowWhenDisabled && !AURORA_BFF_PDP_HOTSET_PREWARM_ENABLED) {
    pdpPrefetchStats.hotset_runs.skipped_disabled += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: false,
      skipped: true,
      skip_reason: 'feature_disabled',
      duration_ms: 0,
      hotset_size: 0,
    };
    return { ok: false, skipped: true, skip_reason: 'feature_disabled', hotset_size: 0, duration_ms: 0 };
  }
  const hotset = getNormalizedPdpHotsetPrewarmPayloads();
  if (!hotset.length) {
    pdpPrefetchStats.hotset_runs.skipped_no_hotset += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: false,
      skipped: true,
      skip_reason: 'empty_hotset',
      duration_ms: 0,
      hotset_size: 0,
    };
    return { ok: false, skipped: true, skip_reason: 'empty_hotset', hotset_size: 0, duration_ms: 0 };
  }
  if (pdpHotsetPrewarmInFlight) {
    pdpPrefetchStats.hotset_runs.skipped_in_flight += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: false,
      skipped: true,
      skip_reason: 'in_flight',
      duration_ms: 0,
      hotset_size: hotset.length,
    };
    return { ok: false, skipped: true, skip_reason: 'in_flight', hotset_size: hotset.length, duration_ms: 0 };
  }

  pdpHotsetPrewarmInFlight = true;
  pdpPrefetchStats.hotset_runs.started += 1;
  const startedAt = Date.now();
  try {
    await mapWithConcurrency(hotset, AURORA_BFF_PDP_HOTSET_PREWARM_CONCURRENCY, async (payload) => {
      await invokePdpCorePrefetch(payload, { logger, reason: reasonKey });
    });
    const durationMs = Date.now() - startedAt;
    pdpPrefetchStats.hotset_runs.completed += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: true,
      skipped: false,
      duration_ms: durationMs,
      hotset_size: hotset.length,
    };
    return { ok: true, skipped: false, duration_ms: durationMs, hotset_size: hotset.length };
  } catch (err) {
    const durationMs = Date.now() - startedAt;
    const errMessage = err?.message || String(err);
    pdpPrefetchStats.hotset_runs.failed += 1;
    pdpPrefetchStats.hotset_last = {
      at: new Date().toISOString(),
      reason: reasonKey,
      ok: false,
      skipped: false,
      duration_ms: durationMs,
      hotset_size: hotset.length,
      error: String(errMessage).slice(0, 400),
    };
    logger?.warn(
      {
        reason: reasonKey,
        hotset_size: hotset.length,
        duration_ms: durationMs,
        err: errMessage,
      },
      'aurora bff: pdp hotset prewarm run failed',
    );
    return { ok: false, skipped: false, duration_ms: durationMs, hotset_size: hotset.length, error: errMessage };
  } finally {
    pdpHotsetPrewarmInFlight = false;
  }
}

function startPdpHotsetPrewarmLoop({ logger } = {}) {
  if (pdpHotsetPrewarmStarted) return;
  if (!AURORA_BFF_PDP_HOTSET_PREWARM_ENABLED || !PIVOTA_BACKEND_BASE_URL) return;
  const hotset = getNormalizedPdpHotsetPrewarmPayloads();
  if (!hotset.length) return;

  pdpHotsetPrewarmStarted = true;
  const waitMs = async (ms) => {
    const delay = Math.max(0, Number(ms) || 0);
    if (!delay) return;
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  };

  const runOnce = async ({ reason = 'hotset_prewarm' } = {}) => {
    await runPdpHotsetPrewarmBatch({ logger, reason, allowWhenDisabled: false });
  };

  const runBootstrapBurst = async () => {
    for (let i = 0; i < AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_ROUNDS; i += 1) {
      const reason = i === 0 ? 'hotset_prewarm_startup' : 'hotset_prewarm_startup_followup';
      await runOnce({ reason });
      if (i < AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_ROUNDS - 1) {
        await waitMs(AURORA_BFF_PDP_HOTSET_PREWARM_BOOTSTRAP_GAP_MS);
      }
    }
  };

  setTimeout(() => {
    void runBootstrapBurst();
  }, AURORA_BFF_PDP_HOTSET_PREWARM_INITIAL_DELAY_MS);

  const timer = setInterval(() => {
    void runOnce({ reason: 'hotset_prewarm_interval' });
  }, AURORA_BFF_PDP_HOTSET_PREWARM_INTERVAL_MS);
  if (typeof timer.unref === 'function') timer.unref();
}

function buildRecoPdpQuickItem(item, { fastFallbackReasonCode = null } = {}) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
  if (!base) return item;
  const skuCandidate =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : null;

  const {
    subjectProductGroupId,
    directProductRef,
    rawProductId,
  } = extractRecoPdpDirectKeys(base, skuCandidate);
  if (subjectProductGroupId) {
    return withRecoPdpMetadata(base, {
      path: 'group',
      subject: { type: 'product_group', id: subjectProductGroupId, product_group_id: subjectProductGroupId },
      canonicalProductRef: directProductRef,
      resolveAttempted: false,
      timeToPdpMs: 0,
    });
  }
  if (directProductRef) {
    return withRecoPdpMetadata(base, {
      path: 'ref',
      canonicalProductRef: directProductRef,
      resolveAttempted: false,
      timeToPdpMs: 0,
    });
  }

  const brand = pickFirstTrimmed(skuCandidate?.brand, base.brand);
  const name = pickFirstTrimmed(skuCandidate?.name, base.name);
  const displayName = pickFirstTrimmed(
    skuCandidate?.display_name,
    skuCandidate?.displayName,
    base.display_name,
    base.displayName,
    name,
  );
  const stableProductId = pickFirstTrimmed(
    rawProductId,
    skuCandidate?.product_id,
    skuCandidate?.productId,
    base?.product_id,
    base?.productId,
  );
  const stableSkuId = pickFirstTrimmed(
    skuCandidate?.sku_id,
    skuCandidate?.skuId,
    base?.sku_id,
    base?.skuId,
    stableProductId,
  );
  const stableQueryText = pickFirstTrimmed(
    brand && displayName ? joinBrandAndName(brand, displayName) : '',
    brand && name ? joinBrandAndName(brand, name) : '',
    displayName,
    name,
    stableSkuId,
    stableProductId,
  );
  const stableAliasMatch = resolveRecoStableAliasRefByQuery(stableQueryText);
  if (stableAliasMatch?.canonicalProductRef) {
    return withRecoPdpMetadata(base, {
      path: 'ref',
      canonicalProductRef: stableAliasMatch.canonicalProductRef,
      resolveAttempted: false,
      timeToPdpMs: 0,
    });
  }

  const queryText =
    buildProductInputText(skuCandidate || base, typeof base.url === 'string' ? base.url : null) ||
    pickFirstTrimmed(
      skuCandidate?.display_name,
      skuCandidate?.displayName,
      skuCandidate?.name,
      base.display_name,
      base.displayName,
      base.name,
      base.brand,
    );
  if (fastFallbackReasonCode) {
    recordRecoPdpExternalFallback(fastFallbackReasonCode);
  }
  return withRecoPdpMetadata(base, {
    path: 'external',
    queryText,
    resolveReasonCode: fastFallbackReasonCode,
    resolveAttempted: false,
    timeToPdpMs: 0,
  });
}

async function enrichRecommendationsWithPdpOpenContract({
  recommendations,
  logger,
  fastExternalFallbackReasonCode = null,
} = {}) {
  const recos = Array.isArray(recommendations) ? recommendations : [];
  if (!recos.length) {
    return {
      recommendations: recos,
      path_stats: { group: 0, ref: 0, resolve: 0, external: 0 },
      fail_reason_counts: { db_error: 0, upstream_timeout: 0, no_candidates: 0 },
      time_to_pdp_ms_stats: { count: 0, mean: 0, p50: 0, p90: 0, max: 0 },
    };
  }

  const fastFallbackReasonCode = normalizeResolveReasonCode(fastExternalFallbackReasonCode || '', null);
  const shouldApplyFastExternalFallback = Boolean(fastFallbackReasonCode && RECO_PDP_FAST_EXTERNAL_FALLBACK_ENABLED);
  if (fastFallbackReasonCode && !shouldApplyFastExternalFallback) {
    recordRecoPdpExternalFallbackBlocked(recos.length);
  }
  if (shouldApplyFastExternalFallback) {
    const fastExternal = recos.map((item) => buildRecoPdpQuickItem(item, { fastFallbackReasonCode }));
    schedulePdpCorePrefetchFromItems(fastExternal, {
      logger,
      reason: 'reco_card_fast_fallback',
    });
    return {
      recommendations: fastExternal,
      path_stats: tallyPdpOpenPathStats(fastExternal),
      fail_reason_counts: tallyResolveFailReasonCounts(fastExternal),
      time_to_pdp_ms_stats: summarizeTimeToPdpStats(fastExternal),
    };
  }

  const networkItemCap = Math.max(0, Math.min(recos.length, RECO_PDP_ENRICH_MAX_NETWORK_ITEMS));
  const allowLocalInvokeFallback = !RECO_PDP_CHAT_DISABLE_LOCAL_DOUBLE_HOP;
  const enriched = await mapWithConcurrency(recos, RECO_PDP_ENRICH_CONCURRENCY, async (item, idx) => {
    if (idx >= networkItemCap) return buildRecoPdpQuickItem(item, { fastFallbackReasonCode: null });
    return enrichRecoItemWithPdpOpenContract(item, { logger, allowLocalInvokeFallback });
  });
  const normalized = enriched.map((item, idx) => {
    if (item && typeof item === 'object' && !Array.isArray(item)) return item;
    return recos[idx];
  });
  schedulePdpCorePrefetchFromItems(normalized, {
    logger,
    reason: 'reco_card',
  });

  return {
    recommendations: normalized,
    path_stats: tallyPdpOpenPathStats(normalized),
    fail_reason_counts: tallyResolveFailReasonCounts(normalized),
    time_to_pdp_ms_stats: summarizeTimeToPdpStats(normalized),
  };
}

function coerceRecoItemForUi(item, { lang } = {}) {
  const base = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
  if (!base) return item;

  const skuCandidate =
    base.sku && typeof base.sku === 'object' && !Array.isArray(base.sku)
      ? base.sku
      : base.product && typeof base.product === 'object' && !Array.isArray(base.product)
        ? base.product
        : null;

  const skuId =
    (skuCandidate && typeof skuCandidate.sku_id === 'string' ? skuCandidate.sku_id : null) ||
    (skuCandidate && typeof skuCandidate.skuId === 'string' ? skuCandidate.skuId : null) ||
    (typeof base.sku_id === 'string' ? base.sku_id : null) ||
    (typeof base.skuId === 'string' ? base.skuId : null) ||
    (skuCandidate && typeof skuCandidate.product_id === 'string' ? skuCandidate.product_id : null) ||
    (skuCandidate && typeof skuCandidate.productId === 'string' ? skuCandidate.productId : null) ||
    (typeof base.product_id === 'string' ? base.product_id : null) ||
    (typeof base.productId === 'string' ? base.productId : null) ||
    null;

  const productId =
    (skuCandidate && typeof skuCandidate.product_id === 'string' ? skuCandidate.product_id : null) ||
    (skuCandidate && typeof skuCandidate.productId === 'string' ? skuCandidate.productId : null) ||
    (typeof base.product_id === 'string' ? base.product_id : null) ||
    (typeof base.productId === 'string' ? base.productId : null) ||
    null;

  const brand =
    (skuCandidate && typeof skuCandidate.brand === 'string' ? skuCandidate.brand.trim() : '') ||
    (typeof base.brand === 'string' ? base.brand.trim() : '') ||
    '';
  const name =
    (skuCandidate && typeof skuCandidate.name === 'string' ? skuCandidate.name.trim() : '') ||
    (typeof base.name === 'string' ? base.name.trim() : '') ||
    '';
  const displayName =
    (skuCandidate && typeof skuCandidate.display_name === 'string' ? skuCandidate.display_name.trim() : '') ||
    (skuCandidate && typeof skuCandidate.displayName === 'string' ? skuCandidate.displayName.trim() : '') ||
    (typeof base.display_name === 'string' ? base.display_name.trim() : '') ||
    (typeof base.displayName === 'string' ? base.displayName.trim() : '') ||
    name ||
    '';
  const category =
    (skuCandidate && typeof skuCandidate.category === 'string' ? skuCandidate.category.trim() : '') ||
    (typeof base.category === 'string' ? base.category.trim() : '') ||
    '';

  const slotRaw = typeof base.slot === 'string' ? base.slot.trim().toLowerCase() : '';
  const slot = slotRaw === 'am' || slotRaw === 'pm' ? slotRaw : 'other';
  const step =
    (typeof base.step === 'string' && base.step.trim()) ||
    (typeof base.category === 'string' && base.category.trim()) ||
    category ||
    (String(lang || '').toUpperCase() === 'CN' ? '' : 'Recommendation');

  const notesRaw =
    Array.isArray(base.notes) ? base.notes
      : Array.isArray(base.reasons) ? base.reasons
        : Array.isArray(base.why) ? base.why
          : typeof base.reason === 'string' ? [base.reason]
            : typeof base.why === 'string' ? [base.why]
              : [];

  const notes = Array.isArray(notesRaw)
    ? notesRaw
      .map((v) => (typeof v === 'string' ? v.trim() : v == null ? '' : String(v).trim()))
      .filter(Boolean)
      .slice(0, 8)
    : [];

  const nextSku = skuCandidate || skuId || productId || brand || name || displayName || category
    ? {
      ...(skuCandidate && typeof skuCandidate === 'object' ? skuCandidate : {}),
      ...(skuId ? { sku_id: skuId } : {}),
      ...(productId ? { product_id: productId } : {}),
      ...(brand ? { brand } : {}),
      ...(name ? { name } : {}),
      ...(displayName ? { display_name: displayName } : {}),
      ...(category ? { category } : {}),
    }
    : null;

  return {
    ...base,
    slot,
    step,
    ...(nextSku ? { sku: nextSku } : {}),
    ...(notes.length ? { notes } : {}),
  };
}

function buildAuroraRoutineQuery({ profile, focus, constraints, lang }) {
  const skinType = profile && typeof profile.skinType === 'string' ? profile.skinType : 'unknown';
  const barrierStatus = mapBarrierStatus(profile && profile.barrierStatus);
  const concerns = mapConcerns(profile && profile.goals);
  const region = profile && typeof profile.region === 'string' && profile.region.trim() ? profile.region.trim() : 'US';
  const budgetKnown = normalizeBudgetHint(profile && profile.budgetTier) || normalizeBudgetHint(constraints && constraints.budget) || '';
  const budget = budgetKnown || 'unknown';
  const goal = typeof focus === 'string' && focus.trim()
    ? focus.trim()
    : constraints && typeof constraints.goal === 'string' && constraints.goal.trim()
      ? constraints.goal.trim()
      : 'balanced routine';
  const preference = constraints && typeof constraints.preference === 'string' && constraints.preference.trim()
    ? constraints.preference.trim()
    : 'No special preference';

  const concernsStr = concerns.length ? concerns.join(', ') : 'none';
  const reply = lang === 'CN' ? 'Chinese' : 'English';
  const budgetRule = budgetKnown
    ? 'Budget is provided; keep product picks close to this budget band.'
    : 'Budget is unknown; provide a balanced-value baseline first and do not ask budget in the first response unless user explicitly asks to optimize by budget.';

  const productsNote = profile && profile.currentRoutine ? `Current routine: ${JSON.stringify(profile.currentRoutine).slice(0, 1000)}\n` : '';

  return (
    `User profile: skin type ${skinType}; barrier status: ${barrierStatus}; concerns: ${concernsStr}; region: ${region}; budget: ${budget}.\n` +
    `Goal: ${goal}.\n` +
    `${productsNote}` +
    `Preference: ${preference}.\n` +
    `${budgetRule}\n` +
    `Please recommend a simple AM/PM skincare routine. Reply in ${reply}.`
  );
}

function buildAuroraProductRecommendationsQuery({ profile, requestText, lang }) {
  const skinType = profile && typeof profile.skinType === 'string' ? profile.skinType : 'unknown';
  const barrierStatus = mapBarrierStatus(profile && profile.barrierStatus);
  const concerns = mapConcerns(profile && profile.goals);
  const region = profile && typeof profile.region === 'string' && profile.region.trim() ? profile.region.trim() : 'US';
  const budgetKnown = normalizeBudgetHint(profile && profile.budgetTier) || '';
  const budget = budgetKnown || 'unknown';
  const concernsStr = concerns.length ? concerns.join(', ') : 'none';
  const replyLang = lang === 'CN' ? 'Chinese' : 'English';
  const req = typeof requestText === 'string' ? requestText.trim() : '';
  const budgetReasonRule = budgetKnown
    ? 'If budget is known, include one reason that references budget fit.'
    : 'If budget is unknown, do not ask budget in the first response; focus on efficacy/tolerance and balanced value.';

  return (
    `User profile: skin type ${skinType}; barrier status: ${barrierStatus}; concerns: ${concernsStr}; region: ${region}; budget: ${budget}.\n` +
    (req ? `User request: ${req}\n` : '') +
    `Task: Generate skincare product picks (NOT a full AM/PM routine).\n` +
    `Return ONLY a JSON object with keys: recommendations (array), evidence (object), confidence (0..1), missing_info (string[]), warnings (string[]).\n` +
    `recommendations: up to 5 items, ranked.\n` +
    `Each recommendation item MUST include:\n` +
    `- slot: "other"\n` +
    `- step: category label (cleanser/sunscreen/treatment/moisturizer/other)\n` +
    `- score: integer 0..100 (fit score)\n` +
    `- sku: {brand,name,display_name,sku_id,product_id,category,availability(string[]),price{usd,cny,unknown}}\n` +
    `- reasons: string[] (max 4). Reasons must be end-user readable and user-specific.\n` +
    `  - Include at least one reason that explicitly references the user's profile (skin type / sensitivity / barrier / goals).\n` +
    `  - ${budgetReasonRule}\n` +
    `  - If recent_logs were provided, include one reason that references the last 7 days trend; otherwise add warnings: "recent_logs_missing".\n` +
    `  - If profile.itinerary (upcoming plan/travel context) is available, include one reason that references it.\n` +
    `  - If upcoming plan/travel context is not available, add warnings: "itinerary_unknown" (do NOT guess).\n` +
    `- evidence_pack: {keyActives,sensitivityFlags,pairingRules,comparisonNotes,citations} (omit unknown keys; do NOT fabricate).\n` +
    `- missing_info: string[] (per-item; ONLY user-provided fields like budget_unknown)\n` +
    `- warnings: string[] (per-item; quality signals like over_budget/price_unknown/recent_logs_missing)\n` +
    `Rules:\n` +
    `- Do NOT include checkout links.\n` +
    `- Do NOT recommend the exact same sku_id/product_id twice.\n` +
    `- If unsure, use null/unknown and list missing_info/warnings (do not fabricate).\n` +
    `- All free-text strings should be in ${replyLang}.\n`
  );
}

function looksLikeRoutineRequest(message, action) {
  const text = String(message || '').trim().toLowerCase();
  const id =
    typeof action === 'string'
      ? action
      : action && typeof action === 'object'
        ? action.action_id
        : '';
  const idText = String(id || '').trim().toLowerCase();

  const routineByAction = idText.includes('routine') || idText.includes('reco_routine');
  const routineByMessage =
    Boolean(text) &&
    (text.includes('routine') ||
      /am\s*\/\s*pm/.test(text) ||
      /.*(|am|pm).*(|routine)/.test(text) ||
      /(|)/.test(text));

  // Guard against stale UI action_id leakage: when user typed a non-routine message,
  // do not let a previous routine chip/action force routine routing.
  if (routineByAction && text && !routineByMessage) return false;

  if (routineByAction) return true;
  return routineByMessage;
}

function looksLikeIngredientScienceIntent(message, action) {
  const raw = String(message || '').trim();
  const text = raw.toLowerCase();
  const id =
    typeof action === 'string'
      ? action
      : action && typeof action === 'object'
        ? action.action_id
        : '';
  const idText = String(id || '').trim().toLowerCase();

  if (idText === 'chip.start.ingredients' || idText === 'chip_start_ingredients') return true;

  const en =
    /\b(ingredient|ingredients|active|actives)\b.{0,28}\b(science|evidence|mechanism|clinical|study|paper|citation|citations)\b/i.test(raw) ||
    /\b(science|evidence|mechanism|clinical|study|paper|citation|citations)\b.{0,28}\b(ingredient|ingredients|active|actives)\b/i.test(raw);
  const cn = /((||||)|||||)/.test(raw);
  return en || cn;
}

function messageContainsSpecificIngredientScienceTarget(message) {
  const raw = String(message || '').trim();
  if (!raw) return false;
  const lower = raw.toLowerCase();
  if (extractKnownActivesFromText(raw).length > 0) return true;

  const specificIngredient =
    /\b(niacinamide|retinol|retinoid|adapalene|tretinoin|vitamin\s*c|ascorbic|azelaic|salicylic|glycolic|mandelic|pha|ceramide|peptide|tranexamic|arbutin)\b/i
      .test(lower) ||
    /(|a|a||c|c|||||||||)/.test(raw);
  if (specificIngredient) return true;

  const specificEffect =
    /\b(acne|breakout|redness|sensitive|dark spots?|hyperpigmentation|brightening|pores?|anti[-\s]?aging|wrinkles?|barrier|irritation)\b/i.test(lower) ||
    /(|||||||||||||)/.test(raw);
  return specificEffect;
}

function buildIngredientScienceKickoff({ language } = {}) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  if (lang === 'CN') {
    return {
      prompt:
        ' +  + \n' +
        '',
      chips: [
        {
          chip_id: 'chip.science.target.niacinamide',
          label: '',
          kind: 'quick_reply',
          data: { reply_text: '' },
        },
        {
          chip_id: 'chip.science.target.retinoid',
          label: 'A/A',
          kind: 'quick_reply',
          data: { reply_text: 'A/A' },
        },
        {
          chip_id: 'chip.science.target.vitc',
          label: 'C',
          kind: 'quick_reply',
          data: { reply_text: 'C' },
        },
        {
          chip_id: 'chip.science.goal.brightening',
          label: '/',
          kind: 'quick_reply',
          data: { reply_text: '/' },
        },
        {
          chip_id: 'chip.science.goal.acne',
          label: '/',
          kind: 'quick_reply',
          data: { reply_text: '/' },
        },
        {
          chip_id: 'chip.science.goal.redness',
          label: '',
          kind: 'quick_reply',
          data: { reply_text: '' },
        },
      ],
    };
  }

  return {
    prompt:
      "Great question. Ill keep this evidence-based and practical.\n" +
      "Before I answer, which direction should we focus on first?",
    chips: [
      {
        chip_id: 'chip.science.target.niacinamide',
        label: 'Niacinamide (evidence)',
        kind: 'quick_reply',
        data: { reply_text: 'Ingredient science: niacinamide  explain evidence strength, who it fits, and key risks.' },
      },
      {
        chip_id: 'chip.science.target.retinoid',
        label: 'Retinoids (evidence)',
        kind: 'quick_reply',
        data: { reply_text: 'Ingredient science: retinoids  explain mechanism, evidence quality, and risk controls.' },
      },
      {
        chip_id: 'chip.science.target.vitc',
        label: 'Vitamin C (evidence)',
        kind: 'quick_reply',
        data: { reply_text: 'Ingredient science: vitamin C  explain evidence, stability concerns, and irritation risk.' },
      },
      {
        chip_id: 'chip.science.goal.brightening',
        label: 'Goal: dark spots',
        kind: 'quick_reply',
        data: { reply_text: 'Science-only: explain ingredient mechanisms/evidence for dark spots and brightening (no product picks yet).' },
      },
      {
        chip_id: 'chip.science.goal.acne',
        label: 'Goal: acne/texture',
        kind: 'quick_reply',
        data: { reply_text: 'Science-only: explain ingredient mechanisms/evidence for acne and texture (no product picks yet).' },
      },
      {
        chip_id: 'chip.science.goal.redness',
        label: 'Goal: redness',
        kind: 'quick_reply',
        data: { reply_text: 'Science-only: explain ingredient mechanisms/evidence for redness-sensitive skin (no product picks yet).' },
      },
    ],
  };
}

function isBudgetClarificationAction(actionId, clarificationId) {
  const id = String(actionId || '').trim().toLowerCase();
  const cid = String(clarificationId || '').trim().toLowerCase();
  return id.startsWith('chip.clarify.budget') || id.startsWith('chip.budget.') || cid === 'budget';
}

function isBareBudgetSelectionMessage(message) {
  const text = String(message || '').trim();
  if (!text) return false;
  if (normalizeBudgetHint(text)) return true;
  return /^(not\s+sure|)$/i.test(text);
}

function buildBudgetGatePrompt(language) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  if (lang === 'CN') {
    return '';
  }
  return 'If you want, I can optimize this by budget. What monthly budget feels comfortable? (optional)';
}

function buildBudgetGateChips(language) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  const opts = [
    ['200', '200'],
    ['500', '500'],
    ['1000+', '1000+'],
    ['', lang === 'CN' ? '' : 'Not sure'],
  ];
  return opts.map(([tier, label]) => ({
    chip_id: `chip.budget.${tier.replace(/[^\w]+/g, '_')}`,
    label,
    kind: 'quick_reply',
    data: {
      profile_patch: { budgetTier: tier },
      include_alternatives: true,
      reply_text:
        lang === 'CN'
          ? tier === ''
            ? ''
            : ` AM/PM  ${tier} `
          : tier === ''
            ? 'Skip budget for now and continue.'
            : `Optimize the current AM/PM routine around ${tier} budget while keeping core efficacy.`,
    },
  }));
}

function isBudgetOptimizationEntryAction(actionId) {
  const id = String(actionId || '').trim().toLowerCase();
  return id === 'chip.budget.optimize.entry' || id === 'chip.action.budget_optimize';
}

function buildBudgetOptimizationEntryChip(language) {
  const lang = language === 'CN' ? 'CN' : 'EN';
  return {
    chip_id: 'chip.budget.optimize.entry',
    label: lang === 'CN' ? '' : 'Optimize by budget (optional)',
    kind: 'quick_reply',
    data: {
      include_alternatives: true,
      reply_text:
        lang === 'CN'
          ? ''
          : 'I want to optimize the current routine by budget.',
    },
  };
}

async function mapWithConcurrency(items, limit, worker) {
  const list = Array.isArray(items) ? items : [];
  if (!list.length) return [];

  const concurrency = Math.max(1, Math.min(8, Number.isFinite(Number(limit)) ? Math.trunc(Number(limit)) : 1));
  const out = new Array(list.length);
  let cursor = 0;

  async function runOne() {
    while (cursor < list.length) {
      const idx = cursor;
      cursor += 1;
      try {
        // eslint-disable-next-line no-await-in-loop
        out[idx] = await worker(list[idx], idx);
      } catch (err) {
        out[idx] = { ok: false, error: err instanceof Error ? err.message : String(err) };
      }
    }
  }

  const workers = Array.from({ length: Math.min(concurrency, list.length) }, () => runOne());
  await Promise.all(workers);
  return out;
}

function extractAnchorIdFromProductLike(obj) {
  if (!obj || typeof obj !== 'object') return null;
  const raw =
    (typeof obj.sku_id === 'string' && obj.sku_id) ||
    (typeof obj.skuId === 'string' && obj.skuId) ||
    (typeof obj.product_id === 'string' && obj.product_id) ||
    (typeof obj.productId === 'string' && obj.productId) ||
    null;
  const v = raw ? String(raw).trim() : '';
  return v || null;
}

function mergeFieldMissing(a, b) {
  const out = [];
  const seen = new Set();
  for (const item of [...(Array.isArray(a) ? a : []), ...(Array.isArray(b) ? b : [])]) {
    if (!item || typeof item !== 'object') continue;
    const field = typeof item.field === 'string' ? item.field.trim() : '';
    const reason = typeof item.reason === 'string' ? item.reason.trim() : '';
    if (!field || !reason) continue;
    const key = `${field}::${reason}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push({ field, reason });
  }
  return out;
}

async function fetchRecoAlternativesForProduct({ ctx, profileSummary, recentLogs, productInput, productObj, anchorId, maxTotal, debug, logger }) {
  const inputText = String(productInput || '').trim();
  const productJson = productObj && typeof productObj === 'object' ? JSON.stringify(productObj).slice(0, 1400) : '';
  const anchor = anchorId ? String(anchorId).trim() : '';
  const bestInput = inputText || anchor;
  if (!bestInput) return { ok: false, alternatives: [], field_missing: [{ field: 'alternatives', reason: 'product_identity_missing' }] };

  const normalizeAlternativesSkinType = (raw) => {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) return '';
    if (token.includes('oily')) return 'Oily';
    if (token.includes('dry')) return 'Dry';
    if (token.includes('combo') || token.includes('mix')) return 'Combo/Mixed';
    return '';
  };
  const normalizeAlternativesSensitivity = (raw) => {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) return '';
    if (token.includes('high') || token.includes('sensitive') || token.includes('reactive')) return 'High';
    if (token.includes('low')) return 'Low';
    if (token.includes('medium') || token.includes('mid')) return 'Medium';
    return '';
  };
  const normalizeAlternativesBarrier = (raw) => {
    const token = String(raw || '').trim().toLowerCase();
    if (!token) return '';
    if (
      token.includes('impaired') ||
      token.includes('stinging') ||
      token.includes('red') ||
      token.includes('damaged') ||
      token.includes('reactive')
    ) {
      return 'Impaired';
    }
    if (token.includes('stable') || token.includes('normal') || token.includes('healthy')) return 'Stable';
    return '';
  };
  const normalizeAlternativesGoal = (raw) => {
    const token = String(raw || '').trim();
    if (!token) return '';
    const lower = token.toLowerCase();
    if (lower.includes('acne') || lower.includes('texture') || lower.includes('pore')) return 'Acne/Texture';
    if (lower.includes('bright') || lower.includes('dark spot') || lower.includes('tone')) return 'Dark spots/Brightening';
    if (lower.includes('aging') || lower.includes('firm') || lower.includes('wrinkle')) return 'Aging';
    if (lower.includes('red') || lower.includes('barrier') || lower.includes('repair') || lower.includes('soothing')) {
      return 'Redness/Barrier repair';
    }
    if (lower.includes('hydrat') || lower.includes('moist')) return 'Hydration';
    return token.slice(0, 40);
  };
  const buildProfileSnapshot = (profileObjRaw, { forceConservative = false } = {}) => {
    const profileObjSafe =
      profileObjRaw && typeof profileObjRaw === 'object' && !Array.isArray(profileObjRaw)
        ? profileObjRaw
        : {};
    const skinTypeKnown = normalizeAlternativesSkinType(
      pickFirstTrimmed(profileObjSafe.skinType, profileObjSafe.skin_type, profileObjSafe.skin_type_text),
    );
    const sensitivityKnown = normalizeAlternativesSensitivity(
      pickFirstTrimmed(profileObjSafe.sensitivity, profileObjSafe.sensitivity_level),
    );
    const barrierKnown = normalizeAlternativesBarrier(
      pickFirstTrimmed(profileObjSafe.barrierStatus, profileObjSafe.barrier_status),
    );
    const goalsKnown = uniqCaseInsensitiveStrings(
      Array.isArray(profileObjSafe.goals)
        ? profileObjSafe.goals.map((item) => normalizeAlternativesGoal(item)).filter(Boolean)
        : [],
      3,
    );
    if (forceConservative) {
      return {
        skinType: skinTypeKnown || 'Oily',
        sensitivity: sensitivityKnown || 'Medium',
        barrierStatus: 'Impaired',
        goals: goalsKnown.length ? goalsKnown : ['Hydration'],
        assumptions_applied: true,
      };
    }
    return {
      skinType: skinTypeKnown || 'Combo/Mixed',
      sensitivity: sensitivityKnown || 'Medium',
      barrierStatus: barrierKnown || 'Impaired',
      goals: goalsKnown.length ? goalsKnown : ['Hydration'],
      assumptions_applied: !skinTypeKnown || !sensitivityKnown || !barrierKnown || !goalsKnown.length,
    };
  };
  const extractAlternativesRawFromUpstream = ({ upstream, structured, answerJson }) => {
    const structuredObj = structured && typeof structured === 'object' && !Array.isArray(structured) ? structured : null;
    const answerObj = answerJson && typeof answerJson === 'object' && !Array.isArray(answerJson) ? answerJson : null;
    if (Array.isArray(structuredObj?.alternatives)) return structuredObj.alternatives;
    if (Array.isArray(answerObj?.alternatives)) return answerObj.alternatives;

    const fromCards = [];
    const cards = Array.isArray(upstream?.cards) ? upstream.cards : [];
    for (const card of cards) {
      if (!card || typeof card !== 'object') continue;
      const type = String(card.type || '').trim().toLowerCase();
      const payload = card.payload && typeof card.payload === 'object' && !Array.isArray(card.payload) ? card.payload : null;
      if (!payload) continue;
      const candidateToAlt = (row, kind) => {
        const candidate = row && typeof row === 'object' && !Array.isArray(row) ? row : null;
        if (!candidate) return null;
        const productName = pickFirstTrimmed(candidate.display_name, candidate.name);
        if (!productName) return null;
        const product = {
          ...(pickFirstTrimmed(candidate.product_id, candidate.sku_id) ? { product_id: pickFirstTrimmed(candidate.product_id, candidate.sku_id) } : {}),
          ...(pickFirstTrimmed(candidate.sku_id) ? { sku_id: pickFirstTrimmed(candidate.sku_id) } : {}),
          ...(pickFirstTrimmed(candidate.brand) ? { brand: pickFirstTrimmed(candidate.brand) } : {}),
          name: productName,
          ...(pickFirstTrimmed(candidate.category) ? { category: pickFirstTrimmed(candidate.category) } : {}),
          ...(candidate.price && typeof candidate.price === 'object' ? { price: candidate.price } : {}),
        };
        const why = candidate.why_candidate;
        const reasons = Array.isArray(why)
          ? why
          : why && typeof why === 'object' && !Array.isArray(why) && Array.isArray(why.reasons_user_visible)
            ? why.reasons_user_visible
            : [];
        return {
          kind,
          product,
          ...(candidate.similarity_score != null ? { similarity_score: candidate.similarity_score } : {}),
          ...(reasons.length ? { reasons } : {}),
          tradeoffs: Array.isArray(candidate.compare_highlights) ? candidate.compare_highlights : [],
          evidence: {},
          missing_info: [],
        };
      };
      if (type === 'dupe_suggest') {
        for (const row of Array.isArray(payload.dupes) ? payload.dupes : []) {
          const alt = candidateToAlt(row, 'dupe');
          if (alt) fromCards.push(alt);
        }
        for (const row of Array.isArray(payload.comparables) ? payload.comparables : []) {
          const alt = candidateToAlt(row, 'similar');
          if (alt) fromCards.push(alt);
        }
      } else if (type === 'product_analysis') {
        for (const row of Array.isArray(payload?.dupes?.candidates) ? payload.dupes.candidates : []) {
          const alt = candidateToAlt(row, 'dupe');
          if (alt) fromCards.push(alt);
        }
        for (const row of Array.isArray(payload?.competitors?.candidates) ? payload.competitors.candidates : []) {
          const alt = candidateToAlt(row, 'similar');
          if (alt) fromCards.push(alt);
        }
      }
    }
    return fromCards;
  };

  const profileObj = profileSummary && typeof profileSummary === 'object' && !Array.isArray(profileSummary)
    ? profileSummary
    : {};

  const prefix = buildContextPrefix({
    profile: profileSummary || null,
    recentLogs: Array.isArray(recentLogs) ? recentLogs : [],
    lang: ctx.lang,
    trigger_source: ctx.trigger_source,
    intent: 'alternatives',
    action_id: 'chip.action.dupe_compare',
  });

  const attempts = [{ id: 'primary', forceConservative: false }, { id: 'conservative_retry', forceConservative: true }];
  const attemptDebug = [];
  let mapped = [];
  let lastStructured = null;
  let lastAnswerJson = null;
  let lastAlternativesRaw = [];
  let lastIntent = null;
  let lastError = null;
  for (const attempt of attempts) {
    const profileSnapshot = buildProfileSnapshot(profileObj, {
      forceConservative: attempt.forceConservative,
    });
    const profileSnapshotLine =
      `Profile snapshot (already available, do not re-ask): skinType=${profileSnapshot.skinType}; ` +
      `sensitivity=${profileSnapshot.sensitivity}; barrierStatus=${profileSnapshot.barrierStatus}; goals=${profileSnapshot.goals.join(', ')}`;
    const fallbackAssumptionLine = profileSnapshot.assumptions_applied
      ? 'Fallback assumption mode: profile may be incomplete; proceed now with conservative defaults and return best-effort alternatives.'
      : '';
    const query =
      `${prefix}` +
      `${profileSnapshotLine}\n` +
      (fallbackAssumptionLine ? `${fallbackAssumptionLine}\n` : '') +
      `Execution constraints:\n` +
      `- Do NOT ask clarifying questions.\n` +
      `- If some fields are missing, continue with general-audience assumptions and mark missing_info.\n` +
      `- Return alternatives based on available evidence instead of blocking on additional intake.\n` +
      `Task: Deep-scan this product and return alternatives (dupe/similar/premium) tailored to this user if possible.\n` +
      `Return ONLY a JSON object with keys: alternatives (array).\n` +
      `Each alternative item should include: product (object), similarity_score (0..1 or 0..100), tradeoffs (object), reasons (string[] max 2), evidence (object), missing_info (string[]).\n` +
      `Reasons must be end-user readable and explain why this alternative is useful for THIS user's profile/logs/budget (do NOT guess missing info; use missing_info).\n` +
      `Product: ${bestInput}\n` +
      (productJson ? `Product JSON: ${productJson}\n` : '');
    let upstream = null;
    try {
      upstream = await auroraChat({
        baseUrl: AURORA_DECISION_BASE_URL,
        query,
        timeoutMs: RECO_ALTERNATIVES_TIMEOUT_MS,
        ...(anchor ? { anchor_product_id: anchor } : {}),
        allow_recommendations: true,
        resume_context: {
          enabled: true,
          template_version: 'v2',
          flow_id: 'alternatives',
          include_history: true,
          clarification_history: [
            { question_id: 'skin_type', option: profileSnapshot.skinType },
            { question_id: 'sensitivity', option: profileSnapshot.sensitivity },
            { question_id: 'barrier_status', option: profileSnapshot.barrierStatus },
            { question_id: 'goals', option: profileSnapshot.goals[0] || 'Hydration' },
          ],
          resume_user_text: `Find dupe/similar/premium alternatives for ${bestInput}`,
          known_profile_fields: {
            skinType: profileSnapshot.skinType,
            sensitivity: profileSnapshot.sensitivity,
            barrierStatus: profileSnapshot.barrierStatus,
            goals: profileSnapshot.goals,
          },
        },
      });
    } catch (err) {
      lastError = err;
      logger?.warn(
        {
          err: err && err.message ? err.message : String(err),
          attempt: attempt.id,
        },
        'aurora bff: alternatives upstream failed',
      );
      attemptDebug.push({
        attempt: attempt.id,
        assumptions_applied: profileSnapshot.assumptions_applied,
        upstream_intent: null,
        error: err && err.message ? err.message : String(err),
        alternatives_raw_count: 0,
        alternatives_mapped_count: 0,
      });
      continue;
    }
    lastError = null;
    lastIntent = upstream && typeof upstream.intent === 'string' ? upstream.intent : null;
    const answerJson =
      upstream && typeof upstream.answer === 'string' ? extractJsonObjectByKeys(upstream.answer, ['alternatives']) : null;
    const structuredFallback = getUpstreamStructuredOrJson(upstream);
    const structured =
      answerJson && typeof answerJson === 'object' && !Array.isArray(answerJson) && Array.isArray(answerJson.alternatives)
        ? answerJson
        : structuredFallback || answerJson;
    const alternativesRaw = extractAlternativesRawFromUpstream({
      upstream,
      structured,
      answerJson,
    });
    const attemptMapped = mapAuroraAlternativesToRecoAlternatives(alternativesRaw, {
      lang: ctx.lang,
      maxTotal: maxTotal ?? 3,
    });
    attemptDebug.push({
      attempt: attempt.id,
      assumptions_applied: profileSnapshot.assumptions_applied,
      upstream_intent: lastIntent,
      has_structured: Boolean(upstream && upstream.structured),
      structured_keys:
        upstream && upstream.structured && typeof upstream.structured === 'object' && !Array.isArray(upstream.structured)
          ? Object.keys(upstream.structured).slice(0, 24)
          : [],
      alternatives_raw_count: Array.isArray(alternativesRaw) ? alternativesRaw.length : 0,
      alternatives_mapped_count: Array.isArray(attemptMapped) ? attemptMapped.length : 0,
    });
    lastStructured = structured;
    lastAnswerJson = answerJson;
    lastAlternativesRaw = Array.isArray(alternativesRaw) ? alternativesRaw : [];
    if (attemptMapped.length) {
      mapped = attemptMapped;
      break;
    }
    if (lastIntent !== 'clarify') break;
  }

  if (lastError && !mapped.length) {
    return {
      ok: false,
      alternatives: [],
      field_missing: [{ field: 'alternatives', reason: 'upstream_error' }],
      ...(debug
        ? {
          debug: {
            input: bestInput.slice(0, 200),
            anchor_id: anchor || null,
            product_json_preview: productJson ? productJson.slice(0, 300) : null,
            error: lastError && lastError.message ? lastError.message : String(lastError),
            attempts: attemptDebug,
          },
        }
        : {}),
    };
  }

  return {
    ok: true,
    alternatives: mapped,
    field_missing: mapped.length
      ? []
      : [{ field: 'alternatives', reason: lastStructured ? 'upstream_missing_or_empty' : 'upstream_missing_or_unstructured' }],
    ...(debug
      ? {
        debug: {
          input: bestInput.slice(0, 200),
          anchor_id: anchor || null,
          product_json_preview: productJson ? productJson.slice(0, 300) : null,
          upstream_intent: lastIntent,
          extracted_answer_json_keys:
            lastAnswerJson && typeof lastAnswerJson === 'object' && !Array.isArray(lastAnswerJson)
              ? Object.keys(lastAnswerJson).slice(0, 24)
              : [],
          extracted_structured_keys:
            lastStructured && typeof lastStructured === 'object' && !Array.isArray(lastStructured)
              ? Object.keys(lastStructured).slice(0, 24)
              : [],
          alternatives_raw_count: Array.isArray(lastAlternativesRaw) ? lastAlternativesRaw.length : 0,
          alternatives_mapped_count: mapped.length,
          attempts: attemptDebug,
        },
      }
      : {}),
  };
}

async function enrichRecommendationsWithAlternatives({ ctx, profileSummary, recentLogs, recommendations, debug, logger }) {
  const recos = Array.isArray(recommendations) ? recommendations : [];
  const maxProducts = RECO_ALTERNATIVES_MAX_PRODUCTS;
  if (!recos.length || maxProducts <= 0) return { recommendations: recos, field_missing: [] };

  if (!AURORA_DECISION_BASE_URL && !USE_AURORA_BFF_MOCK) {
    return { recommendations: recos, field_missing: [{ field: 'recommendations[].alternatives', reason: 'aurora_not_configured' }] };
  }

  const firstBySlot = { am: null, pm: null, other: null };
  for (let i = 0; i < recos.length; i += 1) {
    const item = recos[i];
    const slot = item && typeof item === 'object' ? String(item.slot || '').trim().toLowerCase() : '';
    const key = slot === 'am' ? 'am' : slot === 'pm' ? 'pm' : 'other';
    if (firstBySlot[key] == null) firstBySlot[key] = i;
  }

  const orderedIdx = [];
  const seenIdx = new Set();
  for (const key of ['am', 'pm', 'other']) {
    const idx = firstBySlot[key];
    if (typeof idx !== 'number') continue;
    if (seenIdx.has(idx)) continue;
    seenIdx.add(idx);
    orderedIdx.push(idx);
  }
  for (let i = 0; i < recos.length; i += 1) {
    if (seenIdx.has(i)) continue;
    orderedIdx.push(i);
  }

  const targets = [];
  for (const idx of orderedIdx) {
    if (targets.length >= maxProducts) break;
    const item = recos[idx];
    const base = item && typeof item === 'object' ? item : null;
    const candidate =
      base && base.sku && typeof base.sku === 'object'
        ? base.sku
        : base && base.product && typeof base.product === 'object'
          ? base.product
          : base;

    const inputText = buildProductInputText(candidate, base && typeof base.url === 'string' ? base.url : null);
    const anchorId = extractAnchorIdFromProductLike(candidate) || extractAnchorIdFromProductLike(base);
    if (!inputText && !anchorId) continue;
    targets.push({ idx, inputText, anchorId, productObj: candidate });
  }

  if (!targets.length) {
    return { recommendations: recos, field_missing: [{ field: 'recommendations[].alternatives', reason: 'recommendations_missing_product_identity' }] };
  }

  const results = await mapWithConcurrency(targets, RECO_ALTERNATIVES_CONCURRENCY, async (t) => {
    const out = await fetchRecoAlternativesForProduct({
      ctx,
      profileSummary,
      recentLogs,
      productInput: t.inputText,
      productObj: t.productObj,
      anchorId: t.anchorId,
      debug,
      logger,
    });
    return { ...out, idx: t.idx };
  });

  const enriched = recos.slice();
  let anyEmpty = false;
  for (const r of results) {
    if (!r || typeof r !== 'object' || typeof r.idx !== 'number') continue;
    const base = enriched[r.idx];
    const next = base && typeof base === 'object' ? { ...base } : {};
    next.alternatives = Array.isArray(r.alternatives) ? r.alternatives : [];
    enriched[r.idx] = next;
    if (!next.alternatives.length) anyEmpty = true;
  }

  const field_missing = anyEmpty ? [{ field: 'recommendations[].alternatives', reason: 'alternatives_partial' }] : [];
  const debugInfo = debug
    ? results
      .map((r) => (r && typeof r === 'object' && r.debug ? { idx: r.idx, ...r.debug } : null))
      .filter(Boolean)
      .slice(0, 8)
    : null;
  return { recommendations: enriched, field_missing, ...(debugInfo ? { debug: debugInfo } : {}) };
}

async function generateRoutineReco({ ctx, profile, recentLogs, focus, constraints, includeAlternatives, logger }) {
  const profileSummary = summarizeProfileForContext(profile);
  const query = buildAuroraRoutineQuery({
    profile: { ...profileSummary, ...(profile && profile.currentRoutine ? { currentRoutine: profile.currentRoutine } : {}) },
    focus,
    constraints: constraints || {},
    lang: ctx.lang,
  });

  let upstream = null;
  try {
    upstream = await auroraChat({ baseUrl: AURORA_DECISION_BASE_URL, query, timeoutMs: RECO_ROUTINE_UPSTREAM_TIMEOUT_MS });
  } catch (err) {
    if (err && err.code !== 'AURORA_NOT_CONFIGURED') {
      logger?.warn({ err: err.message }, 'aurora bff: routine upstream failed');
    }
  }

  const contextObj = upstream && upstream.context && typeof upstream.context === 'object' ? upstream.context : null;
  const routine = contextObj ? contextObj.routine : null;
  const contextMeta = contextObj && typeof contextObj === 'object' && !Array.isArray(contextObj) ? { ...contextObj } : {};
  if (profileSummary && profileSummary.budgetTier && !contextMeta.budget && !contextMeta.budget_cny) {
    contextMeta.budget = profileSummary.budgetTier;
  }
  const mapped = mapAuroraRoutineToRecoGenerate(routine, contextMeta);
  const norm = normalizeRecoGenerate(mapped);
  norm.payload = { ...norm.payload, intent: 'routine', profile: profileSummary || null };

  if (includeAlternatives) {
    const alt = await enrichRecommendationsWithAlternatives({
      ctx,
      profileSummary,
      recentLogs,
      recommendations: norm.payload.recommendations,
      logger,
    });
    norm.payload = { ...norm.payload, recommendations: alt.recommendations };
    norm.field_missing = mergeFieldMissing(norm.field_missing, alt.field_missing);
  }

  const budgetKnown = normalizeBudgetHint(profileSummary && profileSummary.budgetTier);
  if (budgetKnown && Array.isArray(norm.payload?.missing_info)) {
    norm.payload.missing_info = norm.payload.missing_info.filter((code) => String(code) !== 'budget_unknown');
  }

  const pdpOpenOut = await enrichRecommendationsWithPdpOpenContract({
    recommendations: norm.payload.recommendations,
    logger,
  });
  norm.payload = {
    ...norm.payload,
    recommendations: pdpOpenOut.recommendations,
    metadata: {
      ...(isPlainObject(norm.payload?.metadata) ? norm.payload.metadata : {}),
      pdp_open_path_stats: pdpOpenOut.path_stats,
      resolve_fail_reason_counts: pdpOpenOut.fail_reason_counts,
      time_to_pdp_ms_stats: pdpOpenOut.time_to_pdp_ms_stats,
    },
  };

  const suggestedChips = [];
  const nextActions = upstream && Array.isArray(upstream.next_actions) ? upstream.next_actions : [];
  if ((!norm.payload.recommendations || norm.payload.recommendations.length === 0) && nextActions.length) {
    for (const act of nextActions.slice(0, 8)) {
      if (!act || typeof act !== 'object') continue;
      const label = typeof act.label === 'string' ? act.label.trim() : typeof act.text === 'string' ? act.text.trim() : '';
      const text = typeof act.text === 'string' ? act.text.trim() : label;
      const id = typeof act.id === 'string' ? act.id.trim() : '';
      if (!label) continue;
      suggestedChips.push({
        chip_id: `chip.aurora.next_action.${id || label.replace(/\\s+/g, '_')}`.slice(0, 80),
        label,
        kind: 'quick_reply',
        data: { reply_text: text, aurora_action_id: id || null },
      });
    }
  }

  return { norm, suggestedChips };
}

async function generateProductRecommendations({ ctx, profile, recentLogs, message, includeAlternatives, debug, logger }) {
  const profileSummary = summarizeProfileForContext(profile);
  const analysisSummary =
    profile && profile.lastAnalysis && (!profile.lastAnalysisLang || profile.lastAnalysisLang === ctx.lang) ? profile.lastAnalysis : null;
  const analysisSummaryAt = profile && profile.lastAnalysisAt ? profile.lastAnalysisAt : null;
  const prefix = buildContextPrefix({
    profile: profileSummary || null,
    recentLogs: Array.isArray(recentLogs) ? recentLogs : [],
    lang: ctx.lang,
    state: ctx.state,
    trigger_source: ctx.trigger_source,
    action_id: 'chip.start.reco_products',
    intent: 'reco_products',
    ...(analysisSummary ? { analysis_summary: analysisSummary } : {}),
    ...(analysisSummaryAt ? { analysis_summary_at: analysisSummaryAt } : {}),
  });
  const userAsk =
    String(message || '').trim() ||
    (ctx.lang === 'CN' ? '' : 'Recommend a few skincare products for my profile and goals.');

  let upstream = null;
  let contextMeta = {};

  const catalogOut = await buildRecoGenerateFromCatalog({ ctx, profileSummary, debug, logger });
  const catalogStructured =
    catalogOut && typeof catalogOut === 'object' && catalogOut.structured && typeof catalogOut.structured === 'object'
      ? catalogOut.structured
      : null;
  const catalogDebug =
    catalogOut && typeof catalogOut === 'object' && catalogOut.debug && typeof catalogOut.debug === 'object'
      ? catalogOut.debug
      : null;
  const pdpFastFallbackReasonCode = deriveRecoPdpFastFallbackReasonCode(catalogDebug);
  const pdpFastExternalFallbackReasonCode = RECO_PDP_FAST_EXTERNAL_FALLBACK_ENABLED ? pdpFastFallbackReasonCode : null;
  const useCatalogTransientFallback = shouldUseRecoCatalogTransientFallback(catalogDebug);
  const catalogTransientFallbackStructured = useCatalogTransientFallback
    ? buildRecoCatalogTransientFallbackStructured({ ctx })
    : null;

  // Prefer: catalog-grounded  explicit JSON (from answer)  routine object (from context)  any structured blob.
  let structured = catalogStructured || catalogTransientFallbackStructured;
  let structuredSource = catalogStructured
    ? 'catalog_grounded'
    : catalogTransientFallbackStructured
      ? 'catalog_transient_fallback'
      : null;
  let answerJson = null;

  if (!structured) {
    const query =
      `${prefix}` +
      buildAuroraProductRecommendationsQuery({
        profile: profileSummary || {},
        requestText: userAsk,
        lang: ctx.lang,
      });

    try {
      upstream = await auroraChat({ baseUrl: AURORA_DECISION_BASE_URL, query, timeoutMs: RECO_UPSTREAM_TIMEOUT_MS });
    } catch (err) {
      if (err && err.code !== 'AURORA_NOT_CONFIGURED') {
        logger?.warn({ err: err.message }, 'aurora bff: product reco upstream failed');
      }
    }

    const contextObj = upstream && upstream.context && typeof upstream.context === 'object' ? upstream.context : null;
    const routine = contextObj ? contextObj.routine : null;
    contextMeta = contextObj && typeof contextObj === 'object' && !Array.isArray(contextObj) ? { ...contextObj } : {};
    if (profileSummary && profileSummary.budgetTier && !contextMeta.budget && !contextMeta.budget_cny) {
      contextMeta.budget = profileSummary.budgetTier;
    }

    answerJson = upstream && typeof upstream.answer === 'string' ? extractJsonObjectByKeys(upstream.answer, ['recommendations']) : null;
    const structuredFallback = getUpstreamStructuredOrJson(upstream);

    structured = answerJson;
    structuredSource = answerJson ? 'answer_json' : null;
    if (!structured && routine) {
      structured = mapAuroraRoutineToRecoGenerate(routine, contextMeta);
      structuredSource = 'context_routine';
    }
    if (!structured) {
      structured = structuredFallback;
      structuredSource = structuredFallback ? 'structured_fallback' : null;
    }
  }

  const upstreamDebug = debug
    ? {
      intent: upstream && typeof upstream.intent === 'string' ? upstream.intent : null,
      has_structured: Boolean(upstream && upstream.structured),
      structured_keys:
        upstream && upstream.structured && typeof upstream.structured === 'object' && !Array.isArray(upstream.structured)
          ? Object.keys(upstream.structured).slice(0, 24)
          : [],
      answer_preview:
        upstream && typeof upstream.answer === 'string' ? upstream.answer.slice(0, 800) : null,
      cards_types: Array.isArray(upstream && upstream.cards)
        ? upstream.cards
          .map((c) => (c && typeof c === 'object' && typeof c.type === 'string' ? c.type : null))
          .filter(Boolean)
          .slice(0, 12)
        : [],
      clarification:
        upstream && upstream.clarification && typeof upstream.clarification === 'object' ? upstream.clarification : null,
      context_keys:
        upstream && upstream.context && typeof upstream.context === 'object' && !Array.isArray(upstream.context)
          ? Object.keys(upstream.context).slice(0, 24)
          : [],
      structured_source: structuredSource,
      extracted_answer_json_keys:
        answerJson && typeof answerJson === 'object' && !Array.isArray(answerJson) ? Object.keys(answerJson).slice(0, 24) : [],
      extracted_structured_keys:
        structured && typeof structured === 'object' && !Array.isArray(structured) ? Object.keys(structured).slice(0, 24) : [],
      reco_catalog_grounded_enabled: RECO_CATALOG_GROUNDED_ENABLED,
      reco_upstream_timeout_ms: RECO_UPSTREAM_TIMEOUT_MS,
      reco_upstream_timeout_hard_cap_ms: RECO_UPSTREAM_TIMEOUT_HARD_CAP_MS,
      reco_pdp_enrich_concurrency: RECO_PDP_ENRICH_CONCURRENCY,
      reco_pdp_enrich_max_network_items: RECO_PDP_ENRICH_MAX_NETWORK_ITEMS,
      reco_pdp_resolve_enabled: RECO_PDP_RESOLVE_ENABLED,
      reco_pdp_resolve_timeout_ms: RECO_PDP_RESOLVE_TIMEOUT_MS,
      reco_pdp_resolve_timeout_strict_min_ms: RECO_PDP_RESOLVE_TIMEOUT_STRICT_MIN_MS,
      reco_pdp_strict_internal_first: RECO_PDP_STRICT_INTERNAL_FIRST,
      pivota_backend_base_configured: Boolean(PIVOTA_BACKEND_BASE_URL),
      reco_pdp_chat_disable_local_double_hop: RECO_PDP_CHAT_DISABLE_LOCAL_DOUBLE_HOP,
      reco_local_fallback_chat_enabled: RECO_PDP_LOCAL_INVOKE_FALLBACK_CHAT_ENABLED,
      reco_local_search_fallback_on_transient: RECO_PDP_LOCAL_SEARCH_FALLBACK_ON_TRANSIENT,
      reco_catalog_transient_fallback_enabled: RECO_CATALOG_TRANSIENT_FALLBACK_ENABLED,
      reco_catalog_transient_fallback_applied: Boolean(catalogTransientFallbackStructured),
      reco_pdp_fast_external_fallback_enabled: RECO_PDP_FAST_EXTERNAL_FALLBACK_ENABLED,
      reco_catalog_debug: catalogDebug,
      reco_pdp_fast_fallback_reason: pdpFastFallbackReasonCode,
    }
    : null;
  const mapped = structured && typeof structured === 'object' && !Array.isArray(structured) ? { ...structured } : null;
  if (mapped && Array.isArray(mapped.recommendations)) {
    mapped.recommendations = mapped.recommendations.map((r) => coerceRecoItemForUi(r, { lang: ctx.lang }));
  }

  const norm = normalizeRecoGenerate(mapped);
  norm.payload = { ...norm.payload, intent: 'reco_products', profile: profileSummary || null };
  let recoSeedFilterInfo = {
    applied: false,
    seed_count_before: 0,
    seed_count_after: 0,
    filtered_count: 0,
  };
  let recoDiversityInfo = {
    enabled: RECO_DIVERSITY_ENABLED,
    applied: false,
    repeated_before: 0,
    repeated_after: 0,
    filtered_count: 0,
    history_size_before: 0,
    history_size_after: 0,
  };
  if (Array.isArray(norm.payload.recommendations) && norm.payload.recommendations.length) {
    const deduped = [];
    const seen = new Set();
    for (const item of norm.payload.recommendations) {
      if (!item || typeof item !== 'object') continue;
      const base = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
      const candidate =
        base && base.sku && typeof base.sku === 'object'
          ? base.sku
          : base && base.product && typeof base.product === 'object'
            ? base.product
            : base;
      const anchorId = extractAnchorIdFromProductLike(candidate) || extractAnchorIdFromProductLike(base);
      const inputText = buildProductInputText(candidate, null);
      const key = String(anchorId || inputText || '').trim().toLowerCase();
      if (!key) continue;
      if (seen.has(key)) continue;
      seen.add(key);
      deduped.push({ ...base, slot: 'other' });
      if (deduped.length >= 8) break;
    }
    const limited = limitRecoKnownTestSeedRecommendations(deduped);
    recoSeedFilterInfo = {
      applied: Boolean(limited.applied),
      seed_count_before: Number(limited.seed_count_before || 0),
      seed_count_after: Number(limited.seed_count_after || 0),
      filtered_count: Number(limited.filtered_count || 0),
    };
    let nextRecommendations = limited.recommendations;
    if (RECO_DIVERSITY_ENABLED && Array.isArray(nextRecommendations) && nextRecommendations.length) {
      const diversityHistoryKey = buildRecoDiversityHistoryKey(ctx);
      const historyState = getRecoRecentExposureState(diversityHistoryKey);
      const historyTokens = historyState.tokens;
      const diversityLimited = applyRecoRecentDiversityGuard(nextRecommendations, {
        historyTokens,
        maxRepeatPerResponse: RECO_DIVERSITY_MAX_REPEAT_PER_RESPONSE,
        minTotal: RECO_DIVERSITY_MIN_TOTAL,
        rotationRound: historyState.round + 1,
      });
      nextRecommendations = diversityLimited.recommendations;
      recoDiversityInfo = {
        enabled: true,
        applied: Boolean(diversityLimited.applied),
        repeated_before: Number(diversityLimited.repeated_before || 0),
        repeated_after: Number(diversityLimited.repeated_after || 0),
        filtered_count: Number(diversityLimited.filtered_count || 0),
        history_size_before: historyTokens.length,
        history_size_after: historyTokens.length,
      };

      const exposureTokens = (Array.isArray(nextRecommendations) ? nextRecommendations : [])
        .map((item) => buildRecoDiversityToken(item))
        .filter(Boolean)
        .slice(0, 8);
      updateRecoRecentExposureTokens(diversityHistoryKey, exposureTokens);
      const historyAfter = getRecoRecentExposureState(diversityHistoryKey);
      recoDiversityInfo.history_size_after = historyAfter.tokens.length;
    }
    norm.payload = { ...norm.payload, recommendations: nextRecommendations };
  }
  let alternativesDebug = null;
  if (upstreamDebug) {
    upstreamDebug.reco_test_seed_max_per_response = RECO_TEST_SEED_MAX_PER_RESPONSE;
    upstreamDebug.reco_test_seed_min_total = RECO_TEST_SEED_MIN_TOTAL;
    upstreamDebug.reco_seed_filter_applied = recoSeedFilterInfo.applied;
    upstreamDebug.reco_seed_count_before = recoSeedFilterInfo.seed_count_before;
    upstreamDebug.reco_seed_count_after = recoSeedFilterInfo.seed_count_after;
    upstreamDebug.reco_seed_filtered_count = recoSeedFilterInfo.filtered_count;
    upstreamDebug.reco_diversity_enabled = recoDiversityInfo.enabled;
    upstreamDebug.reco_diversity_applied = recoDiversityInfo.applied;
    upstreamDebug.reco_diversity_repeated_before = recoDiversityInfo.repeated_before;
    upstreamDebug.reco_diversity_repeated_after = recoDiversityInfo.repeated_after;
    upstreamDebug.reco_diversity_filtered_count = recoDiversityInfo.filtered_count;
    upstreamDebug.reco_diversity_history_size_before = recoDiversityInfo.history_size_before;
    upstreamDebug.reco_diversity_history_size_after = recoDiversityInfo.history_size_after;
  }

  if (includeAlternatives) {
    const alt = await enrichRecommendationsWithAlternatives({
      ctx,
      profileSummary,
      recentLogs,
      recommendations: norm.payload.recommendations,
      debug,
      logger,
    });
    norm.payload = { ...norm.payload, recommendations: alt.recommendations };
    norm.field_missing = mergeFieldMissing(norm.field_missing, alt.field_missing);
    if (debug && alt && typeof alt === 'object' && alt.debug) {
      alternativesDebug = alt.debug;
    }
  }

  const budgetKnown = normalizeBudgetHint(profileSummary && profileSummary.budgetTier);
  if (budgetKnown && Array.isArray(norm.payload?.missing_info)) {
    norm.payload.missing_info = norm.payload.missing_info.filter((code) => String(code) !== 'budget_unknown');
  }

  const uniqStrings = (items, max = null) => {
    const out = [];
    const seen = new Set();
    for (const raw of Array.isArray(items) ? items : []) {
      const s = typeof raw === 'string' ? raw.trim() : raw == null ? '' : String(raw).trim();
      if (!s) continue;
      const key = s.toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(s);
      if (typeof max === 'number' && max > 0 && out.length >= max) break;
    }
    return out;
  };

  const itineraryText = profileSummary && typeof profileSummary.itinerary === 'string' ? profileSummary.itinerary.trim() : '';
  const itinerary = itineraryText ? itineraryText.slice(0, 160) : '';
  if (itinerary && Array.isArray(norm.payload?.recommendations)) {
    const itineraryReason = ctx.lang === 'CN' ? `${itinerary}` : `Upcoming plan: ${itinerary}`;
    const itineraryRegex =
      ctx.lang === 'CN'
        ? /(||||||||)/
        : /\b(upcoming plan|itinerary|travel|trip|flight|outdoor|cold|dry|uv|ski)\b/i;

    const pickReasons = (reasonsRaw) => {
      const base = uniqStrings(reasonsRaw, 12);
      const alreadyHasItinerary = base.some((r) => itineraryRegex.test(String(r || '')));
      const reasons = alreadyHasItinerary ? base : [...base, itineraryReason];

      const activeRegex =
        ctx.lang === 'CN'
          ? /(|||)/
          : /\b(most effective active|hero ingredient|key actives?|key ingredients?)\b/i;
      const goalRegex = ctx.lang === 'CN' ? /(||)/ : /\b(goal fit|targets?:|goals?:)\b/i;
      const barrierRegex =
        ctx.lang === 'CN'
          ? /(||||||)/
          : /\b(barrier|sensitivity|irritat|low[- ]irritation|patch test|tolerance)\b/i;
      const logsRegex =
        ctx.lang === 'CN'
          ? /(7|7||||||)/
          : /\b(last 7d|check-?in|redness|hydration)\b/i;
      const analysisRegex =
        ctx.lang === 'CN'
          ? /(|||)/
          : /\b(last skin analysis|skin analysis)\b/i;

      const picked = [];
      const usedIdx = new Set();
      const takeFirstMatch = (re) => {
        const idx = reasons.findIndex((r, i) => !usedIdx.has(i) && re.test(String(r || '')));
        if (idx === -1) return;
        usedIdx.add(idx);
        picked.push(reasons[idx]);
      };

      for (const re of [activeRegex, goalRegex, barrierRegex, logsRegex, analysisRegex, itineraryRegex]) {
        if (picked.length >= 6) break;
        takeFirstMatch(re);
      }

      for (let i = 0; i < reasons.length && picked.length < 6; i += 1) {
        if (usedIdx.has(i)) continue;
        picked.push(reasons[i]);
        usedIdx.add(i);
      }

      if (!picked.some((r) => itineraryRegex.test(String(r || '')))) {
        if (picked.length < 6) picked.push(itineraryReason);
        else picked[picked.length - 1] = itineraryReason;
      }

      return uniqStrings(picked, 6);
    };

    norm.payload.recommendations = norm.payload.recommendations.map((item) => {
      const base = item && typeof item === 'object' && !Array.isArray(item) ? item : null;
      if (!base) return item;
      const reasonsRaw = Array.isArray(base.reasons) ? base.reasons : [];
      return { ...base, reasons: pickReasons(reasonsRaw) };
    });
  }

  const pdpOpenOut = await enrichRecommendationsWithPdpOpenContract({
    recommendations: norm.payload.recommendations,
    logger,
    fastExternalFallbackReasonCode: pdpFastExternalFallbackReasonCode,
  });
  norm.payload = {
    ...norm.payload,
    recommendations: pdpOpenOut.recommendations,
    metadata: {
      ...(isPlainObject(norm.payload?.metadata) ? norm.payload.metadata : {}),
      pdp_open_path_stats: pdpOpenOut.path_stats,
      resolve_fail_reason_counts: pdpOpenOut.fail_reason_counts,
      time_to_pdp_ms_stats: pdpOpenOut.time_to_pdp_ms_stats,
    },
  };

  return { norm, upstreamDebug, alternativesDebug };
}

function parseBoolQueryValue(value, fallback = false) {
  if (value == null) return fallback;
  const token = String(value).trim().toLowerCase();
  if (!token) return fallback;
  if (token === '1' || token === 'true' || token === 'yes' || token === 'y' || token === 'on') return true;
  if (token === '0' || token === 'false' || token === 'no' || token === 'n' || token === 'off') return false;
  return fallback;
}

function parseIntQueryValue(value, fallback, min, max) {
  const n = Number(value);
  const v = Number.isFinite(n) ? Math.trunc(n) : fallback;
  return Math.max(min, Math.min(max, v));
}

function normalizeBlockToken(value) {
  const token = String(value == null ? '' : value).trim().toLowerCase();
  if (token === 'competitors' || token === 'dupes' || token === 'related_products') return token;
  return '';
}

function buildSuggestionLookupByBlock(suggestions = []) {
  const out = {
    competitors: new Map(),
    dupes: new Map(),
    related_products: new Map(),
  };
  for (const row of Array.isArray(suggestions) ? suggestions : []) {
    const block = normalizeBlockToken(row?.block);
    if (!block || !out[block]) continue;
    const key = String(row?.candidate_product_id || '').trim().toLowerCase();
    if (!key) continue;
    out[block].set(key, row);
  }
  return out;
}

function sanitizeSuggestionForPublic(row) {
  const item = row && typeof row === 'object' && !Array.isArray(row) ? row : null;
  if (!item) return null;
  return {
    id: String(item.id || '').trim(),
    suggested_label: String(item.suggested_label || '').trim(),
    wrong_block_target: item.wrong_block_target ? String(item.wrong_block_target).trim() : null,
    confidence: Number.isFinite(Number(item.confidence)) ? Math.max(0, Math.min(1, Number(item.confidence))) : 0,
    rationale_user_visible: String(item.rationale_user_visible || '').trim(),
    flags: Array.isArray(item.flags) ? item.flags.map((x) => String(x || '').trim()).filter(Boolean).slice(0, 10) : [],
    model_name: String(item.model_name || '').trim(),
    prompt_version: String(item.prompt_version || '').trim(),
    updated_at: item.updated_at || null,
  };
}

function attachPrelabelSuggestionsToPayload(payload, suggestions = []) {
  const p = isPlainObject(payload) ? { ...payload } : {};
  const lookup = buildSuggestionLookupByBlock(suggestions);
  for (const block of ['competitors', 'dupes', 'related_products']) {
    const blockObj = isPlainObject(p?.[block]) ? { ...p[block] } : null;
    if (!blockObj) continue;
    const rows = Array.isArray(blockObj.candidates) ? blockObj.candidates : [];
    blockObj.candidates = rows.map((row, idx) => {
      const item = isPlainObject(row) ? { ...row } : row;
      if (!isPlainObject(item)) return item;
      const key = String(item.product_id || item.sku_id || item.id || item.name || `idx:${idx + 1}`)
        .trim()
        .toLowerCase();
      const suggestion = lookup[block].get(key);
      if (!suggestion) return item;
      return {
        ...item,
        llm_suggestion: sanitizeSuggestionForPublic(suggestion),
      };
    });
    p[block] = blockObj;
  }
  return p;
}

function sanitizeProductAnalysisPayloadForPrelabel(payload) {
  const p = isPlainObject(payload) ? { ...payload } : {};
  const contracted = applyProductAnalysisGapContract(p);
  const nextPayload = isPlainObject(contracted) ? { ...contracted } : p;
  delete nextPayload.missing_info_internal;
  delete nextPayload.internal_debug_codes;
  delete nextPayload.llm_raw_response;
  delete nextPayload.suggestion_debug;
  delete nextPayload.input_hash;
  delete nextPayload.candidate_tracking;
  delete nextPayload.candidate_tracking_internal;
  delete nextPayload.internal_attribution;
  delete nextPayload.tracking;
  for (const block of ['competitors', 'dupes', 'related_products']) {
    const blockObj = isPlainObject(nextPayload?.[block]) ? { ...nextPayload[block] } : null;
    if (!blockObj) continue;
    const rows = Array.isArray(blockObj.candidates) ? blockObj.candidates : [];
    blockObj.candidates = rows.map((row) => {
      const item = isPlainObject(row) ? { ...row } : row;
      if (!isPlainObject(item)) return item;
      delete item.ref_id;
      delete item.internal_reason_codes;
      delete item.input_hash;
      delete item.llm_raw_response;
      delete item.suggestion_debug;
      return item;
    });
    nextPayload[block] = blockObj;
  }
  return nextPayload;
}

function buildPrelabelKbKey(anchorProductId, lang = 'EN') {
  const anchor = String(anchorProductId || '').trim();
  if (!anchor) return '';
  const langCode = String(lang || '').trim().toUpperCase() === 'CN' ? 'CN' : 'EN';
  return normalizeProductIntelKbKey(`product:${anchor}|lang:${langCode}`);
}

function mapSuggestionForResponse(row) {
  const item = sanitizeSuggestionForPublic(row);
  if (!item) return null;
  return {
    ...item,
    anchor_product_id: String(row?.anchor_product_id || '').trim(),
    block: normalizeBlockToken(row?.block),
    candidate_product_id: String(row?.candidate_product_id || '').trim(),
  };
}

function mountAuroraBffRoutes(app, { logger }) {
  startPdpHotsetPrewarmLoop({ logger });

  app.get('/metrics', (req, res) => {
    res.setHeader('Content-Type', 'text/plain; version=0.0.4; charset=utf-8');
    const visionMetrics = String(renderVisionMetricsPrometheus() || '');
    const recoMetrics = renderRecoPdpFallbackMetricsPrometheus();
    return res.status(200).send(`${visionMetrics}${recoMetrics}`);
  });

  app.get('/v1/ops/pdp-prefetch/state', (req, res) => {
    if (!AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    if (!hasPdpHotsetPrewarmAdminAccess(req)) {
      return res.status(403).json({ ok: false, error: 'FORBIDDEN' });
    }
    return res.status(200).json({
      ok: true,
      data: getPdpPrefetchStateSnapshot(),
    });
  });

  app.post('/v1/ops/pdp-prefetch/run', async (req, res) => {
    if (!AURORA_BFF_PDP_HOTSET_PREWARM_ADMIN_KEY) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    if (!hasPdpHotsetPrewarmAdminAccess(req)) {
      return res.status(403).json({ ok: false, error: 'FORBIDDEN' });
    }
    const reason = normalizePdpPrefetchReason(pickFirstTrimmed(req?.body?.reason, 'hotset_prewarm_manual'));
    const result = await runPdpHotsetPrewarmBatch({
      logger,
      reason,
      allowWhenDisabled: true,
    });
    return res.status(200).json({
      ok: true,
      result,
      data: getPdpPrefetchStateSnapshot(),
    });
  });

  app.post('/internal/prelabel', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode || !RECO_DOGFOOD_CONFIG.prelabel?.enabled || !AURORA_BFF_RECO_PRELABEL_ADMIN_KEY) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    if (!hasRecoPrelabelAdminAccess(req)) {
      return res.status(403).json({ ok: false, error: 'FORBIDDEN' });
    }
    const parsed = InternalPrelabelRequestSchema.safeParse(req.body || {});
    if (!parsed.success) {
      return res.status(400).json({ ok: false, error: 'BAD_REQUEST', details: parsed.error.format() });
    }
    try {
      const blocks = Array.isArray(parsed.data.blocks) && parsed.data.blocks.length
        ? parsed.data.blocks
        : ['competitors', 'dupes', 'related_products'];
      const out = await generatePrelabelsForAnchor({
        anchor_product_id: parsed.data.anchor_product_id,
        blocks,
        max_candidates_per_block: {
          ...(RECO_DOGFOOD_CONFIG.prelabel?.max_candidates_per_block || {}),
          ...(isPlainObject(parsed.data.max_candidates_per_block) ? parsed.data.max_candidates_per_block : {}),
        },
        force_refresh: parsed.data.force_refresh === true,
        snapshot_payload: isPlainObject(parsed.data.snapshot_payload) ? parsed.data.snapshot_payload : null,
        lang: ctx.lang,
        request_id: pickFirstTrimmed(parsed.data.request_id, ctx.request_id),
        session_id: pickFirstTrimmed(parsed.data.session_id, ctx.aurora_uid),
        logger,
        model_name: process.env.AURORA_BFF_RECO_PRELABEL_MODEL || 'gemini-2.0-flash',
        prompt_version: PRELABEL_PROMPT_VERSION,
        ttl_ms: RECO_DOGFOOD_CONFIG.prelabel?.ttl_ms,
        gemini_timeout_ms: RECO_DOGFOOD_CONFIG.prelabel?.timeout_ms,
      });

      for (const block of ['competitors', 'dupes', 'related_products']) {
        recordPrelabelRequest({ block, mode: 'main_path', delta: Number(out?.requested_by_block?.[block] || 0) });
        recordPrelabelSuccess({ block, mode: 'main_path', delta: Number(out?.generated_by_block?.[block] || 0) });
        recordPrelabelInvalidJson({ block, mode: 'main_path', delta: Number(out?.invalid_json_by_block?.[block] || 0) });
        recordPrelabelCacheHit({ block, mode: 'main_path', delta: Number(out?.cache_hit_by_block?.[block] || 0) });
        recordSuggestionsGeneratedPerBlock({ block, mode: 'main_path', delta: Number(out?.suggestions_by_block?.[block]?.length || 0) });
      }
      for (const latency of Array.isArray(out?.gemini_latency_ms) ? out.gemini_latency_ms : []) {
        observePrelabelGeminiLatency({ latencyMs: latency });
      }
      const totalRequested = Number(out?.candidates_total || 0);
      const totalHits = Number(out?.cache_hit_count || 0);
      if (totalRequested > 0) setPrelabelCacheHitRate(totalHits / totalRequested);

      return res.status(200).json({
        ok: true,
        data: out,
      });
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err), request_id: ctx.request_id }, 'aurora bff: internal prelabel failed');
      return res.status(500).json({ ok: false, error: 'PRELABEL_FAILED' });
    }
  });

  app.get('/internal/prelabel/suggestions', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode || !RECO_DOGFOOD_CONFIG.prelabel?.enabled || !AURORA_BFF_RECO_PRELABEL_ADMIN_KEY) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    if (!hasRecoPrelabelAdminAccess(req)) {
      return res.status(403).json({ ok: false, error: 'FORBIDDEN' });
    }
    const parsed = PrelabelSuggestionsQuerySchema.safeParse({
      anchor_product_id: req.query.anchor_product_id || req.query.anchor,
      block: req.query.block,
      limit: req.query.limit,
    });
    if (!parsed.success) {
      return res.status(400).json({ ok: false, error: 'BAD_REQUEST', details: parsed.error.format() });
    }

    try {
      const limit = parseIntQueryValue(parsed.data.limit, 200, 1, 500);
      const suggestions = await loadSuggestionsForAnchor({
        anchor_product_id: parsed.data.anchor_product_id,
        block: parsed.data.block || '',
        limit,
      });
      const kbKey = buildPrelabelKbKey(parsed.data.anchor_product_id, ctx.lang);
      let payload = null;
      if (kbKey) {
        const kbEntry = await getProductIntelKbEntry(kbKey);
        if (isPlainObject(kbEntry?.analysis)) payload = kbEntry.analysis;
      }
      const payloadWithSuggestions = payload
        ? sanitizeProductAnalysisPayloadForPrelabel(attachPrelabelSuggestionsToPayload(payload, suggestions))
        : null;

      return res.status(200).json({
        ok: true,
        anchor_product_id: parsed.data.anchor_product_id,
        block: parsed.data.block || null,
        suggestions: suggestions.map(mapSuggestionForResponse).filter(Boolean),
        payload: payloadWithSuggestions,
      });
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err), request_id: ctx.request_id }, 'aurora bff: prelabel suggestions fetch failed');
      return res.status(500).json({ ok: false, error: 'PRELABEL_SUGGESTIONS_FAILED' });
    }
  });

  app.get('/internal/label-queue', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode || !RECO_DOGFOOD_CONFIG.prelabel?.enabled || !AURORA_BFF_RECO_PRELABEL_ADMIN_KEY) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    if (!hasRecoPrelabelAdminAccess(req)) {
      return res.status(403).json({ ok: false, error: 'FORBIDDEN' });
    }
    const parsed = LabelQueueQuerySchema.safeParse({
      block: req.query.block,
      limit: req.query.limit,
      anchor_product_id: req.query.anchor_product_id || req.query.anchor,
      low_confidence: req.query.low_confidence,
      wrong_block_only: req.query.wrong_block_only,
      exploration_only: req.query.exploration_only,
      missing_info_only: req.query.missing_info_only,
    });
    if (!parsed.success) {
      return res.status(400).json({ ok: false, error: 'BAD_REQUEST', details: parsed.error.format() });
    }

    try {
      const limit = parseIntQueryValue(parsed.data.limit, 50, 1, 500);
      const lowConfidence = parseBoolQueryValue(parsed.data.low_confidence, false);
      const wrongBlockOnly = parseBoolQueryValue(parsed.data.wrong_block_only, false);
      const explorationOnly = parseBoolQueryValue(parsed.data.exploration_only, false);
      const missingInfoOnly = parseBoolQueryValue(parsed.data.missing_info_only, false);

      const rows = await listQueueCandidatesWithSuggestions({
        block: parsed.data.block || '',
        limit: Math.max(limit * 3, 120),
        anchorProductId: parsed.data.anchor_product_id || '',
        confidenceLte: lowConfidence ? 0.45 : null,
        wrongBlockOnly,
      });

      const queue = buildLabelQueue(rows, {
        limit,
        filters: {
          block: parsed.data.block || '',
          anchor_product_id: parsed.data.anchor_product_id || '',
          low_confidence: lowConfidence,
          wrong_block_only: wrongBlockOnly,
          exploration_only: explorationOnly,
          missing_info_only: missingInfoOnly,
        },
      });
      const countsByBlock = { competitors: 0, dupes: 0, related_products: 0 };
      for (const item of queue) {
        const block = normalizeBlockToken(item?.block);
        if (!block) continue;
        countsByBlock[block] += 1;
      }
      for (const block of ['competitors', 'dupes', 'related_products']) {
        if (countsByBlock[block] > 0) recordQueueItemsServed({ block, delta: countsByBlock[block] });
      }

      return res.status(200).json({
        ok: true,
        items: queue.map((row) => ({
          suggestion_id: row.id,
          anchor_product_id: row.anchor_product_id,
          block: row.block,
          candidate_product_id: row.candidate_product_id,
          suggested_label: row.suggested_label,
          wrong_block_target: row.wrong_block_target,
          confidence: row.confidence,
          rationale_user_visible: row.rationale_user_visible,
          flags: Array.isArray(row.flags) ? row.flags : [],
          priority_score: row.priority_score,
          review_url: `/chat/label-queue?anchor_product_id=${encodeURIComponent(String(row.anchor_product_id || ''))}`,
          updated_at: row.updated_at || null,
        })),
      });
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err), request_id: ctx.request_id }, 'aurora bff: label queue fetch failed');
      return res.status(500).json({ ok: false, error: 'LABEL_QUEUE_FAILED' });
    }
  });

  app.post('/v1/reco/employee-feedback', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    try {
      const parsed = RecoEmployeeFeedbackRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        return res.status(400).json({
          ok: false,
          error: 'BAD_REQUEST',
          details: parsed.error.format(),
        });
      }
      const sessionId = getRecoDogfoodSessionId(req, ctx, parsed.data.session_id);
      const requestId = pickFirstTrimmed(parsed.data.request_id, ctx.request_id);
      const metadata = getRecoTrackingMetadata({
        requestId,
        sessionId,
        block: parsed.data.block,
        candidateProductId: parsed.data.candidate_product_id,
        candidateName: parsed.data.candidate_name,
      });
      const event = writeRecoEmployeeFeedbackEvent(
        {
          anchor_product_id: parsed.data.anchor_product_id,
          block: parsed.data.block,
          candidate_product_id: parsed.data.candidate_product_id || '',
          candidate_name: parsed.data.candidate_name || '',
          feedback_type: parsed.data.feedback_type,
          wrong_block_target: parsed.data.wrong_block_target || null,
          reason_tags: Array.isArray(parsed.data.reason_tags) ? parsed.data.reason_tags : [],
          was_exploration_slot:
            parsed.data.was_exploration_slot == null
              ? Boolean(metadata?.was_exploration_slot)
              : Boolean(parsed.data.was_exploration_slot),
          rank_position:
            parsed.data.rank_position == null
              ? Number(metadata?.rank_position || 1)
              : Number(parsed.data.rank_position),
          pipeline_version: parsed.data.pipeline_version || RECO_DOGFOOD_CONFIG.interleave.rankerA,
          models: parsed.data.models || 'unknown',
          suggestion_id: parsed.data.suggestion_id || null,
          llm_suggested_label: parsed.data.llm_suggested_label || null,
          llm_confidence: parsed.data.llm_confidence == null ? null : Number(parsed.data.llm_confidence),
          request_id: requestId,
          session_id: sessionId,
          timestamp: parsed.data.timestamp || Date.now(),
        },
        { logger },
      );
      if (event.llm_suggested_label) {
        const suggested = String(event.llm_suggested_label || '').trim().toLowerCase();
        const finalLabel = String(event.feedback_type || '').trim().toLowerCase();
        if (suggested && finalLabel) {
          if (!global.__auroraPrelabelFeedbackStats) {
            global.__auroraPrelabelFeedbackStats = { total: 0, overturned: 0 };
          }
          global.__auroraPrelabelFeedbackStats.total += 1;
          if (suggested !== finalLabel) global.__auroraPrelabelFeedbackStats.overturned += 1;
          if (global.__auroraPrelabelFeedbackStats.total > 0) {
            const rate = global.__auroraPrelabelFeedbackStats.overturned / global.__auroraPrelabelFeedbackStats.total;
            setLlmSuggestionOverturnedRate(rate);
          }
        }
      }
      recordRecoEmployeeFeedback({
        block: event.block,
        feedbackType: event.feedback_type,
        mode: 'main_path',
      });
      return res.status(200).json({
        ok: true,
        event,
      });
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err) }, 'aurora bff: reco employee feedback failed');
      return res.status(500).json({ ok: false, error: 'RECO_EMPLOYEE_FEEDBACK_FAILED' });
    }
  });

  app.post('/v1/reco/interleave/click', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    try {
      const parsed = RecoInterleaveClickRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        return res.status(400).json({
          ok: false,
          error: 'BAD_REQUEST',
          details: parsed.error.format(),
        });
      }
      const sessionId = getRecoDogfoodSessionId(req, ctx, parsed.data.session_id);
      const requestId = pickFirstTrimmed(parsed.data.request_id, ctx.request_id);
      const metadata = getRecoTrackingMetadata({
        requestId,
        sessionId,
        block: parsed.data.block,
        candidateProductId: parsed.data.candidate_product_id,
        candidateName: parsed.data.candidate_name,
      });
      const attribution = String(metadata?.attribution || 'both');
      recordRecoInterleaveClick({
        block: parsed.data.block,
        attribution,
        mode: 'main_path',
      });
      if (attribution === 'A' || attribution === 'B') {
        recordRecoInterleaveWin({
          block: parsed.data.block,
          ranker: attribution === 'A' ? RECO_DOGFOOD_CONFIG.interleave.rankerA : RECO_DOGFOOD_CONFIG.interleave.rankerB,
          categoryBucket: parsed.data.category_bucket || 'unknown',
          priceBand: parsed.data.price_band || 'unknown',
          mode: 'main_path',
        });
      } else {
        recordRecoInterleaveWin({
          block: parsed.data.block,
          ranker: 'tie',
          categoryBucket: parsed.data.category_bucket || 'unknown',
          priceBand: parsed.data.price_band || 'unknown',
          mode: 'main_path',
        });
      }
      logger?.info?.(
        {
          event_name: 'reco_interleave_click',
          request_id: requestId,
          session_id: sessionId,
          block: parsed.data.block,
          attribution,
          candidate_product_id: parsed.data.candidate_product_id || '',
          was_exploration_slot: Boolean(metadata?.was_exploration_slot),
          rank_position: Number(metadata?.rank_position || 0),
        },
        'aurora bff: reco interleave click',
      );
      return res.status(200).json({
        ok: true,
        attribution,
        was_exploration_slot: Boolean(metadata?.was_exploration_slot),
        rank_position: Number(metadata?.rank_position || 0),
      });
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err) }, 'aurora bff: reco interleave click failed');
      return res.status(500).json({ ok: false, error: 'RECO_INTERLEAVE_CLICK_FAILED' });
    }
  });

  app.get('/v1/reco/async-updates', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    if (!RECO_DOGFOOD_CONFIG.dogfood_mode) {
      return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    }
    try {
      const parsed = RecoAsyncUpdatesRequestSchema.safeParse({
        ticket_id: req.query.ticket_id,
        since_version: req.query.since_version,
      });
      if (!parsed.success) {
        return res.status(400).json({
          ok: false,
          error: 'BAD_REQUEST',
          details: parsed.error.format(),
        });
      }
      const sinceVersionRaw = parsed.data.since_version;
      const sinceVersion = Number.isFinite(Number(sinceVersionRaw))
        ? Math.max(0, Math.trunc(Number(sinceVersionRaw)))
        : 0;
      const out = getAsyncUpdates({
        ticketId: parsed.data.ticket_id,
        sinceVersion,
      });
      if (!out.ok) {
        return res.status(404).json({
          ok: false,
          error: out.reason || 'TICKET_NOT_FOUND',
          version: Number(out.version || 0),
        });
      }
      const mode = 'main_path';
      for (const block of ['competitors', 'related_products', 'dupes']) {
        const patchRows = Array.isArray(out?.payload_patch?.[block]?.candidates)
          ? out.payload_patch[block].candidates
          : [];
        recordRecoAsyncUpdate({
          block,
          result: out.has_update ? 'applied' : 'noop',
          mode,
          changedCount: out.has_update ? patchRows.length : 0,
        });
      }
      return res.status(200).json(out);
    } catch (err) {
      logger?.warn?.({ err: err?.message || String(err), request_id: ctx.request_id }, 'aurora bff: reco async updates failed');
      return res.status(500).json({ ok: false, error: 'RECO_ASYNC_UPDATES_FAILED' });
    }
  });

  app.post('/v1/auth/start', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = AuthStartRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [
            { card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const challenge = await createOtpChallenge({ email: parsed.data.email, language: ctx.lang });
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          ctx.lang === 'CN'
            ? ''
            : "I've sent a sign-in code to your email. Enter the code to continue.",
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `auth_start_${ctx.request_id}`,
            type: 'auth_challenge',
            payload: {
              email: challenge.email,
              challenge_id: challenge.challengeId,
              expires_at: challenge.expiresAt,
              expires_in_seconds: challenge.expiresInSeconds,
              delivery: challenge.delivery,
              ...(challenge.debug_code ? { debug_code: challenge.debug_code } : {}),
              ...(challenge.delivery_error ? { delivery_error: challenge.delivery_error } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'auth_started', { delivery: challenge.delivery })],
      });
      return res.json(envelope);
    } catch (err) {
      const fallbackCode = err && err.code ? err.code : err && err.message ? err.message : 'AUTH_START_FAILED';
      const { code: storageCode, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const code = storageCode || fallbackCode;
      const status = code === 'INVALID_EMAIL' ? 400 : code === 'AUTH_NOT_CONFIGURED' ? 503 : dbError ? 503 : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          code === 'AUTH_NOT_CONFIGURED'
            ? ctx.lang === 'CN'
              ? ''
              : 'Sign-in is not configured yet.'
            : dbError
              ? ctx.lang === 'CN'
                ? ''
                : 'Sign-in is not ready yet (storage unavailable). Please try again shortly.'
            : ctx.lang === 'CN'
              ? ''
              : "Couldn't send a sign-in code. Please try again.",
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error: dbNotConfigured ? 'DB_NOT_CONFIGURED' : dbSchemaError ? 'DB_SCHEMA_NOT_READY' : dbError ? 'DB_UNAVAILABLE' : code,
              ...(storageCode ? { code: storageCode } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/auth/verify', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = AuthVerifyRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [
            { card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const verification = await verifyOtpChallenge({ email: parsed.data.email, code: parsed.data.code });
      if (!verification.ok) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage(
            ctx.lang === 'CN' ? '' : 'Invalid or expired code.',
          ),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'INVALID_CODE', reason: verification.reason } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'INVALID_CODE', reason: verification.reason })],
        });
        return res.status(401).json(envelope);
      }

      const session = await createSession({ userId: verification.userId });

      if (ctx.aurora_uid) {
        try {
          await upsertIdentityLink(ctx.aurora_uid, verification.userId);
        } catch {
          // ignore
        }
        try {
          await migrateGuestDataToUser({ auroraUid: ctx.aurora_uid, userId: verification.userId });
        } catch (err) {
          logger?.warn({ err: err?.message || String(err) }, 'aurora bff: guest->account migration failed');
        }
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(ctx.lang === 'CN' ? '' : 'Signed in.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `auth_${ctx.request_id}`,
            type: 'auth_session',
            payload: {
              token: session.token,
              expires_at: session.expiresAt,
              user: { user_id: verification.userId, email: verification.email },
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'auth_verified', { user_id: verification.userId })],
      });
      return res.json(envelope);
    } catch (err) {
      const fallbackCode = err && err.code ? err.code : err && err.message ? err.message : 'AUTH_VERIFY_FAILED';
      const { code: storageCode, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const code = storageCode || fallbackCode;
      const status = code === 'AUTH_NOT_CONFIGURED' ? 503 : dbError ? 503 : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          code === 'AUTH_NOT_CONFIGURED'
            ? ctx.lang === 'CN'
              ? ''
              : 'Sign-in is not configured yet.'
            : dbError
              ? ctx.lang === 'CN'
                ? ''
                : 'Sign-in is not ready yet (storage unavailable). Please try again shortly.'
            : ctx.lang === 'CN'
              ? ''
              : 'Sign-in failed. Please try again.',
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error: dbNotConfigured ? 'DB_NOT_CONFIGURED' : dbSchemaError ? 'DB_SCHEMA_NOT_READY' : dbError ? 'DB_UNAVAILABLE' : code,
              ...(storageCode ? { code: storageCode } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/auth/password/login', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = AuthPasswordLoginRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [
            { card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const verification = await verifyPasswordForEmail({ email: parsed.data.email, password: parsed.data.password });
      if (!verification.ok) {
        const isLocked = verification.reason === 'locked';
        const status = isLocked ? 429 : verification.reason === 'no_password_set' ? 409 : 401;
        const message =
          verification.reason === 'no_password_set'
            ? ctx.lang === 'CN'
              ? ''
              : 'No password is set for this email yet. Use an email code to sign in first, then set a password.'
            : isLocked
              ? ctx.lang === 'CN'
                ? ''
                : 'Too many attempts. Please try again later.'
              : ctx.lang === 'CN'
                ? ''
                : 'Invalid email or password.';

        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage(message),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: {
                error: isLocked ? 'PASSWORD_LOCKED' : 'INVALID_CREDENTIALS',
                reason: verification.reason,
                ...(verification.locked_until ? { locked_until: verification.locked_until } : {}),
              },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: isLocked ? 'PASSWORD_LOCKED' : 'INVALID_CREDENTIALS' })],
        });
        return res.status(status).json(envelope);
      }

      const session = await createSession({ userId: verification.userId });

      if (ctx.aurora_uid) {
        try {
          await upsertIdentityLink(ctx.aurora_uid, verification.userId);
        } catch {
          // ignore
        }
        try {
          await migrateGuestDataToUser({ auroraUid: ctx.aurora_uid, userId: verification.userId });
        } catch (err) {
          logger?.warn({ err: err?.message || String(err) }, 'aurora bff: guest->account migration failed');
        }
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(ctx.lang === 'CN' ? '' : 'Signed in.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `auth_${ctx.request_id}`,
            type: 'auth_session',
            payload: {
              token: session.token,
              expires_at: session.expiresAt,
              user: { user_id: verification.userId, email: verification.email },
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'auth_verified', { user_id: verification.userId, method: 'password' })],
      });
      return res.json(envelope);
    } catch (err) {
      const fallbackCode = err && err.code ? err.code : err && err.message ? err.message : 'AUTH_PASSWORD_LOGIN_FAILED';
      const { code: storageCode, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const code = storageCode || fallbackCode;
      const status = code === 'AUTH_NOT_CONFIGURED' ? 503 : dbError ? 503 : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          code === 'AUTH_NOT_CONFIGURED'
            ? ctx.lang === 'CN'
              ? ''
              : 'Sign-in is not configured yet.'
            : dbError
              ? ctx.lang === 'CN'
                ? ''
                : 'Sign-in is not ready yet (storage unavailable). Please try again shortly.'
            : ctx.lang === 'CN'
              ? ''
              : 'Sign-in failed. Please try again.',
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error: dbNotConfigured ? 'DB_NOT_CONFIGURED' : dbSchemaError ? 'DB_SCHEMA_NOT_READY' : dbError ? 'DB_UNAVAILABLE' : code,
              ...(storageCode ? { code: storageCode } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/auth/password/set', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const identity = await resolveIdentity(req, ctx);
      if (!identity.userId) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage(ctx.lang === 'CN' ? '' : 'Please sign in first.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'UNAUTHORIZED' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'UNAUTHORIZED' })],
        });
        return res.status(401).json(envelope);
      }

      const parsed = AuthPasswordSetRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [
            { card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      await setUserPassword({ userId: identity.userId, password: parsed.data.password });

      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          ctx.lang === 'CN'
            ? ' + '
            : 'Password set. Next time you can sign in with email + password (OTP still works too).',
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `auth_password_set_${ctx.request_id}`,
            type: 'auth_password_set',
            payload: { ok: true },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'auth_password_set', { user_id: identity.userId })],
      });
      return res.json(envelope);
    } catch (err) {
      const fallbackCode = err && err.code ? err.code : err && err.message ? err.message : 'AUTH_PASSWORD_SET_FAILED';
      const { code: storageCode, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const code = storageCode || fallbackCode;
      const status =
        code === 'INVALID_PASSWORD'
          ? 400
          : code === 'UNAUTHORIZED'
            ? 401
            : code === 'AUTH_NOT_CONFIGURED'
              ? 503
              : dbError
                ? 503
                : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(
          code === 'INVALID_PASSWORD'
            ? ctx.lang === 'CN'
              ? ' 8 '
              : 'Invalid password (min 8 characters).'
            : code === 'AUTH_NOT_CONFIGURED'
              ? ctx.lang === 'CN'
                ? ''
                : 'Sign-in is not configured yet.'
              : dbError
                ? ctx.lang === 'CN'
                  ? ''
                  : "Couldn't save password yet (storage unavailable). Please try again shortly."
              : ctx.lang === 'CN'
                ? ''
                : "Couldn't set password. Please try again.",
        ),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error: dbNotConfigured ? 'DB_NOT_CONFIGURED' : dbSchemaError ? 'DB_SCHEMA_NOT_READY' : dbError ? 'DB_UNAVAILABLE' : code,
              ...(storageCode ? { code: storageCode } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.get('/v1/auth/me', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const identity = await resolveIdentity(req, ctx);
      if (!identity.userId) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage(ctx.lang === 'CN' ? '' : 'Not signed in.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'UNAUTHORIZED' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'UNAUTHORIZED' })],
        });
        return res.status(401).json(envelope);
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `me_${ctx.request_id}`,
            type: 'auth_me',
            payload: {
              user: { user_id: identity.userId, email: identity.userEmail },
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'auth_me' })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err && err.status ? err.status : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to load session.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'AUTH_ME_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'AUTH_ME_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/auth/logout', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const token = getBearerToken(req);
      if (token) {
        try {
          await revokeSessionToken(token);
        } catch {
          // ignore
        }
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage(ctx.lang === 'CN' ? '' : 'Signed out.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `logout_${ctx.request_id}`,
            type: 'auth_logout',
            payload: { ok: true },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'auth_logout', {})],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err && err.status ? err.status : 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to sign out.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'AUTH_LOGOUT_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'AUTH_LOGOUT_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/product/parse', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = ProductParseRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const input = parsed.data.url || parsed.data.text;
      const query = `Task: Parse the user's product input into a normalized product entity.\n` +
        `Return ONLY a JSON object with keys: product (object), confidence (0..1), missing_info (string[]).\n` +
        `Input: ${input}`;

      let upstream = null;
      try {
        upstream = await auroraChat({ baseUrl: AURORA_DECISION_BASE_URL, query, timeoutMs: 12000 });
      } catch (err) {
        // ignore; fall back below
      }

      const structured = getUpstreamStructuredOrJson(upstream);
      const mapped =
        structured && typeof structured === 'object' && !Array.isArray(structured)
          ? mapAuroraProductParse(structured)
          : structured;
      const norm = normalizeProductParse(mapped);
      let payload = norm.payload;
      let fieldMissing = Array.isArray(norm.field_missing) ? norm.field_missing.slice() : [];

      // Fallback: if upstream parse misses the product entity, reuse catalog resolve/search capability.
      if (PRODUCT_INTEL_CATALOG_FALLBACK_ENABLED && !payload.product && input) {
        const catalogFallback = await resolveCatalogProductForProductInput({
          inputText: input,
          inputUrl: parsed.data.url || null,
          parsedProduct: null,
          lang: ctx.lang,
          logger,
        });
        if (catalogFallback.ok && catalogFallback.product) {
          const fallbackAnchor = mapCatalogProductToAnchorProduct(catalogFallback.product, { fallbackName: String(input || '') });
          if (fallbackAnchor) {
            const existingMissing = Array.isArray(payload.missing_info) ? payload.missing_info : [];
            payload = {
              ...payload,
              product: fallbackAnchor,
              confidence:
                Number.isFinite(Number(payload.confidence)) && Number(payload.confidence) > 0
                  ? Number(payload.confidence)
                  : 0.55,
              missing_info: Array.from(new Set([...existingMissing, 'catalog_fallback_used'])),
            };
            fieldMissing = fieldMissing.filter((item) => String(item && item.field ? item.field : '').trim() !== 'product');
            fieldMissing.push({ field: 'parse.fallback', reason: `catalog_${catalogFallback.source || 'resolve'}` });
          }
        }
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `parse_${ctx.request_id}`,
            type: 'product_parse',
            payload,
            ...(fieldMissing.length ? { field_missing: fieldMissing.slice(0, 8) } : {}),
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'product_parse' })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to parse product.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'PRODUCT_PARSE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'PRODUCT_PARSE_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/product/analyze', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    const productAnalyzeSessionId = getRecoDogfoodSessionId(
      req,
      ctx,
      pickFirstTrimmed(
        req?.body?.session?.session_id,
        req?.body?.session?.sessionId,
        req?.body?.session?.id,
      ),
    );
    const sendProductAnalyzeEnvelope = async (envelope, statusCode = 200, mode = 'main_path') => {
      let augmented = augmentEnvelopeProductAnalysisCardsForDogfood({
        envelope,
        req,
        ctx,
        mode,
        sessionId: productAnalyzeSessionId,
        logger,
      });
      augmented = await augmentEnvelopeProductAnalysisCardsWithPrelabelSuggestions({
        envelope: augmented,
        logger,
      });
      if (statusCode >= 400) return res.status(statusCode).json(augmented);
      return res.json(augmented);
    };
    try {
      requireAuroraUid(ctx);
      const parsed = ProductAnalyzeRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return sendProductAnalyzeEnvelope(envelope, 400, 'main_path');
      }

      const incomingSession =
        parsed.data.session && typeof parsed.data.session === 'object' && !Array.isArray(parsed.data.session)
          ? parsed.data.session
          : null;
      if (incomingSession) {
        const sessionStateAsObject =
          incomingSession.state && typeof incomingSession.state === 'object' && !Array.isArray(incomingSession.state)
            ? incomingSession.state
            : null;
        const resumedState = resolveNextStateFromSessionPatch({
          next_state:
            typeof incomingSession.state === 'string'
              ? incomingSession.state
              : typeof incomingSession.next_state === 'string'
                ? incomingSession.next_state
                : '',
          state: sessionStateAsObject,
        });
        if (resumedState) ctx.state = resumedState;
      }

      const identity = await resolveIdentity(req, ctx);
      const profile = await getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }).catch(() => null);
      const recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7).catch(() => []);
      const profileSummary = summarizeProfileForContext(profile);
      const commonMeta = {
        profile: profileSummary,
        recentLogs,
        lang: ctx.lang,
        state: ctx.state || 'idle',
        trigger_source: ctx.trigger_source,
      };
      const parsePrefix = buildContextPrefix({ ...commonMeta, intent: 'product_parse', action_id: 'chip.action.parse_product' });
      const prefix = buildContextPrefix({ ...commonMeta, intent: 'product_analyze', action_id: 'chip.action.analyze_product' });

      const input = parsed.data.url || parsed.data.name || JSON.stringify(parsed.data.product || {});
      let parsedProduct = parsed.data.product || null;
      let anchorId = parsedProduct && (parsedProduct.sku_id || parsedProduct.product_id);
      let primaryAnchorResolution = null;
      let catalogFallback = null;
      let realtimeUrlNormMeta = null;
      const realtimeUrlInput = String(parsed.data.url || '').trim();
      const forceRefresh = parsed.data.force_refresh === true;
      const shouldRunRealtimeUrlFirst = PRODUCT_URL_INGREDIENT_ANALYSIS_ENABLED && /^https?:\/\//i.test(realtimeUrlInput);

      if (shouldRunRealtimeUrlFirst) {
        const kbKeys = [];
        const primaryKbKey = buildProductIntelKbKey({
          productUrl: realtimeUrlInput,
          parsedProduct,
          lang: ctx.lang,
        });
        const urlOnlyKbKey = buildProductIntelKbKey({
          productUrl: realtimeUrlInput,
          parsedProduct: null,
          lang: ctx.lang,
        });
        for (const key of [primaryKbKey, urlOnlyKbKey]) {
          const kbKey = String(key || '').trim();
          if (!kbKey) continue;
          if (kbKeys.includes(kbKey)) continue;
          kbKeys.push(kbKey);
        }
        for (const kbKey of kbKeys) {
          if (forceRefresh) break;
          // eslint-disable-next-line no-await-in-loop
          const kbEntry = await getProductIntelKbEntry(kbKey);
          const kbAnalysis =
            kbEntry && kbEntry.analysis && typeof kbEntry.analysis === 'object' && !Array.isArray(kbEntry.analysis)
              ? kbEntry.analysis
              : null;
          const kbAnalysisSanitized = sanitizeCompetitorsInPayload(kbAnalysis, {
            max: PRODUCT_URL_REALTIME_COMPETITOR_MAX_CANDIDATES,
          });
          if (!kbAnalysisSanitized || !shouldServeProductIntelKbPayload(kbAnalysisSanitized)) continue;
          let kbPayload = enrichProductAnalysisPayload(kbAnalysisSanitized, { lang: ctx.lang, profileSummary });
          if (kbPayload && typeof kbPayload === 'object' && !Array.isArray(kbPayload)) {
            const internalCodes = getProductAnalysisInternalMissingCodes(kbPayload);
            const cleanedInternalCodes = uniqCaseInsensitiveStrings(
              internalCodes.filter((raw) => String(raw || '').trim().toLowerCase() !== 'competitor_sync_enrich_used'),
              16,
            );
            if (cleanedInternalCodes.length !== internalCodes.length) {
              kbPayload = applyProductAnalysisGapContract({
                ...kbPayload,
                internal_debug_codes: cleanedInternalCodes,
              });
            }
          }
          let syncCoverageRepairApplied = false;

          if (
            shouldRepairCompetitorCoverage(kbPayload, { preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT })
          ) {
            // Fast main-path repair for stale low-coverage KB entries: keep latency bounded.
            const syncRepair = await maybeSyncRepairLowCoverageCompetitors({
              productUrl: realtimeUrlInput,
              payload: kbPayload,
              parsedProduct,
              profileSummary,
              lang: ctx.lang,
              logger,
            });
            if (syncRepair && syncRepair.enhanced && syncRepair.payload) {
              kbPayload = enrichProductAnalysisPayload(syncRepair.payload, { lang: ctx.lang, profileSummary });
              syncCoverageRepairApplied = true;
            }
          }

          const kbAssessment = kbPayload?.assessment && typeof kbPayload.assessment === 'object' ? kbPayload.assessment : null;
          const kbBackfillAnchor =
            kbAssessment && typeof kbAssessment.anchor_product === 'object' && !Array.isArray(kbAssessment.anchor_product)
              ? kbAssessment.anchor_product
              : parsedProduct;
          if (syncCoverageRepairApplied) {
            scheduleProductIntelKbBackfill({
              productUrl: realtimeUrlInput,
              parsedProduct: kbBackfillAnchor,
              payload: kbPayload,
              lang: ctx.lang,
              source: 'url_realtime_product_intel_kb_sync_enrich',
              sourceMeta: {
                ...(kbEntry && typeof kbEntry.source_meta === 'object' && !Array.isArray(kbEntry.source_meta) ? kbEntry.source_meta : {}),
                competitor_sync_enriched: true,
                competitor_sync_timeout_ms: PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS,
                competitor_sync_max_queries: PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_MAX_QUERIES,
              },
              logger,
            });
          }
          scheduleProductIntelCompetitorEnrichBackfill({
            productUrl: realtimeUrlInput,
            parsedProduct: kbBackfillAnchor,
            payload: kbPayload,
            lang: ctx.lang,
            profileSummary,
            source: 'url_realtime_product_intel',
            sourceMeta: kbEntry && typeof kbEntry.source_meta === 'object' ? kbEntry.source_meta : null,
            forceEnhance: shouldRepairCompetitorCoverage(kbPayload, {
              preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT,
            }),
            logger,
          });
          kbPayload = finalizeProductAnalysisRecoContract(kbPayload, {
            logger,
            requestId: ctx.request_id,
            mode: syncCoverageRepairApplied ? 'sync_repair' : 'main_path',
          });
          const kbSocialState = resolveProductAnalysisSocialState(kbPayload);
          kbPayload = applyProductAnalysisSocialProvenance(kbPayload, {
            social_fetch_mode: kbSocialState.fetchMode,
            ...(kbSocialState.socialFreshUntil ? { social_fresh_until: kbSocialState.socialFreshUntil } : {}),
            ...(kbSocialState.socialChannels.length ? { social_channels_used: kbSocialState.socialChannels } : {}),
          });
          const envelope = buildEnvelope(ctx, {
            assistant_message: null,
            suggested_chips: [],
            cards: [
              {
                card_id: `analyze_${ctx.request_id}`,
                type: 'product_analysis',
                payload: kbPayload,
              },
            ],
            session_patch: {},
            events: [
              makeEvent(ctx, 'value_moment', {
                kind: 'product_analyze',
                mode: syncCoverageRepairApplied ? 'url_realtime_product_intel_kb_hit_sync_enriched' : 'url_realtime_product_intel_kb_hit',
              }),
            ],
          });
          if (kbSocialState.shouldRefresh) {
            social_enrich_async({
              logger,
              mode: syncCoverageRepairApplied ? 'sync_repair' : 'main_path',
              product_url: realtimeUrlInput,
              payload: kbPayload,
              lang: ctx.lang,
              profile_summary: profileSummary,
              anchor_product: kbBackfillAnchor,
              kb_key: kbKey,
              source: syncCoverageRepairApplied ? 'url_realtime_product_intel_kb_sync_enrich' : 'url_realtime_product_intel_kb_hit',
              source_meta:
                kbEntry && typeof kbEntry.source_meta === 'object' && !Array.isArray(kbEntry.source_meta)
                  ? kbEntry.source_meta
                  : null,
            });
          }
          skin_fit_heavy_async({
            logger,
            mode: syncCoverageRepairApplied ? 'sync_repair' : 'main_path',
            product_url: realtimeUrlInput,
          });
          return sendProductAnalyzeEnvelope(
            envelope,
            200,
            syncCoverageRepairApplied ? 'sync_repair' : 'main_path',
          );
        }

        const realtimeNorm = await buildProductAnalysisFromUrlIngredients({
          productUrl: realtimeUrlInput,
          lang: ctx.lang,
          profileSummary,
          parsedProduct,
          logger,
        });
        if (realtimeNorm && realtimeNorm.payload && realtimeNorm.payload.assessment) {
          realtimeUrlNormMeta = realtimeNorm.source_meta || null;
          let realtimePayload = enrichProductAnalysisPayload(realtimeNorm.payload, { lang: ctx.lang, profileSummary });
          if (realtimePayload && typeof realtimePayload === 'object') {
            const internalCodes = getProductAnalysisInternalMissingCodes(realtimePayload);
            realtimePayload = applyProductAnalysisGapContract({
              ...realtimePayload,
              internal_debug_codes: Array.from(new Set([...internalCodes, 'url_realtime_product_intel_used'])),
            });
          }
          const assessment = realtimePayload?.assessment && typeof realtimePayload.assessment === 'object'
            ? realtimePayload.assessment
            : null;
          if (assessment && !assessment.anchor_product && !assessment.anchorProduct && parsedProduct) {
            realtimePayload = { ...realtimePayload, assessment: { ...assessment, anchor_product: parsedProduct } };
          }

          const kbBackfillAnchor =
            assessment && typeof assessment.anchor_product === 'object' && !Array.isArray(assessment.anchor_product)
              ? assessment.anchor_product
              : parsedProduct;
          let realtimeSyncRepairApplied = false;
          if (
            shouldRepairCompetitorCoverage(realtimePayload, {
              preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT,
            })
          ) {
            const syncRepair = await maybeSyncRepairLowCoverageCompetitors({
              productUrl: realtimeUrlInput,
              payload: realtimePayload,
              parsedProduct: kbBackfillAnchor,
              profileSummary,
              lang: ctx.lang,
              logger,
            });
            if (syncRepair && syncRepair.enhanced && syncRepair.payload) {
              realtimePayload = enrichProductAnalysisPayload(syncRepair.payload, { lang: ctx.lang, profileSummary });
              realtimeSyncRepairApplied = true;
              realtimeUrlNormMeta = {
                ...(realtimeUrlNormMeta && typeof realtimeUrlNormMeta === 'object' && !Array.isArray(realtimeUrlNormMeta)
                  ? realtimeUrlNormMeta
                  : {}),
                competitor_sync_enriched: true,
                competitor_sync_timeout_ms: PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_TIMEOUT_MS,
                competitor_sync_max_queries: PRODUCT_URL_REALTIME_COMPETITOR_SYNC_ENRICH_MAX_QUERIES,
              };
            }
          }
          scheduleProductIntelKbBackfill({
            productUrl: realtimeUrlInput,
            parsedProduct: kbBackfillAnchor,
            payload: realtimePayload,
            lang: ctx.lang,
            source: realtimeSyncRepairApplied ? 'url_realtime_product_intel_sync_enrich' : 'url_realtime_product_intel',
            sourceMeta: realtimeUrlNormMeta,
            logger,
          });
          scheduleProductIntelCompetitorEnrichBackfill({
            productUrl: realtimeUrlInput,
            parsedProduct: kbBackfillAnchor,
            payload: realtimePayload,
            lang: ctx.lang,
            profileSummary,
            source: 'url_realtime_product_intel',
            sourceMeta: realtimeUrlNormMeta,
            forceEnhance: shouldRepairCompetitorCoverage(realtimePayload, {
              preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT,
            }),
            logger,
          });
          realtimePayload = finalizeProductAnalysisRecoContract(realtimePayload, {
            logger,
            requestId: ctx.request_id,
            mode: realtimeSyncRepairApplied ? 'sync_repair' : 'main_path',
          });
          realtimePayload = applyProductAnalysisSocialProvenance(realtimePayload, {
            social_fetch_mode: 'async_refresh',
          });

          const envelope = buildEnvelope(ctx, {
            assistant_message: null,
            suggested_chips: [],
            cards: [
              {
                card_id: `analyze_${ctx.request_id}`,
                type: 'product_analysis',
                payload: realtimePayload,
                ...(realtimeNorm.field_missing?.length ? { field_missing: realtimeNorm.field_missing.slice(0, 8) } : {}),
              },
            ],
            session_patch: {},
            events: [
              makeEvent(ctx, 'value_moment', {
                kind: 'product_analyze',
                mode: realtimeSyncRepairApplied
                  ? 'url_realtime_product_intel_sync_enriched'
                  : 'url_realtime_product_intel',
              }),
            ],
          });
          social_enrich_async({
            logger,
            mode: realtimeSyncRepairApplied ? 'sync_repair' : 'main_path',
            product_url: realtimeUrlInput,
            payload: realtimePayload,
            lang: ctx.lang,
            profile_summary: profileSummary,
            anchor_product: kbBackfillAnchor,
            kb_key: buildProductIntelKbKey({
              productUrl: realtimeUrlInput,
              parsedProduct: kbBackfillAnchor,
              lang: ctx.lang,
            }),
            source: 'url_realtime_product_intel',
            source_meta: realtimeUrlNormMeta,
          });
          skin_fit_heavy_async({
            logger,
            mode: realtimeSyncRepairApplied ? 'sync_repair' : 'main_path',
            product_url: realtimeUrlInput,
          });
          return sendProductAnalyzeEnvelope(
            envelope,
            200,
            realtimeSyncRepairApplied ? 'sync_repair' : 'main_path',
          );
        }
      }

      // If caller only provided a name/url, try to parse into an anchor product first to improve KB hit rate.
      if (!anchorId && input) {
        try {
          const parseQuery = `${parsePrefix}Task: Parse the user's product input into a normalized product entity.\n` +
            `Return ONLY a JSON object with keys: product, confidence, missing_info (string[]).\n` +
            `Input: ${input}`;

          const parseUpstream = await auroraChat({
            baseUrl: AURORA_DECISION_BASE_URL,
            query: parseQuery,
            timeoutMs: 12000,
            ...(parsed.data.url ? { anchor_product_url: parsed.data.url } : {}),
          });

          const parseStructured = (() => {
            if (parseUpstream && parseUpstream.structured && typeof parseUpstream.structured === 'object' && !Array.isArray(parseUpstream.structured)) {
              return parseUpstream.structured;
            }
            const a =
              parseUpstream && typeof parseUpstream.answer === 'string'
                ? extractJsonObjectByKeys(parseUpstream.answer, ['product', 'parse', 'anchor_product', 'anchorProduct'])
                : null;
            return a;
          })();
          const parseMapped =
            parseStructured && typeof parseStructured === 'object' && !Array.isArray(parseStructured)
              ? mapAuroraProductParse(parseStructured)
              : parseStructured;
          const parseNorm = normalizeProductParse(parseMapped);
          parsedProduct = parseNorm.payload.product || parsedProduct;
          anchorId =
            parsedProduct && (parsedProduct.sku_id || parsedProduct.product_id)
              ? String(parsedProduct.sku_id || parsedProduct.product_id)
              : anchorId;
        } catch (err) {
          // ignore; continue without anchor id
        }
      }

      // Main-chain anchor resolution: if parse did not yield an ID, try catalog resolve once (fast path).
      if (!anchorId && input) {
        primaryAnchorResolution = await resolvePrimaryAnalyzeAnchorForProductInput({
          inputText: input,
          inputUrl: parsed.data.url || null,
          parsedProduct,
          lang: ctx.lang,
          logger,
        });
        if (primaryAnchorResolution.ok && primaryAnchorResolution.product) {
          const resolvedAnchor = mapCatalogProductToAnchorProduct(primaryAnchorResolution.product, {
            fallbackName: String(input || ''),
          });
          if (resolvedAnchor) {
            parsedProduct = parsedProduct || resolvedAnchor;
            anchorId =
              resolvedAnchor && (resolvedAnchor.sku_id || resolvedAnchor.product_id)
                ? String(resolvedAnchor.sku_id || resolvedAnchor.product_id)
                : anchorId;
          }
        }
      }

      // Second-stage fallback: reuse catalog resolve/search when upstream parse cannot provide anchor.
      if (PRODUCT_INTEL_CATALOG_FALLBACK_ENABLED && !anchorId && input) {
        catalogFallback = await resolveCatalogProductForProductInput({
          inputText: input,
          inputUrl: parsed.data.url || null,
          parsedProduct,
          lang: ctx.lang,
          logger,
        });
        if (catalogFallback.ok && catalogFallback.product) {
          const fallbackAnchor = mapCatalogProductToAnchorProduct(catalogFallback.product, { fallbackName: String(input || '') });
          if (fallbackAnchor) {
            parsedProduct = parsedProduct || fallbackAnchor;
            anchorId =
              fallbackAnchor && (fallbackAnchor.sku_id || fallbackAnchor.product_id)
                ? String(fallbackAnchor.sku_id || fallbackAnchor.product_id)
                : anchorId;
          }
        }
      }

      const productDescriptor = buildProductInputText(parsedProduct, null) || parsed.data.name || input;

      // Fast return when the product is outside current catalog/KB and no fallback mode is enabled.
      // This keeps latency predictable and makes the main-chain limitation explicit.
      if (!anchorId && !PRODUCT_INTEL_CATALOG_FALLBACK_ENABLED && !(PRODUCT_URL_INGREDIENT_ANALYSIS_ENABLED && parsed.data.url)) {
        const isCn = String(ctx.lang || '').toUpperCase() === 'CN';
        const anchorResolveReason =
          primaryAnchorResolution && primaryAnchorResolution.reason
            ? `anchor_resolve_${String(primaryAnchorResolution.reason || '').toLowerCase()}`
            : null;
        const missingInfo = Array.from(
          new Set(
            [
              'anchor_product_missing',
              'catalog_product_missing',
              'upstream_deep_scan_skipped_anchor_missing',
              parsed.data.url ? 'url_not_indexed_in_catalog' : null,
              anchorResolveReason,
            ].filter(Boolean),
          ),
        );
        const fallbackUnknownPayload = {
          assessment: {
            verdict: isCn ? '' : 'Unknown',
            reasons: isCn
              ? [
                  ' catalog/KB  Deep Scan',
                  ' INCI ',
                ]
              : [
                  'This product is not indexed in the current catalog/KB yet, so the main deep-scan path cannot run.',
                  'Please share the full INCI list, or index this product first and then re-run analysis.',
                ],
            ...(parsedProduct && typeof parsedProduct === 'object' ? { anchor_product: parsedProduct } : {}),
          },
          evidence: {
            science: { key_ingredients: [], mechanisms: [], fit_notes: [], risk_notes: [] },
            social_signals: { typical_positive: [], typical_negative: [], risk_for_groups: [] },
            expert_notes: [],
            confidence: null,
            missing_info: ['evidence_missing'],
          },
          confidence: null,
          missing_info: missingInfo,
        };
        const normNoAnchor = normalizeProductAnalysis(fallbackUnknownPayload);
        const payloadNoAnchor = finalizeProductAnalysisRecoContract(
          enrichProductAnalysisPayload(normNoAnchor.payload, { lang: ctx.lang, profileSummary }),
          { logger, requestId: ctx.request_id, mode: 'main_path' },
        );
        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `analyze_${ctx.request_id}`,
              type: 'product_analysis',
              payload: payloadNoAnchor,
              ...(normNoAnchor.field_missing?.length ? { field_missing: normNoAnchor.field_missing.slice(0, 8) } : {}),
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'product_analyze', mode: 'catalog_missing_fast_return' })],
        });
        return sendProductAnalyzeEnvelope(envelope, 200, 'main_path');
      }

      const query = `${prefix}Task: Deep-scan this product for suitability vs the user's profile.\n` +
        `Return ONLY a JSON object with keys: assessment, evidence, confidence (0..1), missing_info (string[]).\n` +
        `Evidence must include science/social_signals/expert_notes.\n` +
        `Product: ${productDescriptor}`;

      const runDeepScan = async ({ queryText, timeoutMs }) => {
        try {
          return await auroraChat({
            baseUrl: AURORA_DECISION_BASE_URL,
            query: queryText,
            timeoutMs,
            ...(anchorId ? { anchor_product_id: String(anchorId) } : {}),
            ...(parsed.data.url ? { anchor_product_url: parsed.data.url } : {}),
          });
        } catch {
          return null;
        }
      };

      let upstream = await runDeepScan({ queryText: query, timeoutMs: 16000 });

      const upstreamStructured = upstream && upstream.structured && typeof upstream.structured === 'object' && !Array.isArray(upstream.structured)
        ? upstream.structured
        : null;
      const upstreamAnswerJson =
        upstream && typeof upstream.answer === 'string'
          ? extractJsonObjectByKeys(upstream.answer, [
            'assessment',
            'evidence',
            'confidence',
            'missing_info',
            'missingInfo',
            'analyze',
            'verdict',
            'reasons',
            'science_evidence',
            'social_signals',
            'expert_notes',
          ])
          : null;
      const upstreamAnswerObj = upstreamAnswerJson && typeof upstreamAnswerJson === 'object' && !Array.isArray(upstreamAnswerJson) ? upstreamAnswerJson : null;
      const answerLooksLikeProductAnalysis =
        upstreamAnswerObj &&
        (upstreamAnswerObj.assessment != null ||
          upstreamAnswerObj.evidence != null ||
          upstreamAnswerObj.analyze != null ||
          upstreamAnswerObj.analysis != null ||
          upstreamAnswerObj.product_analysis != null ||
          upstreamAnswerObj.productAnalysis != null ||
          upstreamAnswerObj.confidence != null ||
          upstreamAnswerObj.missing_info != null ||
          upstreamAnswerObj.missingInfo != null ||
          upstreamAnswerObj.verdict != null ||
          upstreamAnswerObj.reasons != null ||
          upstreamAnswerObj.science_evidence != null ||
          upstreamAnswerObj.scienceEvidence != null ||
          upstreamAnswerObj.social_signals != null ||
          upstreamAnswerObj.socialSignals != null ||
          upstreamAnswerObj.expert_notes != null ||
          upstreamAnswerObj.expertNotes != null);

      // Prefer answer JSON when `structured` exists but is missing `analyze`.
      const structuredOrJson =
        upstreamStructured && upstreamStructured.analyze && typeof upstreamStructured.analyze === 'object'
          ? upstreamStructured
          : answerLooksLikeProductAnalysis
            ? upstreamAnswerObj
            : upstreamStructured || upstreamAnswerObj;

      const mapped =
        structuredOrJson && typeof structuredOrJson === 'object' && !Array.isArray(structuredOrJson)
          ? mapAuroraProductAnalysis(structuredOrJson)
          : structuredOrJson;
      let norm = normalizeProductAnalysis(mapped);

      // If personalized scan fails (often due to upstream echoing context or dropping analysis),
      // retry once with a minimal prefix to improve reliability. Mark the payload as less personalized.
      if (!norm.payload.assessment && profileSummary && input) {
        const minimalPrefix = buildContextPrefix({
          lang: ctx.lang,
          state: ctx.state || 'idle',
          trigger_source: ctx.trigger_source,
          intent: 'product_analyze_fallback',
          action_id: 'chip.action.analyze_product_fallback',
        });
        const minimalQuery =
          `${minimalPrefix}Task: Deep-scan this product for suitability vs the user's profile.\n` +
          `Return ONLY a JSON object with keys: assessment, evidence, confidence (0..1), missing_info (string[]).\n` +
          `Evidence must include science/social_signals/expert_notes.\n` +
          `Product: ${input}`;
        const upstream2 = await runDeepScan({ queryText: minimalQuery, timeoutMs: 14000 });
        const structured2 = upstream2 && upstream2.structured && typeof upstream2.structured === 'object' && !Array.isArray(upstream2.structured)
          ? upstream2.structured
          : null;
        const answer2 =
          upstream2 && typeof upstream2.answer === 'string'
            ? extractJsonObjectByKeys(upstream2.answer, [
              'assessment',
              'evidence',
              'confidence',
              'missing_info',
              'missingInfo',
              'analyze',
              'verdict',
              'reasons',
              'science_evidence',
              'social_signals',
              'expert_notes',
            ])
            : null;
        const structuredOrJson2 =
          structured2 && structured2.analyze && typeof structured2.analyze === 'object'
            ? structured2
            : answer2 && typeof answer2 === 'object' && !Array.isArray(answer2)
              ? answer2
              : structured2 || answer2;
        const mapped2 =
          structuredOrJson2 && typeof structuredOrJson2 === 'object' && !Array.isArray(structuredOrJson2)
            ? mapAuroraProductAnalysis(structuredOrJson2)
            : structuredOrJson2;
        const norm2 = normalizeProductAnalysis(mapped2);
        if (norm2 && norm2.payload && norm2.payload.assessment) {
          const internalCodes = getProductAnalysisInternalMissingCodes(norm2.payload);
          norm = {
            payload: applyProductAnalysisGapContract({
              ...norm2.payload,
              internal_debug_codes: Array.from(new Set([...internalCodes, 'profile_context_dropped_for_reliability'])),
            }),
            field_missing: norm2.field_missing,
          };
        }
      }

      const needsUrlIngredientAnalysis = (() => {
        const assessment = norm && norm.payload && typeof norm.payload === 'object' ? norm.payload.assessment : null;
        if (!assessment || typeof assessment !== 'object') return true;
        const verdict = String(assessment.verdict || '').trim().toLowerCase();
        return !verdict || verdict === 'unknown' || verdict === '';
      })();
      if (PRODUCT_URL_INGREDIENT_ANALYSIS_ENABLED && needsUrlIngredientAnalysis && parsed.data.url) {
        const urlNorm = await buildProductAnalysisFromUrlIngredients({
          productUrl: parsed.data.url,
          lang: ctx.lang,
          profileSummary,
          parsedProduct,
          logger,
        });
        if (urlNorm && urlNorm.payload && urlNorm.payload.assessment) {
          realtimeUrlNormMeta = urlNorm.source_meta || realtimeUrlNormMeta;
          const mergedMissingInfo = Array.from(
            new Set([
              ...(Array.isArray(norm?.payload?.missing_info) ? norm.payload.missing_info : []),
              ...(Array.isArray(urlNorm.payload.missing_info) ? urlNorm.payload.missing_info : []),
            ]),
          );
          const mergedInternalCodes = Array.from(
            new Set([
              ...getProductAnalysisInternalMissingCodes(norm?.payload),
              ...getProductAnalysisInternalMissingCodes(urlNorm.payload),
            ]),
          );
          norm = {
            payload: applyProductAnalysisGapContract({
              ...urlNorm.payload,
              missing_info: mergedMissingInfo,
              internal_debug_codes: mergedInternalCodes,
            }),
            field_missing: mergeFieldMissing(urlNorm.field_missing, norm.field_missing),
          };
        }
      }

      let payload = enrichProductAnalysisPayload(norm.payload, { lang: ctx.lang, profileSummary });
      if (catalogFallback && catalogFallback.ok && payload && typeof payload === 'object') {
        const internalCodes = getProductAnalysisInternalMissingCodes(payload);
        payload = applyProductAnalysisGapContract({
          ...payload,
          internal_debug_codes: Array.from(new Set([...internalCodes, `catalog_anchor_fallback_${catalogFallback.source || 'used'}`])),
        });
      }
      if (parsedProduct && payload && typeof payload === 'object') {
        const a = payload.assessment && typeof payload.assessment === 'object' ? payload.assessment : null;
        if (a && !a.anchor_product && !a.anchorProduct) {
          payload = { ...payload, assessment: { ...a, anchor_product: parsedProduct } };
        }
      }
      if (realtimeUrlNormMeta && parsed.data.url && payload && typeof payload === 'object') {
        const assessment = payload.assessment && typeof payload.assessment === 'object' ? payload.assessment : null;
        const kbBackfillAnchor =
          assessment && typeof assessment.anchor_product === 'object' && !Array.isArray(assessment.anchor_product)
            ? assessment.anchor_product
            : parsedProduct;
        scheduleProductIntelKbBackfill({
          productUrl: parsed.data.url,
          parsedProduct: kbBackfillAnchor,
          payload,
          lang: ctx.lang,
          source: 'url_realtime_product_intel',
          sourceMeta: realtimeUrlNormMeta,
          logger,
        });
        scheduleProductIntelCompetitorEnrichBackfill({
          productUrl: parsed.data.url,
          parsedProduct: kbBackfillAnchor,
          payload,
          lang: ctx.lang,
          profileSummary,
          source: 'url_realtime_product_intel',
          sourceMeta: realtimeUrlNormMeta,
          forceEnhance: hasLowCoverageCompetitorsInPayload(payload, {
            preferredCount: PRODUCT_URL_REALTIME_COMPETITOR_PREFERRED_COUNT,
          }),
          logger,
        });
      }
      payload = finalizeProductAnalysisRecoContract(payload, {
        logger,
        requestId: ctx.request_id,
        mode: 'main_path',
      });
      if (realtimeUrlNormMeta && parsed.data.url) {
        payload = applyProductAnalysisSocialProvenance(payload, {
          social_fetch_mode: 'async_refresh',
        });
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `analyze_${ctx.request_id}`,
            type: 'product_analysis',
            payload,
            ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'product_analyze' })],
      });
      if (realtimeUrlNormMeta && parsed.data.url) {
        const socialAnchorAssessment =
          payload && typeof payload === 'object' && payload.assessment && typeof payload.assessment === 'object'
            ? payload.assessment
            : null;
        const socialAnchorProduct =
          socialAnchorAssessment &&
          socialAnchorAssessment.anchor_product &&
          typeof socialAnchorAssessment.anchor_product === 'object' &&
          !Array.isArray(socialAnchorAssessment.anchor_product)
            ? socialAnchorAssessment.anchor_product
            : parsedProduct;
        social_enrich_async({
          logger,
          mode: 'main_path',
          product_url: String(parsed.data.url || '').trim(),
          payload,
          lang: ctx.lang,
          profile_summary: profileSummary,
          anchor_product: socialAnchorProduct,
          kb_key: buildProductIntelKbKey({
            productUrl: String(parsed.data.url || '').trim(),
            parsedProduct: socialAnchorProduct,
            lang: ctx.lang,
          }),
          source: 'url_realtime_product_intel',
          source_meta: realtimeUrlNormMeta,
        });
        skin_fit_heavy_async({
          logger,
          mode: 'main_path',
          product_url: String(parsed.data.url || '').trim(),
        });
      }
      return sendProductAnalyzeEnvelope(envelope, 200, 'main_path');
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to analyze product.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'PRODUCT_ANALYZE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'PRODUCT_ANALYZE_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/dupe/suggest', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = DupeSuggestRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const maxDupes = Math.max(1, Math.min(6, Number.isFinite(parsed.data.max_dupes) ? parsed.data.max_dupes : 3));
      const maxComparables = Math.max(
        1,
        Math.min(6, Number.isFinite(parsed.data.max_comparables) ? parsed.data.max_comparables : 2),
      );
      const forceRefresh = parsed.data.force_refresh === true;
      const forceValidate = parsed.data.force_validate === true;

      const originalUrl = typeof parsed.data.original_url === 'string' ? parsed.data.original_url.trim() : '';
      let originalObj =
        parsed.data.original && typeof parsed.data.original === 'object' && !Array.isArray(parsed.data.original) ? parsed.data.original : null;
      let anchorId = extractAnchorIdFromProductLike(originalObj);

      const inputText =
        buildProductInputText(originalObj, originalUrl) ||
        (typeof parsed.data.original_text === 'string' ? parsed.data.original_text.trim() : '') ||
        '';
      if (!inputText) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: 'original is required' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const buildKbKey = ({ anchor, url, text }) => {
        const id = String(anchor || '').trim();
        if (id) return normalizeDupeKbKey(`id:${id}`);
        const u = String(url || '').trim();
        if (u) return normalizeDupeKbKey(`url:${u}`);
        const t = String(text || '').trim();
        if (!t) return null;
        const norm = t.toLowerCase().replace(/\s+/g, ' ').slice(0, 220);
        return normalizeDupeKbKey(`text:${norm}`);
      };

      // 1) KB fast-path (avoid upstream parse/LLM when possible)
      let kbKey = buildKbKey({ anchor: anchorId, url: originalUrl, text: inputText });
      let kbEntry = kbKey ? await getDupeKbEntry(kbKey) : null;

      const kbVerified = kbEntry && kbEntry.verified === true;
      const canServeKb = kbEntry && kbVerified && !forceRefresh && !forceValidate;
      if (canServeKb) {
        const payload = {
          kb_key: kbKey,
          original: kbEntry.original || originalObj || null,
          dupes: Array.isArray(kbEntry.dupes) ? kbEntry.dupes : [],
          comparables: Array.isArray(kbEntry.comparables) ? kbEntry.comparables : [],
          verified: true,
          verified_at: kbEntry.verified_at || null,
          source: kbEntry.source || 'kb',
          meta: { served_from_kb: true, validated_now: false },
        };

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [{ card_id: `dupe_suggest_${ctx.request_id}`, type: 'dupe_suggest', payload }],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'dupe_suggest', source: 'kb' })],
        });
        return res.json(envelope);
      }

      // 2) Best-effort parse (improves kb_key stability and gives the UI a normalized product object)
      if (!anchorId && inputText) {
        const upstreamMeta = {
          lang: ctx.lang,
          state: ctx.state || 'idle',
          trigger_source: ctx.trigger_source,
        };
        const parsePrefix = buildContextPrefix({ ...upstreamMeta, intent: 'product_parse', action_id: 'chip.action.parse_product' });
        const parseQuery =
          `${parsePrefix}Task: Parse the user's product input into a normalized product entity.\n` +
          `Return ONLY a JSON object with keys: product, confidence, missing_info (string[]).\n` +
          `Input: ${inputText}`;
        try {
          const upstream = await auroraChat({
            baseUrl: AURORA_DECISION_BASE_URL,
            query: parseQuery,
            timeoutMs: 9000,
            ...(originalUrl ? { anchor_product_url: originalUrl } : {}),
          });
          const structured = getUpstreamStructuredOrJson(upstream);
          const answerJson =
            upstream && typeof upstream.answer === 'string'
              ? extractJsonObjectByKeys(upstream.answer, ['product', 'parse', 'anchor_product', 'anchorProduct'])
              : null;
          const obj =
            structured && typeof structured === 'object' && !Array.isArray(structured)
              ? structured
              : answerJson && typeof answerJson === 'object' && !Array.isArray(answerJson)
                ? answerJson
                : null;
          const anchor =
            obj && obj.parse && typeof obj.parse === 'object'
              ? (obj.parse.anchor_product || obj.parse.anchorProduct)
              : obj && obj.product && typeof obj.product === 'object'
                ? obj.product
                : null;
          if (anchor && typeof anchor === 'object' && !Array.isArray(anchor)) {
            originalObj = originalObj || anchor;
            anchorId = anchorId || extractAnchorIdFromProductLike(anchor);
          }
        } catch {
          // ignore parse failures; continue
        }
      }

      // If we managed to derive a more stable ID key, try the KB once more.
      const stableKey = buildKbKey({ anchor: anchorId, url: originalUrl, text: inputText });
      if (stableKey && stableKey !== kbKey) {
        kbKey = stableKey;
        kbEntry = await getDupeKbEntry(kbKey);
        const stableVerified = kbEntry && kbEntry.verified === true;
        if (kbEntry && stableVerified && !forceRefresh && !forceValidate) {
          const payload = {
            kb_key: kbKey,
            original: kbEntry.original || originalObj || null,
            dupes: Array.isArray(kbEntry.dupes) ? kbEntry.dupes : [],
            comparables: Array.isArray(kbEntry.comparables) ? kbEntry.comparables : [],
            verified: true,
            verified_at: kbEntry.verified_at || null,
            source: kbEntry.source || 'kb',
            meta: { served_from_kb: true, validated_now: false },
          };

          const envelope = buildEnvelope(ctx, {
            assistant_message: null,
            suggested_chips: [],
            cards: [{ card_id: `dupe_suggest_${ctx.request_id}`, type: 'dupe_suggest', payload }],
            session_patch: {},
            events: [makeEvent(ctx, 'value_moment', { kind: 'dupe_suggest', source: 'kb' })],
          });
          return res.json(envelope);
        }
      }

      // 3) Generate and validate once via upstream LLM, then cache to KB for future calls.
      const total = Math.max(2, Math.min(6, maxDupes + maxComparables));
      const upstreamOut = await fetchRecoAlternativesForProduct({
        ctx,
        profileSummary: null,
        recentLogs: [],
        productInput: inputText,
        productObj: originalObj,
        anchorId,
        maxTotal: total,
        debug: false,
        logger,
      });

      const mapped = Array.isArray(upstreamOut.alternatives) ? upstreamOut.alternatives : [];
      const kindOf = (it) => String(it && typeof it === 'object' ? it.kind : '').trim().toLowerCase();

      const dupes = mapped.filter((it) => kindOf(it) === 'dupe').slice(0, maxDupes);
      const comparables = mapped.filter((it) => kindOf(it) !== 'dupe').slice(0, maxComparables);

      const verified = dupes.length > 0 || comparables.length > 0;
      if (kbKey) {
        const kbWritePayload = {
          kb_key: kbKey,
          original: originalObj || null,
          dupes,
          comparables,
          verified,
          verified_at: verified ? new Date().toISOString() : null,
          verified_by: verified ? 'aurora_llm' : null,
          source: verified ? 'llm_generate' : 'llm_generate_empty',
          source_meta: {
            generated_at: new Date().toISOString(),
            max_dupes: maxDupes,
            max_comparables: maxComparables,
          },
        };
        if (DUPE_KB_ASYNC_BACKFILL_ENABLED) {
          // Non-blocking write: keep response latency stable while still warming KB.
          upsertDupeKbEntry(kbWritePayload).catch((err) => {
            logger?.warn(
              { err: err?.message || String(err), kb_key: kbKey },
              'aurora bff: async dupe kb backfill failed',
            );
          });
        } else {
          await upsertDupeKbEntry(kbWritePayload);
        }
      }

      const payload = {
        kb_key: kbKey,
        original: originalObj || null,
        dupes,
        comparables,
        verified,
        verified_at: verified ? new Date().toISOString() : null,
        source: verified ? 'llm_generate' : 'llm_generate_empty',
        meta: {
          served_from_kb: false,
          validated_now: true,
          force_refresh: forceRefresh,
          force_validate: forceValidate,
          kb_backfill_mode: DUPE_KB_ASYNC_BACKFILL_ENABLED ? 'async' : 'sync',
        },
        ...(Array.isArray(upstreamOut.field_missing) && upstreamOut.field_missing.length ? { field_missing: upstreamOut.field_missing } : {}),
      };

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `dupe_suggest_${ctx.request_id}`,
            type: 'dupe_suggest',
            payload,
            ...(Array.isArray(upstreamOut.field_missing) && upstreamOut.field_missing.length ? { field_missing: upstreamOut.field_missing } : {}),
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'dupe_suggest', source: 'llm' })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to suggest dupes.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'DUPE_SUGGEST_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'DUPE_SUGGEST_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/dupe/compare', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = DupeCompareRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const identity = await resolveIdentity(req, ctx);
      const profile = await getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }).catch(() => null);
      const recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7).catch(() => []);
      const profileSummary = summarizeProfileForContext(profile);
      // Use minimal upstream context for stability: dupe_compare should not depend on per-user logs/profile size.
      const upstreamMeta = {
        lang: ctx.lang,
        state: ctx.state || 'idle',
        trigger_source: ctx.trigger_source,
      };
      const parsePrefix = buildContextPrefix({ ...upstreamMeta, intent: 'product_parse', action_id: 'chip.action.parse_product' });
      const analyzePrefix = buildContextPrefix({ ...upstreamMeta, intent: 'product_analyze', action_id: 'chip.action.analyze_product' });
      const comparePrefix = buildContextPrefix({ ...upstreamMeta, intent: 'dupe_compare', action_id: 'chip.action.dupe_compare' });

      const originalInput = buildProductInputText(parsed.data.original, parsed.data.original_url);
      const dupeInput = buildProductInputText(parsed.data.dupe, parsed.data.dupe_url);

      if (!originalInput || !dupeInput) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: 'original and dupe are required' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const productQuery = (input) => (
        `${parsePrefix}Task: Parse the user's product input into a normalized product entity.\n` +
        `Return ONLY a JSON object with keys: product, confidence, missing_info (string[]).\n` +
        `Input: ${input}`
      );

      const parseOne = async ({ inputText, anchorObj, anchorUrl }) => {
        try {
          const anchorId = anchorObj && (anchorObj.sku_id || anchorObj.product_id);
          return await auroraChat({
            baseUrl: AURORA_DECISION_BASE_URL,
            query: productQuery(inputText),
            // Best-effort only; keep fast so dupe_compare doesn't hang on parse.
            timeoutMs: 9000,
            ...(anchorId ? { anchor_product_id: String(anchorId) } : {}),
            ...(anchorUrl ? { anchor_product_url: anchorUrl } : {}),
          });
        } catch {
          return null;
        }
      };

      const [originalUpstream, dupeUpstream] = await Promise.all([
        parseOne({ inputText: originalInput, anchorObj: parsed.data.original, anchorUrl: parsed.data.original_url }),
        parseOne({ inputText: dupeInput, anchorObj: parsed.data.dupe, anchorUrl: parsed.data.dupe_url }),
      ]);

      const originalStructured = getUpstreamStructuredOrJson(originalUpstream);
      const dupeStructured = getUpstreamStructuredOrJson(dupeUpstream);
      const originalAnchorFromUpstream = originalStructured && originalStructured.parse && typeof originalStructured.parse === 'object'
        ? (originalStructured.parse.anchor_product || originalStructured.parse.anchorProduct)
        : null;
      const dupeAnchorFromUpstream = dupeStructured && dupeStructured.parse && typeof dupeStructured.parse === 'object'
        ? (dupeStructured.parse.anchor_product || dupeStructured.parse.anchorProduct)
        : null;

      const originalAnchor = originalAnchorFromUpstream || parsed.data.original || null;
      const dupeAnchor = dupeAnchorFromUpstream || parsed.data.dupe || null;

      const originalText = buildProductInputText(originalAnchor, parsed.data.original_url) || originalInput;
      const dupeText = buildProductInputText(dupeAnchor, parsed.data.dupe_url) || dupeInput;

      const compareQuery =
        `${comparePrefix}Task: Compare the original product vs the dupe/alternative.\n` +
        `Return ONLY a JSON object with keys: original, dupe, tradeoffs (string[]), evidence, confidence (0..1), missing_info (string[]).\n` +
        `Evidence must include science/social_signals/expert_notes.\n` +
        `Original: ${originalText}\n` +
        `Dupe: ${dupeText}`;

      let compareUpstream = null;
      try {
        const originalAnchorId = originalAnchor && (originalAnchor.sku_id || originalAnchor.product_id);
        compareUpstream = await auroraChat({
          baseUrl: AURORA_DECISION_BASE_URL,
          query: compareQuery,
          timeoutMs: 18000,
          ...(originalAnchorId ? { anchor_product_id: String(originalAnchorId) } : {}),
          ...(parsed.data.original_url ? { anchor_product_url: parsed.data.original_url } : {}),
        });
      } catch (err) {
        // ignore; fall back below
      }

      const compareStructured = (() => {
        const structured = compareUpstream && compareUpstream.structured && typeof compareUpstream.structured === 'object' && !Array.isArray(compareUpstream.structured)
          ? compareUpstream.structured
          : null;
        const answerJson =
          compareUpstream && typeof compareUpstream.answer === 'string'
            ? extractJsonObjectByKeys(compareUpstream.answer, [
              'tradeoffs',
              'tradeoffs_detail',
              'tradeoffsDetail',
              'evidence',
              'original',
              'dupe',
              'alternatives',
              'compare',
            ])
            : null;
        const answerObj = answerJson && typeof answerJson === 'object' && !Array.isArray(answerJson) ? answerJson : null;
        if (structured && Array.isArray(structured.alternatives)) return structured;
        if (answerObj && (Array.isArray(answerObj.tradeoffs) || answerObj.tradeoffs_detail || answerObj.tradeoffsDetail)) return answerObj;
        return structured || answerObj;
      })();

      const fallbackAnalyze = () => {
        if (!originalStructured || !dupeStructured) {
          return {
            original: originalAnchor || null,
            dupe: dupeAnchor || null,
            tradeoffs: [],
            evidence: null,
            confidence: null,
            missing_info: ['upstream_missing_or_unstructured'],
          };
        }
        const orig = mapAuroraProductAnalysis(originalStructured);
        const dup = mapAuroraProductAnalysis(dupeStructured);

        const origKeys = Array.isArray(orig.evidence?.science?.key_ingredients) ? orig.evidence.science.key_ingredients : [];
        const dupKeys = Array.isArray(dup.evidence?.science?.key_ingredients) ? dup.evidence.science.key_ingredients : [];
        const origRisk = Array.isArray(orig.evidence?.science?.risk_notes) ? orig.evidence.science.risk_notes : [];
        const dupRisk = Array.isArray(dup.evidence?.science?.risk_notes) ? dup.evidence.science.risk_notes : [];

        const barrierRaw = profileSummary && typeof profileSummary.barrierStatus === 'string' ? profileSummary.barrierStatus.trim().toLowerCase() : '';
        const barrierImpaired = barrierRaw === 'impaired' || barrierRaw === 'damaged';

        const ingredientSignals = (items) => {
          const out = {
            occlusives: [],
            humectants: [],
            soothing: [],
            exfoliants: [],
            brightening: [],
            peptides: [],
            fragrance: [],
            alcohol: [],
          };

          const seen = new Set();
          const add = (k, v) => {
            const s = typeof v === 'string' ? v.trim() : String(v || '').trim();
            if (!s) return;
            const key = `${k}:${s.toLowerCase()}`;
            if (seen.has(key)) return;
            seen.add(key);
            out[k].push(s);
          };

          for (const raw of Array.isArray(items) ? items : []) {
            const s = typeof raw === 'string' ? raw.trim() : String(raw || '').trim();
            if (!s) continue;
            const n = s.toLowerCase();

            // Ignore trivial carriers.
            if (n === 'water' || n === 'aqua') continue;

            if (
              n.includes('petrolatum') ||
              n.includes('petroleum jelly') ||
              n.includes('mineral oil') ||
              n.includes('paraffin') ||
              n.includes('dimethicone') ||
              n.includes('lanolin') ||
              n.includes('wax') ||
              n.includes('beeswax') ||
              n.includes('shea butter') ||
              n.includes('cocoa butter')
            ) {
              add('occlusives', s);
            }

            if (
              n.includes('glycerin') ||
              n.includes('hyaluronic') ||
              n.includes('sodium hyaluronate') ||
              n.includes('panthenol') ||
              n.includes('urea') ||
              n.includes('betaine') ||
              n.includes('sodium pca') ||
              n.includes('trehalose') ||
              n.includes('propanediol') ||
              n.includes('butylene glycol') ||
              n.includes('sorbitol')
            ) {
              add('humectants', s);
            }

            if (
              n.includes('panthenol') ||
              n.includes('allantoin') ||
              n.includes('madecassoside') ||
              n.includes('centella') ||
              n.includes('ceramide') ||
              n.includes('cholesterol') ||
              n.includes('beta-glucan') ||
              n.includes('cica')
            ) {
              add('soothing', s);
            }

            if (
              n.includes('glycolic') ||
              n.includes('lactic') ||
              n.includes('mandelic') ||
              n.includes('salicylic') ||
              n.includes('gluconolactone') ||
              n.includes('pha') ||
              n.includes('bha') ||
              n.includes('aha')
            ) {
              add('exfoliants', s);
            }

            if (
              n.includes('niacinamide') ||
              n.includes('tranexamic') ||
              n.includes('azelaic') ||
              n.includes('ascorbic') ||
              n.includes('vitamin c') ||
              n.includes('arbutin') ||
              n.includes('kojic') ||
              n.includes('licorice')
            ) {
              add('brightening', s);
            }

            if (n.includes('peptide')) add('peptides', s);

            if (
              n.includes('fragrance') ||
              n.includes('parfum') ||
              n.includes('essential oil') ||
              n.includes('limonene') ||
              n.includes('linalool') ||
              n.includes('citral')
            ) {
              add('fragrance', s);
            }

            if (n.includes('alcohol denat') || n.includes('denatured alcohol')) add('alcohol', s);
          }

          return out;
        };

        const pickFew = (arr, max) => Array.from(new Set(Array.isArray(arr) ? arr.map((x) => String(x || '').trim()).filter(Boolean) : [])).slice(0, max);
        const joinFew = (arr, max) => pickFew(arr, max).join(', ');
        const nonEmpty = (arr) => Array.isArray(arr) && arr.length > 0;

        const origSig = ingredientSignals(origKeys);
        const dupSig = ingredientSignals(dupKeys);

        const tradeoffs = [];
        if (nonEmpty(origSig.occlusives) && !nonEmpty(dupSig.occlusives) && nonEmpty(dupSig.humectants)) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? `/ ${joinFew(origSig.occlusives, 2)} ${joinFew(dupSig.humectants, 2)} `
              : `Texture/finish: Original is more occlusive (e.g., ${joinFew(origSig.occlusives, 2)}) while the dupe is more humectant (e.g., ${joinFew(dupSig.humectants, 2)})  lighter feel, but may need a moisturizer on top to seal.`,
          );
        } else if (nonEmpty(origSig.occlusives) && nonEmpty(dupSig.occlusives)) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? `/${joinFew(origSig.occlusives, 2)}${joinFew(dupSig.occlusives, 2)} /`
              : `Shared: Both include occlusive/emollient components (orig: ${joinFew(origSig.occlusives, 2)}; dupe: ${joinFew(dupSig.occlusives, 2)})  both can be sealing; differences may come from formula balance.`,
          );
        }

        if (nonEmpty(origSig.humectants) && nonEmpty(dupSig.humectants) && tradeoffs.length < 2) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? `${joinFew(origSig.humectants, 2)}${joinFew(dupSig.humectants, 2)} `
              : `Shared: Both include humectants (orig: ${joinFew(origSig.humectants, 2)}; dupe: ${joinFew(dupSig.humectants, 2)})  both support hydration; how sealing it feels depends on occlusives.`,
          );
        }

        if (nonEmpty(dupSig.exfoliants)) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? ` ${joinFew(dupSig.exfoliants, 2)} ${barrierImpaired ? '' : ''}`
              : `Irritation risk: Dupe includes exfoliant-like actives (e.g., ${joinFew(dupSig.exfoliants, 2)})  ${barrierImpaired ? 'higher irritation risk if your barrier is impaired; start low' : 'higher irritation risk; start low'}, avoid stacking strong actives.`,
          );
        }

        if (nonEmpty(dupSig.fragrance) && !nonEmpty(origSig.fragrance)) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? `// ${joinFew(dupSig.fragrance, 1)} `
              : `Fragrance risk: Dupe may include fragrance-related ingredients (e.g., ${joinFew(dupSig.fragrance, 1)})  higher risk for sensitive skin.`,
          );
        }

        const addedRisks = dupRisk.filter((k) => !origRisk.includes(k));
        if (addedRisks.length) {
          tradeoffs.push(
            ctx.lang === 'CN'
              ? `${addedRisks.slice(0, 2).join('  ')}`
              : `Dupe risk notes: ${addedRisks.slice(0, 2).join('  ')}`,
          );
        }

        if (!tradeoffs.length) {
          const origPreview = pickFew([...origSig.occlusives, ...origSig.humectants, ...origSig.soothing, ...origSig.brightening, ...origSig.exfoliants], 3);
          const dupPreview = pickFew([...dupSig.occlusives, ...dupSig.humectants, ...dupSig.soothing, ...dupSig.brightening, ...dupSig.exfoliants], 3);
          if (origPreview.length && dupPreview.length) {
            tradeoffs.push(
              ctx.lang === 'CN'
                ? `${origPreview.length ? origPreview.join(' / ') : ''}${dupPreview.length ? dupPreview.join(' / ') : ''}`
                : `Key ingredient emphasis (brief): original  ${origPreview.length ? origPreview.join(' / ') : 'unknown'}; dupe  ${dupPreview.length ? dupPreview.join(' / ') : 'unknown'}.`,
            );
          }
        }

        const confidence = typeof orig.confidence === 'number' && typeof dup.confidence === 'number'
          ? (orig.confidence + dup.confidence) / 2
          : (orig.confidence || dup.confidence || null);

        const evidence = {
          science: {
            key_ingredients: Array.from(new Set([...origKeys, ...dupKeys])),
            mechanisms: Array.from(new Set([...(orig.evidence?.science?.mechanisms || []), ...(dup.evidence?.science?.mechanisms || [])])),
            fit_notes: Array.from(new Set([...(orig.evidence?.science?.fit_notes || []), ...(dup.evidence?.science?.fit_notes || [])])),
            risk_notes: Array.from(new Set([...(orig.evidence?.science?.risk_notes || []), ...(dup.evidence?.science?.risk_notes || [])])),
          },
          social_signals: { typical_positive: [], typical_negative: [], risk_for_groups: [] },
          expert_notes: Array.from(new Set([...(orig.evidence?.expert_notes || []), ...(dup.evidence?.expert_notes || [])])),
          confidence,
          missing_info: ['dupe_not_in_alternatives_used_analyze_diff'],
        };

        return {
          original: originalAnchor || null,
          dupe: dupeAnchor || null,
          tradeoffs,
          evidence,
          confidence,
          missing_info: ['dupe_not_found_in_alternatives'],
        };
      };

      const mappedFromOriginalAlts =
        originalStructured && originalStructured.alternatives
          ? mapAuroraAlternativesToDupeCompare(originalStructured, dupeAnchor, {
              fallbackAnalyze,
              originalAnchorFallback: originalAnchor,
              lang: ctx.lang,
              barrierStatus: profileSummary && profileSummary.barrierStatus,
            })
          : null;

      const mapped = (() => {
        // Prefer structured.alternatives (when present) because it yields stable similarity/tradeoffs.
        if (mappedFromOriginalAlts && Array.isArray(mappedFromOriginalAlts.tradeoffs) && mappedFromOriginalAlts.tradeoffs.length) {
          return mappedFromOriginalAlts;
        }
        if (compareStructured) {
          if (compareStructured.alternatives) {
            return mapAuroraAlternativesToDupeCompare(compareStructured, dupeAnchor, {
              fallbackAnalyze,
              originalAnchorFallback: originalAnchor,
              lang: ctx.lang,
              barrierStatus: profileSummary && profileSummary.barrierStatus,
            });
          }
          return compareStructured;
        }
        if (mappedFromOriginalAlts) return mappedFromOriginalAlts;
        return fallbackAnalyze();
      })();

      const norm = normalizeDupeCompare(mapped);
      let payload = norm.payload;
      let field_missing = norm.field_missing;
      if (!payload.original && originalAnchor) payload = { ...payload, original: originalAnchor };
      if (!payload.dupe && dupeAnchor) payload = { ...payload, dupe: dupeAnchor };

      const uniqStrings = (arr) => {
        const out = [];
        const seen = new Set();
        for (const v of Array.isArray(arr) ? arr : []) {
          const s = typeof v === 'string' ? v.trim() : String(v || '').trim();
          if (!s) continue;
          if (seen.has(s)) continue;
          seen.add(s);
          out.push(s);
        }
        return out;
      };

      const isMissingTradeoffs = !Array.isArray(payload.tradeoffs) || payload.tradeoffs.length === 0;
      if (isMissingTradeoffs) {
        const scanOne = async ({ productText, productObj, productUrl }) => {
          const anchorId = extractAnchorIdFromProductLike(productObj);
          const bestText = String(productText || '').trim() || (anchorId ? String(anchorId) : '');
          if (!bestText) return null;

          const cacheKey = (() => {
            const langKey = ctx.lang === 'CN' ? 'CN' : 'EN';
            if (anchorId) return `dupe_deepscan:${langKey}:id:${String(anchorId).trim()}`;
            const url = typeof productUrl === 'string' ? productUrl.trim() : '';
            if (url) return `dupe_deepscan:${langKey}:url:${url}`;
            const norm = bestText.toLowerCase().replace(/\s+/g, ' ').slice(0, 160);
            return `dupe_deepscan:${langKey}:text:${norm}`;
          })();
          const cached = getDupeDeepscanCache(cacheKey);
          if (cached) return cached;

          const buildQuery = (strict = false) => (
            `${analyzePrefix}Task: Deep-scan this product for a product-level ingredient/benefit/risk snapshot.\n` +
            `Return ONLY a JSON object with keys: assessment, evidence, confidence (0..1), missing_info (string[]).\n` +
            `Evidence must include science/social_signals/expert_notes.\n` +
            `${strict ? 'If possible, include at least 4 items in evidence.science.key_ingredients; if unavailable, return [] and add missing_info: \"key_ingredients_missing\".\n' : ''}` +
            `Product: ${bestText}`
          );

          const runScan = async (queryText, timeoutMs) =>
            auroraChat({
              baseUrl: AURORA_DECISION_BASE_URL,
              query: queryText,
              timeoutMs,
              ...(anchorId ? { anchor_product_id: String(anchorId) } : {}),
              ...(productUrl ? { anchor_product_url: productUrl } : {}),
            });

          const parseUpstream = (upstream) => {
            const upStructured = upstream && upstream.structured && typeof upstream.structured === 'object' && !Array.isArray(upstream.structured)
              ? upstream.structured
              : null;
            const upAnswerJson =
              upstream && typeof upstream.answer === 'string'
                ? extractJsonObjectByKeys(upstream.answer, [
                    'assessment',
                    'evidence',
                    'confidence',
                    'missing_info',
                    'missingInfo',
                    'analyze',
                    'verdict',
                    'reasons',
                    'science_evidence',
                    'social_signals',
                    'expert_notes',
                  ])
                : null;
            const upAnswerObj = upAnswerJson && typeof upAnswerJson === 'object' && !Array.isArray(upAnswerJson) ? upAnswerJson : null;
            const answerLooksLikeProductAnalysis =
              upAnswerObj &&
              (upAnswerObj.assessment != null ||
                upAnswerObj.evidence != null ||
                upAnswerObj.analyze != null ||
                upAnswerObj.analysis != null ||
                upAnswerObj.product_analysis != null ||
                upAnswerObj.productAnalysis != null ||
                upAnswerObj.confidence != null ||
                upAnswerObj.missing_info != null ||
                upAnswerObj.missingInfo != null ||
                upAnswerObj.verdict != null ||
                upAnswerObj.reasons != null ||
                upAnswerObj.science_evidence != null ||
                upAnswerObj.scienceEvidence != null ||
                upAnswerObj.social_signals != null ||
                upAnswerObj.socialSignals != null ||
                upAnswerObj.expert_notes != null ||
                upAnswerObj.expertNotes != null);
            const structuredOrJson =
              upStructured && upStructured.analyze && typeof upStructured.analyze === 'object'
                ? upStructured
                : answerLooksLikeProductAnalysis
                  ? upAnswerObj
                  : upStructured || upAnswerObj;

            const mappedAnalyze =
              structuredOrJson && typeof structuredOrJson === 'object' && !Array.isArray(structuredOrJson)
                ? mapAuroraProductAnalysis(structuredOrJson)
                : structuredOrJson;
            const normAnalyze = normalizeProductAnalysis(mappedAnalyze);
            const keyIngredientsNow = (() => {
              const ev = normAnalyze.payload && typeof normAnalyze.payload === 'object' ? normAnalyze.payload.evidence : null;
              const sci = ev && typeof ev === 'object' ? ev.science : null;
              const key = sci && typeof sci === 'object' ? (sci.key_ingredients || sci.keyIngredients) : null;
              return Array.isArray(key) ? key.filter(Boolean) : [];
            })();
            return { normAnalyze, keyIngredientsNow };
          };

          let best = null;
          try {
            const upstream1 = await runScan(buildQuery(false), 12000);
            best = parseUpstream(upstream1);
          } catch {
            // ignore
          }

          const needsRetry = !best || !best.normAnalyze.payload.assessment || best.keyIngredientsNow.length === 0;
          if (needsRetry) {
            try {
              const upstream2 = await runScan(buildQuery(true), 11000);
              const parsed2 = parseUpstream(upstream2);
              if (parsed2 && parsed2.normAnalyze && parsed2.normAnalyze.payload && parsed2.normAnalyze.payload.assessment) {
                best = parsed2;
              }
            } catch {
              // ignore
            }
          }

          if (!best) return null;

          const enriched = enrichProductAnalysisPayload(best.normAnalyze.payload, { lang: ctx.lang, profileSummary });
          const out = { payload: enriched, field_missing: best.normAnalyze.field_missing };

          const keyAfterEnrich = (() => {
            const ev = enriched && typeof enriched === 'object' ? enriched.evidence : null;
            const sci = ev && typeof ev === 'object' ? ev.science : null;
            const key = sci && typeof sci === 'object' ? (sci.key_ingredients || sci.keyIngredients) : null;
            return Array.isArray(key) ? key.filter(Boolean) : [];
          })();
          if (enriched && enriched.assessment && keyAfterEnrich.length >= 3) {
            setDupeDeepscanCache(cacheKey, out);
          }

          return out;
        };

        const [origScan, dupeScan] = await Promise.all([
          scanOne({ productText: originalText, productObj: originalAnchor, productUrl: parsed.data.original_url }),
          scanOne({ productText: dupeText, productObj: dupeAnchor, productUrl: parsed.data.dupe_url }),
        ]);

        const origPayload = origScan && origScan.payload && typeof origScan.payload === 'object' ? origScan.payload : null;
        const dupePayload = dupeScan && dupeScan.payload && typeof dupeScan.payload === 'object' ? dupeScan.payload : null;

        const extractEvidence = (p) => {
          const ev = p && typeof p === 'object' ? p.evidence : null;
          const sci = ev && typeof ev === 'object' ? ev.science : null;
          const soc = ev && typeof ev === 'object' ? (ev.social_signals || ev.socialSignals) : null;
          return {
            key: uniqStrings(sci && Array.isArray(sci.key_ingredients || sci.keyIngredients) ? (sci.key_ingredients || sci.keyIngredients) : []),
            mech: uniqStrings(sci && Array.isArray(sci.mechanisms) ? sci.mechanisms : []),
            fit: uniqStrings(sci && Array.isArray(sci.fit_notes || sci.fitNotes) ? (sci.fit_notes || sci.fitNotes) : []),
            risk: uniqStrings(sci && Array.isArray(sci.risk_notes || sci.riskNotes) ? (sci.risk_notes || sci.riskNotes) : []),
            pos: uniqStrings(soc && Array.isArray(soc.typical_positive || soc.typicalPositive) ? (soc.typical_positive || soc.typicalPositive) : []),
            neg: uniqStrings(soc && Array.isArray(soc.typical_negative || soc.typicalNegative) ? (soc.typical_negative || soc.typicalNegative) : []),
            expert: uniqStrings(ev && Array.isArray(ev.expert_notes || ev.expertNotes) ? (ev.expert_notes || ev.expertNotes) : []),
            missing: uniqStrings(ev && Array.isArray(ev.missing_info || ev.missingInfo) ? (ev.missing_info || ev.missingInfo) : []),
            conf: ev && typeof ev.confidence === 'number' ? ev.confidence : null,
          };
        };

        const origEv = extractEvidence(origPayload);
        const dupEv = extractEvidence(dupePayload);

        const isCn = ctx.lang === 'CN';

        const ingredientSignals = (items) => {
          const out = {
            occlusives: [],
            humectants: [],
            soothing: [],
            exfoliants: [],
            brightening: [],
            peptides: [],
            fragrance: [],
            alcohol: [],
          };

          const seen = new Set();
          const add = (k, v) => {
            const s = typeof v === 'string' ? v.trim() : String(v || '').trim();
            if (!s) return;
            const key = `${k}:${s.toLowerCase()}`;
            if (seen.has(key)) return;
            seen.add(key);
            out[k].push(s);
          };

          for (const raw of Array.isArray(items) ? items : []) {
            const s = typeof raw === 'string' ? raw.trim() : String(raw || '').trim();
            if (!s) continue;
            const n = s.toLowerCase();

            // Ignore trivial carriers.
            if (n === 'water' || n === 'aqua') continue;

            if (
              n.includes('petrolatum') ||
              n.includes('petroleum jelly') ||
              n.includes('mineral oil') ||
              n.includes('paraffin') ||
              n.includes('dimethicone') ||
              n.includes('lanolin') ||
              n.includes('wax') ||
              n.includes('beeswax') ||
              n.includes('shea butter') ||
              n.includes('cocoa butter')
            ) {
              add('occlusives', s);
            }

            if (
              n.includes('glycerin') ||
              n.includes('hyaluronic') ||
              n.includes('sodium hyaluronate') ||
              n.includes('panthenol') ||
              n.includes('urea') ||
              n.includes('betaine') ||
              n.includes('sodium pca') ||
              n.includes('trehalose') ||
              n.includes('propanediol') ||
              n.includes('butylene glycol') ||
              n.includes('sorbitol')
            ) {
              add('humectants', s);
            }

            if (
              n.includes('panthenol') ||
              n.includes('allantoin') ||
              n.includes('madecassoside') ||
              n.includes('centella') ||
              n.includes('ceramide') ||
              n.includes('cholesterol') ||
              n.includes('beta-glucan') ||
              n.includes('cica')
            ) {
              add('soothing', s);
            }

            if (
              n.includes('glycolic') ||
              n.includes('lactic') ||
              n.includes('mandelic') ||
              n.includes('salicylic') ||
              n.includes('gluconolactone') ||
              n.includes('pha') ||
              n.includes('bha') ||
              n.includes('aha')
            ) {
              add('exfoliants', s);
            }

            if (
              n.includes('niacinamide') ||
              n.includes('tranexamic') ||
              n.includes('azelaic') ||
              n.includes('ascorbic') ||
              n.includes('vitamin c') ||
              n.includes('arbutin') ||
              n.includes('kojic') ||
              n.includes('licorice')
            ) {
              add('brightening', s);
            }

            if (n.includes('peptide')) add('peptides', s);

            if (
              n.includes('fragrance') ||
              n.includes('parfum') ||
              n.includes('essential oil') ||
              n.includes('limonene') ||
              n.includes('linalool') ||
              n.includes('citral')
            ) {
              add('fragrance', s);
            }

            if (n.includes('alcohol denat') || n.includes('denatured alcohol')) add('alcohol', s);
          }

          return out;
        };

        const pickFew = (arr, max) => uniqStrings(arr).slice(0, max);
        const joinFew = (arr, max) => pickFew(arr, max).join(', ');
        const nonEmpty = (arr) => Array.isArray(arr) && arr.length > 0;

        const origSig = ingredientSignals(origEv.key);
        const dupSig = ingredientSignals(dupEv.key);

        const derivedTradeoffs = [];

        // More human, high-signal comparisons (avoid dumping full INCI).
        if (nonEmpty(origSig.occlusives) && !nonEmpty(dupSig.occlusives) && nonEmpty(dupSig.humectants)) {
          derivedTradeoffs.push(
            isCn
              ? `/ ${joinFew(origSig.occlusives, 2)} ${joinFew(dupSig.humectants, 2)} `
              : `Texture/finish: Original is more occlusive (e.g., ${joinFew(origSig.occlusives, 2)}) while the dupe is more humectant (e.g., ${joinFew(dupSig.humectants, 2)})  lighter feel, but may need a moisturizer on top to seal.`,
          );
        } else if (nonEmpty(dupSig.occlusives) && !nonEmpty(origSig.occlusives) && nonEmpty(origSig.humectants)) {
          derivedTradeoffs.push(
            isCn
              ? `/ ${joinFew(dupSig.occlusives, 2)} ${joinFew(origSig.humectants, 2)} `
              : `Texture/finish: Dupe is more occlusive (e.g., ${joinFew(dupSig.occlusives, 2)}) while the original is more humectant (e.g., ${joinFew(origSig.humectants, 2)})  dupe may feel richer and more sealing.`,
          );
        } else if (nonEmpty(origSig.occlusives) && nonEmpty(dupSig.occlusives)) {
          derivedTradeoffs.push(
            isCn
              ? `/${joinFew(origSig.occlusives, 2)}${joinFew(dupSig.occlusives, 2)} /`
              : `Shared: Both include occlusive/emollient components (orig: ${joinFew(origSig.occlusives, 2)}; dupe: ${joinFew(dupSig.occlusives, 2)})  both can be sealing; differences may come from formula balance.`,
          );
        }

        if (nonEmpty(origSig.humectants) && nonEmpty(dupSig.humectants) && derivedTradeoffs.length < 2) {
          derivedTradeoffs.push(
            isCn
              ? `${joinFew(origSig.humectants, 2)}${joinFew(dupSig.humectants, 2)} `
              : `Shared: Both include humectants (orig: ${joinFew(origSig.humectants, 2)}; dupe: ${joinFew(dupSig.humectants, 2)})  both support hydration; how sealing it feels depends on occlusives.`,
          );
        }

        if (nonEmpty(dupSig.exfoliants)) {
          derivedTradeoffs.push(
            isCn
              ? ` ${joinFew(dupSig.exfoliants, 2)} /`
              : `Irritation risk: Dupe includes exfoliant-like actives (e.g., ${joinFew(dupSig.exfoliants, 2)})  higher irritation risk if your barrier is impaired; start low and avoid stacking strong actives.`,
          );
        }

        if (nonEmpty(dupSig.fragrance) && !nonEmpty(origSig.fragrance)) {
          derivedTradeoffs.push(
            isCn
              ? `// ${joinFew(dupSig.fragrance, 1)} `
              : `Fragrance risk: Dupe may include fragrance-related ingredients (e.g., ${joinFew(dupSig.fragrance, 1)})  higher risk for sensitive skin.`,
          );
        }

        const addedRisks = dupEv.risk.filter((k) => !origEv.risk.includes(k));
        if (addedRisks.length) {
          derivedTradeoffs.push(
            isCn
              ? `${addedRisks.slice(0, 2).join('  ')}`
              : `Dupe risk notes: ${addedRisks.slice(0, 2).join('  ')}`,
          );
        }

        if (derivedTradeoffs.length < 2) {
          const origPreview = pickFew([...origSig.occlusives, ...origSig.humectants, ...origSig.soothing, ...origSig.brightening, ...origSig.exfoliants], 3);
          const dupPreview = pickFew([...dupSig.occlusives, ...dupSig.humectants, ...dupSig.soothing, ...dupSig.brightening, ...dupSig.exfoliants], 3);
          if (origPreview.length && dupPreview.length) {
            derivedTradeoffs.push(
              isCn
                ? `${origPreview.length ? origPreview.join(' / ') : ''}${dupPreview.length ? dupPreview.join(' / ') : ''}`
                : `Key ingredient emphasis (brief): original  ${origPreview.length ? origPreview.join(' / ') : 'unknown'}; dupe  ${dupPreview.length ? dupPreview.join(' / ') : 'unknown'}.`,
            );
          }
        }

        const origHero = origPayload && origPayload.assessment && typeof origPayload.assessment === 'object'
          ? (origPayload.assessment.hero_ingredient || origPayload.assessment.heroIngredient)
          : null;
        const dupHero = dupePayload && dupePayload.assessment && typeof dupePayload.assessment === 'object'
          ? (dupePayload.assessment.hero_ingredient || dupePayload.assessment.heroIngredient)
          : null;
        if (origHero && dupHero && origHero.name && dupHero.name && String(origHero.name).toLowerCase() !== String(dupHero.name).toLowerCase()) {
          derivedTradeoffs.push(`Hero ingredient shift: ${origHero.name}  ${dupHero.name}`);
        }

        const outConfidence = typeof origEv.conf === 'number' && typeof dupEv.conf === 'number'
          ? (origEv.conf + dupEv.conf) / 2
          : (origEv.conf || dupEv.conf || null);

        const labelLines = (label, arr, max) => uniqStrings(arr).slice(0, max).map((x) => `${label}: ${x}`);

        const mergedEvidence = {
          science: {
            key_ingredients: uniqStrings([...origEv.key, ...dupEv.key]),
            mechanisms: uniqStrings([...origEv.mech, ...dupEv.mech]).slice(0, 8),
            fit_notes: uniqStrings([...labelLines('Original', origEv.fit, 3), ...labelLines('Dupe', dupEv.fit, 3)]),
            risk_notes: uniqStrings([...labelLines('Original', origEv.risk, 3), ...labelLines('Dupe', dupEv.risk, 3)]),
          },
          social_signals: {
            typical_positive: uniqStrings([...labelLines('Original', origEv.pos, 3), ...labelLines('Dupe', dupEv.pos, 3)]),
            typical_negative: uniqStrings([...labelLines('Original', origEv.neg, 3), ...labelLines('Dupe', dupEv.neg, 3)]),
            risk_for_groups: [],
          },
          expert_notes: uniqStrings([...labelLines('Original', origEv.expert, 2), ...labelLines('Dupe', dupEv.expert, 2)]),
          confidence: outConfidence,
          missing_info: uniqStrings(['tradeoffs_from_product_analyze_diff', ...origEv.missing, ...dupEv.missing]),
        };

        const origAnchorOut =
          (origPayload && origPayload.assessment && typeof origPayload.assessment === 'object'
            ? (origPayload.assessment.anchor_product || origPayload.assessment.anchorProduct)
            : null) || payload.original || null;
        const dupeAnchorOut =
          (dupePayload && dupePayload.assessment && typeof dupePayload.assessment === 'object'
            ? (dupePayload.assessment.anchor_product || dupePayload.assessment.anchorProduct)
            : null) || payload.dupe || null;

        if (derivedTradeoffs.length) {
          const rawOut = {
            original: origAnchorOut,
            dupe: dupeAnchorOut,
            ...(payload.similarity != null ? { similarity: payload.similarity } : {}),
            ...(payload.tradeoffs_detail ? { tradeoffs_detail: payload.tradeoffs_detail } : {}),
            tradeoffs: derivedTradeoffs.slice(0, 6),
            evidence: mergedEvidence,
            confidence: outConfidence,
            missing_info: uniqStrings([
              ...uniqStrings(payload.missing_info).filter((c) => c !== 'evidence_missing'),
              'compare_tradeoffs_missing_used_deepscan_diff',
            ]),
          };
          const norm2 = normalizeDupeCompare(rawOut);
          payload = norm2.payload;
          field_missing = mergeFieldMissing(field_missing.filter((x) => x && x.field !== 'tradeoffs'), norm2.field_missing);
          field_missing = mergeFieldMissing(field_missing, mergeFieldMissing(origScan && origScan.field_missing, dupeScan && dupeScan.field_missing));
        }
      }

      if (!Array.isArray(payload.tradeoffs) || payload.tradeoffs.length === 0) {
        const note =
          ctx.lang === 'CN'
            ? '/'
            : 'No tradeoff details were returned (comparison is limited). Provide the dupe link/full name or pick from suggested alternatives to compare again.';
        payload = { ...payload, tradeoffs: [note] };
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `dupe_${ctx.request_id}`,
            type: 'dupe_compare',
            payload,
            ...(field_missing?.length ? { field_missing: field_missing.slice(0, 8) } : {}),
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'dupe_compare' })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to compare products.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'DUPE_COMPARE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'DUPE_COMPARE_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/reco/generate', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = RecoGenerateRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const identity = await resolveIdentity(req, ctx);
      const profile = await getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }).catch(() => null);
      const recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7).catch(() => []);
      const profileSummary = summarizeProfileForContext(profile);

      const gate = shouldDiagnosisGate({ message: 'recommend', triggerSource: 'action', profile });
      if (gate.gated) {
        const prompt = buildDiagnosisPrompt(ctx.lang, gate.missing);
        const chips = buildDiagnosisChips(ctx.lang, gate.missing);
        const sessionPatch = { next_state: 'S2_DIAGNOSIS' };
        if (AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED) {
          const pendingFromGate =
            gate.pending_clarification ||
            buildPendingClarificationForGate({
              language: ctx.lang,
              missing: gate.missing,
              message: 'recommend',
              wants: 'recommendation',
            });
          if (pendingFromGate) emitPendingClarificationPatch(sessionPatch, pendingFromGate);
        }
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage(prompt),
          suggested_chips: chips,
          cards: [
            {
              card_id: `diag_${ctx.request_id}`,
              type: 'diagnosis_gate',
              payload: { reason: gate.reason, missing_fields: gate.missing, wants: 'recommendation', profile: profileSummary, recent_logs: recentLogs },
            },
          ],
          session_patch: sessionPatch,
          events: [makeEvent({ ...ctx, trigger_source: 'action' }, 'state_entered', { next_state: 'S2_DIAGNOSIS', reason: gate.reason })],
        });
        return res.json(envelope);
      }

      const query = buildAuroraRoutineQuery({
        profile: { ...profileSummary, ...(profile && profile.currentRoutine ? { currentRoutine: profile.currentRoutine } : {}) },
        focus: parsed.data.focus,
        constraints: parsed.data.constraints || {},
        lang: ctx.lang,
      });

      let upstream = null;
      try {
        upstream = await auroraChat({ baseUrl: AURORA_DECISION_BASE_URL, query, timeoutMs: 22000 });
      } catch (err) {
        // ignore
      }

      const routine = upstream && upstream.context && typeof upstream.context === 'object' ? upstream.context.routine : null;
      const mapped = mapAuroraRoutineToRecoGenerate(routine, upstream && upstream.context && typeof upstream.context === 'object' ? upstream.context : null);
      const norm = normalizeRecoGenerate(mapped);
      if (parsed.data.include_alternatives) {
        const alt = await enrichRecommendationsWithAlternatives({
          ctx,
          profileSummary,
          recentLogs,
          recommendations: norm.payload.recommendations,
          logger,
        });
        norm.payload = { ...norm.payload, recommendations: alt.recommendations };
        norm.field_missing = mergeFieldMissing(norm.field_missing, alt.field_missing);
      }
      const payload = norm.payload;

      const suggestedChips = [];
      const nextActions = upstream && Array.isArray(upstream.next_actions) ? upstream.next_actions : [];
      if ((!payload.recommendations || payload.recommendations.length === 0) && nextActions.length) {
        for (const act of nextActions.slice(0, 8)) {
          if (!act || typeof act !== 'object') continue;
          const label = typeof act.label === 'string' ? act.label.trim() : typeof act.text === 'string' ? act.text.trim() : '';
          const text = typeof act.text === 'string' ? act.text.trim() : label;
          const id = typeof act.id === 'string' ? act.id.trim() : '';
          if (!label) continue;
          suggestedChips.push({
            chip_id: `chip.aurora.next_action.${id || label.replace(/\\s+/g, '_')}`.slice(0, 80),
            label,
            kind: 'quick_reply',
            data: { reply_text: text, aurora_action_id: id || null },
          });
        }
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: suggestedChips,
        cards: [
          {
            card_id: `reco_${ctx.request_id}`,
            type: 'recommendations',
            payload,
            ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
          },
        ],
        session_patch: payload.recommendations && payload.recommendations.length ? { next_state: 'S7_PRODUCT_RECO' } : {},
        events: [makeEvent({ ...ctx, trigger_source: 'action' }, 'recos_requested', { explicit: true })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to generate recommendations.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'RECO_GENERATE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'RECO_GENERATE_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/photos/presign', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = PhotosPresignRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      if (USE_AURORA_BFF_MOCK) {
        // Stub: real storage/QC should be wired via pivota-backend photos endpoints.
        const photoId = `photo_${ctx.request_id}_${Date.now()}`;
        const payload = {
          photo_id: photoId,
          slot_id: parsed.data.slot_id,
          upload: {
            method: 'PUT',
            url: null,
            headers: {},
            expires_in_seconds: 600,
          },
        };

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `presign_${ctx.request_id}`,
              type: 'photo_presign',
              payload,
              field_missing: [{ field: 'upload.url', reason: 'mock_mode' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_presign' })],
        });
        return res.json(envelope);
      }

      if (!PIVOTA_BACKEND_BASE_URL) {
        const photoId = `photo_${ctx.request_id}_${Date.now()}`;
        const payload = {
          photo_id: photoId,
          slot_id: parsed.data.slot_id,
          upload: {
            method: 'PUT',
            url: null,
            headers: {},
            expires_in_seconds: 600,
          },
        };

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `presign_${ctx.request_id}`,
              type: 'photo_presign',
              payload,
              field_missing: [{ field: 'upload.url', reason: 'pivota_backend_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_presign' })],
        });
        return res.json(envelope);
      }

      const authHeaders = buildPivotaBackendAuthHeaders(req);
      if (!Object.keys(authHeaders).length) {
        const photoId = `photo_${ctx.request_id}_${Date.now()}`;
        const payload = {
          photo_id: photoId,
          slot_id: parsed.data.slot_id,
          upload: {
            method: 'PUT',
            url: null,
            headers: {},
            expires_in_seconds: 600,
          },
        };

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `presign_${ctx.request_id}`,
              type: 'photo_presign',
              payload,
              field_missing: [{ field: 'upload.url', reason: 'pivota_backend_auth_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_presign' })],
        });
        return res.json(envelope);
      }

      const contentType =
        typeof parsed.data.content_type === 'string' && parsed.data.content_type.trim()
          ? parsed.data.content_type.trim()
          : 'image/jpeg';
      const byteSize = typeof parsed.data.bytes === 'number' && Number.isFinite(parsed.data.bytes) ? parsed.data.bytes : null;

      const upstreamResp = await axios.post(
        `${PIVOTA_BACKEND_BASE_URL}/photos/presign`,
        {
          content_type: contentType,
          ...(byteSize ? { byte_size: byteSize } : {}),
          consent: true,
          user_id: ctx.aurora_uid,
        },
        {
          timeout: 12000,
          validateStatus: () => true,
          headers: { 'Content-Type': 'application/json', ...authHeaders },
        },
      );

      if (upstreamResp.status !== 200 || !upstreamResp.data || !upstreamResp.data.upload_id || !upstreamResp.data.upload) {
        const detail = pickUpstreamErrorDetail(upstreamResp.data);
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Failed to presign upload.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: {
                error: 'PHOTO_PRESIGN_UPSTREAM_FAILED',
                status: upstreamResp.status,
                detail: detail || null,
              },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_PRESIGN_UPSTREAM_FAILED', status: upstreamResp.status })],
        });
        return res.status(upstreamResp.status >= 400 ? upstreamResp.status : 502).json(envelope);
      }

      const uploadId = String(upstreamResp.data.upload_id);
      const upstreamUpload = upstreamResp.data.upload || {};
      const expiresInSeconds = secondsUntilIso(upstreamResp.data.expires_at) ?? 900;

      const payload = {
        photo_id: uploadId,
        slot_id: parsed.data.slot_id,
        upload: {
          method: upstreamUpload.method || 'PUT',
          url: upstreamUpload.url || null,
          headers: upstreamUpload.headers || {},
          expires_in_seconds: expiresInSeconds,
        },
        ...(typeof upstreamResp.data.max_bytes === 'number' ? { max_bytes: upstreamResp.data.max_bytes } : {}),
        ...(upstreamResp.data.tips ? { tips: upstreamResp.data.tips } : {}),
      };

      const fieldMissing = [];
      if (!payload.upload.url) fieldMissing.push({ field: 'upload.url', reason: 'upstream_missing_upload_url' });

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `presign_${ctx.request_id}`,
            type: 'photo_presign',
            payload,
            ...(fieldMissing.length ? { field_missing: fieldMissing } : {}),
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'value_moment', { kind: 'photo_presign' })],
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to presign upload.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'PHOTO_PRESIGN_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'PHOTO_PRESIGN_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  // Proxy upload to avoid browser-to-storage CORS issues.
  // Request: multipart/form-data with fields:
  // - slot_id (required)
  // - consent=true (required)
  // - file field: photo (required)
  app.post('/v1/photos/upload', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    let tmpDir = null;
    try {
      requireAuroraUid(ctx);

      if (USE_AURORA_BFF_MOCK) {
        const photoId = `photo_${ctx.request_id}_${Date.now()}`;
        const payload = {
          photo_id: photoId,
          slot_id: 'daylight',
          qc_status: 'passed',
          qc: { state: 'done', qc_status: 'passed', advice: { summary: 'Mock: photo looks good.', suggestions: [] } },
        };
        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `confirm_${ctx.request_id}`,
              type: 'photo_confirm',
              payload,
              field_missing: [{ field: 'upload.url', reason: 'mock_mode' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_upload', qc_status: 'passed' })],
        });
        return res.json(envelope);
      }

      const authHeaders = buildPivotaBackendAuthHeaders(req);
      if (!PIVOTA_BACKEND_BASE_URL) {
        const payload = { photo_id: null, slot_id: null, qc_status: null };
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Photo upload is not configured.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `confirm_${ctx.request_id}`,
              type: 'photo_confirm',
              payload,
              field_missing: [{ field: 'photo_id', reason: 'pivota_backend_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_UPLOAD_NOT_CONFIGURED' })],
        });
        return res.status(501).json(envelope);
      }
      if (!Object.keys(authHeaders).length) {
        const payload = { photo_id: null, slot_id: null, qc_status: null };
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Photo upload auth is not configured.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `confirm_${ctx.request_id}`,
              type: 'photo_confirm',
              payload,
              field_missing: [{ field: 'photo_id', reason: 'pivota_backend_auth_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_UPLOAD_AUTH_NOT_CONFIGURED' })],
        });
        return res.status(501).json(envelope);
      }

      const reqContentType = String(req.headers['content-type'] || '').toLowerCase();
      if (!reqContentType.includes('multipart/form-data') || !reqContentType.includes('boundary=')) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', detail: 'multipart_required' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const { fields, files, tmpDir: parsedTmpDir } = await parseMultipart(req, {
        maxBytes: PHOTO_UPLOAD_PROXY_MAX_BYTES,
        parseTimeoutMs: PHOTO_UPLOAD_PARSE_TIMEOUT_MS,
        allowedContentTypes: new Set(['image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif']),
        requiredFields: ['slot_id', 'consent'],
      });
      tmpDir = parsedTmpDir;

      const slotId = String(fields.slot_id || '').trim();
      if (!slotId) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Missing slot_id.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', detail: 'slot_id_required' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const consentRaw = String(fields.consent || '').trim().toLowerCase();
      const consent = consentRaw === 'true' || consentRaw === '1' || consentRaw === 'yes';
      if (!consent) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('User consent is required.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'USER_CONSENT_REQUIRED' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'USER_CONSENT_REQUIRED' })],
        });
        return res.status(400).json(envelope);
      }

      const fileEntry = files.photo || files.file || files.image || Object.values(files || {})[0];
      if (!fileEntry || !fileEntry.path) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Missing photo file.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', detail: 'photo_file_required' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const stat = fs.statSync(fileEntry.path);
      const byteSize = Number.isFinite(stat.size) ? stat.size : null;
      const contentType = fileEntry.contentType || 'image/jpeg';

      const presignResp = await axios.post(
        `${PIVOTA_BACKEND_BASE_URL}/photos/presign`,
        {
          content_type: contentType,
          ...(byteSize ? { byte_size: byteSize } : {}),
          consent: true,
          user_id: ctx.aurora_uid,
        },
        {
          timeout: 12000,
          validateStatus: () => true,
          headers: { 'Content-Type': 'application/json', ...authHeaders },
        },
      );

      if (presignResp.status !== 200 || !presignResp.data || !presignResp.data.upload_id || !presignResp.data.upload) {
        const detail = pickUpstreamErrorDetail(presignResp.data);
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Failed to start photo upload.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: { error: 'PHOTO_PRESIGN_UPSTREAM_FAILED', status: presignResp.status, detail: detail || null },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_PRESIGN_UPSTREAM_FAILED', status: presignResp.status })],
        });
        return res.status(presignResp.status >= 400 ? presignResp.status : 502).json(envelope);
      }

      const uploadId = String(presignResp.data.upload_id);
      const upstreamUpload = presignResp.data.upload || {};
      const uploadUrl = typeof upstreamUpload.url === 'string' ? upstreamUpload.url.trim() : '';
      const uploadMethod = typeof upstreamUpload.method === 'string' && upstreamUpload.method.trim()
        ? upstreamUpload.method.trim().toUpperCase()
        : 'PUT';
      const uploadHeaders = upstreamUpload.headers && typeof upstreamUpload.headers === 'object' ? upstreamUpload.headers : {};

      if (!uploadUrl) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Upload URL is missing from upstream.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'UPSTREAM_MISSING_UPLOAD_URL' } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'UPSTREAM_MISSING_UPLOAD_URL' })],
        });
        return res.status(502).json(envelope);
      }

      const hasHeader = (headersObj, key) => {
        const wanted = String(key || '').toLowerCase();
        for (const k of Object.keys(headersObj || {})) {
          if (String(k).toLowerCase() === wanted) return true;
        }
        return false;
      };

      const finalUploadHeaders = { ...uploadHeaders };
      // Some S3-compatible providers require a Content-Length (otherwise 411 Length Required).
      if (byteSize && !hasHeader(finalUploadHeaders, 'content-length')) {
        finalUploadHeaders['Content-Length'] = String(byteSize);
      }
      // Ensure Content-Type is present if upstream didn't include it.
      if (contentType && !hasHeader(finalUploadHeaders, 'content-type')) {
        finalUploadHeaders['Content-Type'] = contentType;
      }

      const uploadResp = await axios.request({
        method: uploadMethod,
        url: uploadUrl,
        headers: finalUploadHeaders,
        data: fs.createReadStream(fileEntry.path),
        timeout: 120000,
        maxBodyLength: 30 * 1024 * 1024,
        maxContentLength: 30 * 1024 * 1024,
        validateStatus: () => true,
      });

      if (uploadResp.status < 200 || uploadResp.status >= 300) {
        const detail =
          typeof uploadResp.data === 'string'
            ? uploadResp.data.slice(0, 4000)
            : uploadResp.data && typeof uploadResp.data === 'object'
              ? JSON.stringify(uploadResp.data).slice(0, 4000)
              : null;
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Failed to upload photo bytes.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: { error: 'PHOTO_UPLOAD_BYTES_FAILED', status: uploadResp.status, detail },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_UPLOAD_BYTES_FAILED', status: uploadResp.status })],
        });
        return res.status(502).json(envelope);
      }

      const confirmResp = await axios.post(
        `${PIVOTA_BACKEND_BASE_URL}/photos/confirm`,
        { upload_id: uploadId, ...(byteSize ? { byte_size: byteSize } : {}) },
        {
          timeout: 12000,
          validateStatus: () => true,
          headers: { 'Content-Type': 'application/json', ...authHeaders },
        },
      );

      if (confirmResp.status !== 200 || !confirmResp.data) {
        const detail = pickUpstreamErrorDetail(confirmResp.data);
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Failed to confirm upload.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: { error: 'PHOTO_CONFIRM_UPSTREAM_FAILED', status: confirmResp.status, detail: detail || null },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_CONFIRM_UPSTREAM_FAILED', status: confirmResp.status })],
        });
        return res.status(confirmResp.status >= 400 ? confirmResp.status : 502).json(envelope);
      }

      let qcStatus = resolvePhotoQcStatus(confirmResp.data);
      let qc = confirmResp.data.qc && typeof confirmResp.data.qc === 'object' ? confirmResp.data.qc : null;
      let nextPollMs = typeof confirmResp.data.next_poll_ms === 'number' ? confirmResp.data.next_poll_ms : null;

      const deadlineMs = Date.now() + 6000;
      let lastQcData = null;
      while (!qcStatus && Date.now() < deadlineMs) {
        const waitMs = Math.min(1200, Math.max(400, nextPollMs || 1000));
        await sleep(waitMs);

        const qcResp = await axios.get(`${PIVOTA_BACKEND_BASE_URL}/photos/qc`, {
          timeout: 12000,
          validateStatus: () => true,
          headers: authHeaders,
          params: { upload_id: uploadId },
        });

        if (qcResp.status !== 200 || !qcResp.data) break;
        lastQcData = qcResp.data;
        const resolvedPollStatus = resolvePhotoQcStatus(qcResp.data);
        if (resolvedPollStatus) qcStatus = resolvedPollStatus;
        qc = qcResp.data.qc && typeof qcResp.data.qc === 'object' ? qcResp.data.qc : qc;
        nextPollMs = typeof qcResp.data.next_poll_ms === 'number' ? qcResp.data.next_poll_ms : nextPollMs;
      }

      const payload = {
        photo_id: uploadId,
        slot_id: slotId,
        qc_status: qcStatus,
        ...(qc ? { qc } : {}),
        ...(typeof nextPollMs === 'number' ? { next_poll_ms: nextPollMs } : {}),
        ...(!qcStatus && lastQcData ? { qc_pending: true } : {}),
      };

      try {
        const uploadBuffer = fs.readFileSync(fileEntry.path);
        setPhotoBytesCache({
          photoId: uploadId,
          auroraUid: ctx.aurora_uid,
          buffer: uploadBuffer,
          contentType,
        });
      } catch (cacheErr) {
        logger?.warn({ err: cacheErr && cacheErr.message ? cacheErr.message : String(cacheErr) }, 'aurora bff: failed to cache upload bytes');
      }

      const fieldMissing = [];
      if (!qcStatus) fieldMissing.push({ field: 'qc_status', reason: 'qc_pending' });

      const photoConfirmCard = {
        card_id: `confirm_${ctx.request_id}`,
        type: 'photo_confirm',
        payload,
        ...(fieldMissing.length ? { field_missing: fieldMissing } : {}),
      };
      const autoAnalysis = await safeBuildAutoAnalysisFromConfirmedPhoto({
        req,
        ctx,
        photoId: uploadId,
        slotId,
        qcStatus,
        logger,
      });

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [photoConfirmCard, ...(autoAnalysis && Array.isArray(autoAnalysis.cards) ? autoAnalysis.cards : [])],
        session_patch: autoAnalysis && autoAnalysis.session_patch ? autoAnalysis.session_patch : {},
        events: [
          makeEvent(ctx, 'value_moment', { kind: 'photo_upload', qc_status: qcStatus }),
          ...(autoAnalysis && autoAnalysis.event ? [autoAnalysis.event] : []),
        ],
      });
      return res.json(envelope);
    } catch (err) {
      const status = Number(err?.statusCode || err?.status || 500);
      const code = err?.code || 'PHOTO_UPLOAD_FAILED';
      logger?.error(
        {
          err: err && err.message ? err.message : String(err),
          code,
          request_id: ctx.request_id,
          trace_id: ctx.trace_id,
          aurora_uid: ctx.aurora_uid,
        },
        'aurora bff: /v1/photos/upload failed',
      );
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to upload photo.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: code } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    } finally {
      if (tmpDir) rmrf(tmpDir);
    }
  });

  app.post('/v1/photos/confirm', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = PhotosConfirmRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      if (USE_AURORA_BFF_MOCK) {
        const qcStatus = 'passed';
        const payload = { ...parsed.data, qc_status: qcStatus };

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [{ card_id: `confirm_${ctx.request_id}`, type: 'photo_confirm', payload }],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_confirm', qc_status: qcStatus })],
        });
        return res.json(envelope);
      }

      if (!PIVOTA_BACKEND_BASE_URL) {
        const payload = { ...parsed.data, qc_status: null };
        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `confirm_${ctx.request_id}`,
              type: 'photo_confirm',
              payload,
              field_missing: [{ field: 'qc_status', reason: 'pivota_backend_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_confirm', qc_status: null })],
        });
        return res.json(envelope);
      }

      const authHeaders = buildPivotaBackendAuthHeaders(req);
      if (!Object.keys(authHeaders).length) {
        const payload = { ...parsed.data, qc_status: null };
        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `confirm_${ctx.request_id}`,
              type: 'photo_confirm',
              payload,
              field_missing: [{ field: 'qc_status', reason: 'pivota_backend_auth_not_configured' }],
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'photo_confirm', qc_status: null })],
        });
        return res.json(envelope);
      }

      const uploadId = parsed.data.photo_id;
      const confirmResp = await axios.post(
        `${PIVOTA_BACKEND_BASE_URL}/photos/confirm`,
        { upload_id: uploadId },
        {
          timeout: 12000,
          validateStatus: () => true,
          headers: { 'Content-Type': 'application/json', ...authHeaders },
        },
      );

      if (confirmResp.status !== 200 || !confirmResp.data) {
        const detail = pickUpstreamErrorDetail(confirmResp.data);
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Failed to confirm upload.'),
          suggested_chips: [],
          cards: [
            {
              card_id: `err_${ctx.request_id}`,
              type: 'error',
              payload: {
                error: 'PHOTO_CONFIRM_UPSTREAM_FAILED',
                status: confirmResp.status,
                detail: detail || null,
              },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'PHOTO_CONFIRM_UPSTREAM_FAILED', status: confirmResp.status })],
        });
        return res.status(confirmResp.status >= 400 ? confirmResp.status : 502).json(envelope);
      }

      let qcStatus = resolvePhotoQcStatus(confirmResp.data);
      let qc = confirmResp.data.qc && typeof confirmResp.data.qc === 'object' ? confirmResp.data.qc : null;
      let nextPollMs = typeof confirmResp.data.next_poll_ms === 'number' ? confirmResp.data.next_poll_ms : null;

      const deadlineMs = Date.now() + 6000;
      let lastQcData = null;
      while (!qcStatus && Date.now() < deadlineMs) {
        const waitMs = Math.min(1200, Math.max(400, nextPollMs || 1000));
        await sleep(waitMs);

        const qcResp = await axios.get(`${PIVOTA_BACKEND_BASE_URL}/photos/qc`, {
          timeout: 12000,
          validateStatus: () => true,
          headers: authHeaders,
          params: { upload_id: uploadId },
        });

        if (qcResp.status !== 200 || !qcResp.data) break;

        lastQcData = qcResp.data;
        const resolvedPollStatus = resolvePhotoQcStatus(qcResp.data);
        if (resolvedPollStatus) qcStatus = resolvedPollStatus;
        qc = qcResp.data.qc && typeof qcResp.data.qc === 'object' ? qcResp.data.qc : qc;
        nextPollMs = typeof qcResp.data.next_poll_ms === 'number' ? qcResp.data.next_poll_ms : nextPollMs;
      }

      const payload = {
        ...parsed.data,
        qc_status: qcStatus,
        ...(qc ? { qc } : {}),
        ...(typeof nextPollMs === 'number' ? { next_poll_ms: nextPollMs } : {}),
        ...(!qcStatus && lastQcData ? { qc_pending: true } : {}),
      };

      const fieldMissing = [];
      if (!qcStatus) fieldMissing.push({ field: 'qc_status', reason: 'qc_pending' });

      const photoConfirmCard = {
        card_id: `confirm_${ctx.request_id}`,
        type: 'photo_confirm',
        payload,
        ...(fieldMissing.length ? { field_missing: fieldMissing } : {}),
      };
      const autoAnalysis = await safeBuildAutoAnalysisFromConfirmedPhoto({
        req,
        ctx,
        photoId: uploadId,
        slotId: parsed.data.slot_id || null,
        qcStatus,
        logger,
      });

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [photoConfirmCard, ...(autoAnalysis && Array.isArray(autoAnalysis.cards) ? autoAnalysis.cards : [])],
        session_patch: autoAnalysis && autoAnalysis.session_patch ? autoAnalysis.session_patch : {},
        events: [
          makeEvent(ctx, 'value_moment', { kind: 'photo_confirm', qc_status: qcStatus }),
          ...(autoAnalysis && autoAnalysis.event ? [autoAnalysis.event] : []),
        ],
      });
      return res.json(envelope);
    } catch (err) {
      const status = Number(err?.statusCode || err?.status || 500);
      const code = err?.code || 'PHOTO_CONFIRM_FAILED';
      logger?.error(
        {
          err: err && err.message ? err.message : String(err),
          code,
          request_id: ctx.request_id,
          trace_id: ctx.trace_id,
          aurora_uid: ctx.aurora_uid,
        },
        'aurora bff: /v1/photos/confirm failed',
      );
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to confirm upload.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: code } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/analysis/skin', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    const rollout = getDiagRolloutDecision({ requestId: ctx.request_id });
    const outputPipelineVersion = rollout.shadowMode ? 'legacy' : rollout.selectedVersion;
    const shadowRunV2 = rollout.shadowMode && rollout.selectedVersion === 'v2';

    logger?.info(
      {
        kind: 'diag_rollout',
        request_id: ctx.request_id,
        trace_id: ctx.trace_id,
        output_pipeline_version: outputPipelineVersion,
        selected_pipeline_version: rollout.selectedVersion,
        reason: rollout.reason,
        shadow_mode: rollout.shadowMode,
        canary_percent: rollout.canaryPercent,
        canary_bucket: rollout.canaryBucket,
        llm_kill_switch: rollout.llmKillSwitch,
      },
      'aurora bff: diag rollout decision',
    );
    try {
      requireAuroraUid(ctx);
      const parsed = SkinAnalysisRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      recordAuroraSkinFlowMetric({ stage: 'analysis_request', hit: true });

      const identity = await resolveIdentity(req, ctx);
      const runOnce = async ({ pipelineVersion, persistLastAnalysis, shadowRun } = {}) => {
        const profiler = createStageProfiler();
        profiler.skip('face', 'not_implemented');
        profiler.skip('skin_roi', 'not_implemented');

        const experiments = assignExperiments({ requestId: ctx.request_id });
        const experimentsSlim = Array.isArray(experiments.assignments)
          ? experiments.assignments
              .map((a) => ({
                experiment_id: a.experiment_id,
                kind: a.kind,
                variant: a.variant,
                ...(typeof a.bucket === 'number' ? { bucket: a.bucket } : {}),
                ...(a.reason ? { reason: a.reason } : {}),
              }))
              .slice(0, 8)
          : [];
        if (experiments.error) {
          logger?.warn(
            { err: String(experiments.error), request_id: ctx.request_id, trace_id: ctx.trace_id },
            'aurora bff: experiments config invalid',
          );
        }

        const qualityGateConfig =
          experiments.byKind && experiments.byKind.quality_gate && experiments.byKind.quality_gate.params
            ? experiments.byKind.quality_gate.params
            : null;
        const severityThresholdsOverrides =
          experiments.byKind && experiments.byKind.severity_mapping && experiments.byKind.severity_mapping.params
            ? experiments.byKind.severity_mapping.params
            : null;
        const promptParams =
          experiments.byKind && experiments.byKind.llm_prompt && experiments.byKind.llm_prompt.params
            ? experiments.byKind.llm_prompt.params
            : null;
        const promptVersionFromParams =
          promptParams && typeof promptParams.prompt_version === 'string' && promptParams.prompt_version.trim()
            ? promptParams.prompt_version.trim()
            : null;
        const promptVersion =
          promptVersionFromParams ||
          (experiments.byKind &&
          experiments.byKind.llm_prompt &&
          typeof experiments.byKind.llm_prompt.variant === 'string' &&
          experiments.byKind.llm_prompt.variant &&
          experiments.byKind.llm_prompt.variant !== 'holdout'
            ? experiments.byKind.llm_prompt.variant
            : null);

        let profile = null;
        let recentLogs = [];
        profiler.start('quality', { kind: 'memory' });
        try {
          const [profileRes, logsRes] = await Promise.allSettled([
            getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }),
            getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7),
          ]);
          if (profileRes.status === 'fulfilled') profile = profileRes.value;
          else {
            const r = profileRes.reason;
            logger?.warn(
              { err: r && (r.code || r.message) ? String(r.code || r.message) : String(r) },
              'aurora bff: failed to load profile',
            );
          }
          if (logsRes.status === 'fulfilled') recentLogs = logsRes.value;
          else {
            const r = logsRes.reason;
            logger?.warn(
              { err: r && (r.code || r.message) ? String(r.code || r.message) : String(r) },
              'aurora bff: failed to load recent logs',
            );
          }
        } catch (err) {
          logger?.warn({ err: err.code || err.message }, 'aurora bff: failed to load memory context');
        }

        const photos = Array.isArray(parsed.data.photos) ? parsed.data.photos : [];
        const photoQcParts = [];
        const passedPhotos = [];
        const degradedPhotos = [];
        const failedPhotos = [];
        let photosSubmittedCount = 0;
        for (const p of photos) {
          const slot = String(p.slot_id || '').trim();
          const qc = String(p.qc_status || '').trim().toLowerCase();
          const photoId = typeof p.photo_id === 'string' ? p.photo_id.trim() : '';
          if (slot && qc) photoQcParts.push(`${slot}:${qc}`);
          if (!slot || !photoId) continue;
          photosSubmittedCount += 1;
          const entry = { slot_id: slot, photo_id: photoId, qc_status: qc || 'unknown' };
          if (qc === 'passed' || qc === 'pass' || qc === 'ok') passedPhotos.push(entry);
          else if (qc === 'degraded' || qc === 'warn' || qc === 'warning' || qc === 'low' || !qc) degradedPhotos.push(entry);
          else if (qc === 'fail' || qc === 'failed' || qc === 'reject' || qc === 'rejected' || qc === 'bad') failedPhotos.push(entry);
          else degradedPhotos.push(entry);
        }
        const photosProvided = photosSubmittedCount > 0;
        let photoQuality = classifyPhotoQuality(photos);

        let profileSummary = summarizeProfileForContext(profile);
        const recentLogsSummary = Array.isArray(recentLogs) ? recentLogs.slice(0, 7) : [];
        const routineFromRequest = parsed.data.currentRoutine;

        if (routineFromRequest !== undefined) {
          // Best-effort persistence. Analysis should still proceed even if storage is unavailable.
          profile = { ...(profile || {}), currentRoutine: routineFromRequest };
          if (persistLastAnalysis) {
            try {
              profile = await upsertProfileForIdentity(
                { auroraUid: identity.auroraUid, userId: identity.userId },
                { currentRoutine: routineFromRequest },
              );
            } catch (err) {
              logger?.warn({ err: err.code || err.message }, 'aurora bff: failed to persist current routine for analysis');
            }
          }
          profileSummary = summarizeProfileForContext(profile);
        }

        const routineCandidate = routineFromRequest !== undefined ? routineFromRequest : profileSummary && profileSummary.currentRoutine;
        const hasRoutine = Boolean(
          routineCandidate != null &&
            (typeof routineCandidate === 'string'
              ? String(routineCandidate).trim().length > 0
              : Array.isArray(routineCandidate)
                ? routineCandidate.length > 0
                : typeof routineCandidate === 'object'
                  ? Object.keys(routineCandidate).length > 0
                  : false),
        );
        profiler.end('quality', { kind: 'memory', has_routine: hasRoutine, logs_n: recentLogsSummary.length });

        // "Dual input" policy: photos optional, routine strongly recommended.
        // Treat missing routine as low-confidence and fall back to a baseline when no other primary signals exist.
        const hasPrimaryInput = hasRoutine || recentLogsSummary.length > 0;

        const userRequestedPhoto =
          parsed.data.use_photo === true || (parsed.data.use_photo == null && photosProvided);
        const forceVisionCall = Boolean(SKIN_VISION_FORCE_CALL && userRequestedPhoto && photosProvided && hasPrimaryInput);
        const detectorConfidence = inferDetectorConfidence({ profileSummary, recentLogsSummary, routineCandidate });
        const selectedVisionProvider = resolveVisionProviderSelection();
        const visionAvailability = classifyVisionAvailability({
          enabled: SKIN_VISION_ENABLED,
          apiKeyConfigured: selectedVisionProvider.apiKeyConfigured,
        });
        const visionAvailable = visionAvailability.available && !rollout.llmKillSwitch;
        const reportAvailable = Boolean(AURORA_DECISION_BASE_URL) && !USE_AURORA_BFF_MOCK && !rollout.llmKillSwitch;

        const analysisFieldMissing = [];
        const qualityReportReasons = [];
        const photoFailureCodes = [];
        let usedPhotos = false;
        let analysisSource = 'rule_based';
        let visionRuntime = null;
        let visionDecisionForReport = null;

	        let diagnosisPhoto = null;
	        let diagnosisPhotoBytes = null;
	        let shadowVerifyPhotoBytes = null;
        let diagnosisV1 = null;
        let diagnosisV1Internal = null;
        let diagnosisPolicy = null;
        function recordPhotoFailure(code, detail) {
          const failureCode = String(code || '').trim().toUpperCase() || 'DOWNLOAD_URL_GENERATE_FAILED';
          if (!photoFailureCodes.includes(failureCode)) photoFailureCodes.push(failureCode);
          analysisFieldMissing.push({ field: 'analysis.used_photos', reason: failureCode });
          if (detail) {
            logger?.warn({ code: failureCode, detail }, 'aurora bff: photo fetch failure');
          }
        }

        if (rollout.llmKillSwitch) {
          if (ctx.lang === 'CN') qualityReportReasons.push(' LLM ');
          else qualityReportReasons.push('LLM kill switch is enabled: skipping all model calls for this request.');
        }

        function mergePhotoQuality(baseQuality, extraQuality, { extraPrefix } = {}) {
          const base = baseQuality && typeof baseQuality === 'object' ? baseQuality : { grade: 'unknown', reasons: [] };
          const extra = extraQuality && typeof extraQuality === 'object' ? extraQuality : null;
          if (!extra) return base;
          const order = { unknown: 0, pass: 1, degraded: 2, fail: 3 };
          const g0 = String(base.grade || 'unknown').trim().toLowerCase();
          const g1 = String(extra.grade || 'unknown').trim().toLowerCase();
          const grade0 = order[g0] != null ? g0 : 'unknown';
          const grade1 = order[g1] != null ? g1 : 'unknown';
          const mergedGrade = order[grade1] > order[grade0] ? grade1 : grade0;
          const r0 = Array.isArray(base.reasons) ? base.reasons : [];
          const r1raw = Array.isArray(extra.reasons) ? extra.reasons : [];
          const r1 = extraPrefix ? r1raw.map((r) => `${extraPrefix}${r}`) : r1raw;
          const mergedReasons = Array.from(new Set([...r0, ...r1])).slice(0, 10);
          return { grade: mergedGrade, reasons: mergedReasons };
        }

        if (userRequestedPhoto && photosProvided && hasPrimaryInput && photoQuality.grade !== 'fail') {
          const candidates = photoQuality.grade === 'pass' ? passedPhotos : degradedPhotos.length ? degradedPhotos : passedPhotos;
          diagnosisPhoto = chooseVisionPhoto(candidates);
          if (!diagnosisPhoto) {
            analysisFieldMissing.push({ field: 'analysis.used_photos', reason: 'no_usable_photo' });
            if (ctx.lang === 'CN') qualityReportReasons.push(' photo_id ');
            else qualityReportReasons.push('No usable photo (missing photo_id or failed quality gate); skipping photo checks.');
          } else {
            try {
              profiler.start('decode', { kind: 'photo_fetch', slot: diagnosisPhoto.slot_id, purpose: 'diagnosis_v1' });
              const resp = await fetchPhotoBytesFromPivotaBackend({ req, photoId: diagnosisPhoto.photo_id });
              if (resp && resp.ok) {
                diagnosisPhotoBytes = resp.buffer;
                shadowVerifyPhotoBytes = diagnosisPhotoBytes;
              } else {
                recordPhotoFailure(resp && (resp.failure_code || resp.reason), resp && resp.detail);
              }
              profiler.end('decode', {
                kind: 'photo_fetch',
                slot: diagnosisPhoto.slot_id,
                purpose: 'diagnosis_v1',
                ok: Boolean(diagnosisPhotoBytes),
                bytes: diagnosisPhotoBytes ? diagnosisPhotoBytes.length : 0,
              });
            } catch (err) {
              recordPhotoFailure('DOWNLOAD_URL_FETCH_5XX', err && err.message ? err.message : null);
              profiler.fail('decode', err, { kind: 'photo_fetch', slot: diagnosisPhoto.slot_id, purpose: 'diagnosis_v1' });
              logger?.warn({ err: err.message }, 'aurora bff: failed to fetch photo bytes for diagnosis');
            }

	            if (diagnosisPhotoBytes) {
	              const diag = await runSkinDiagnosisV1({
	                imageBuffer: diagnosisPhotoBytes,
	                language: ctx.lang,
	                profileSummary,
	                recentLogsSummary,
	                profiler,
                  qualityGateConfig,
                  severityThresholdsOverrides,
	              });
	              if (diag && diag.ok && diag.diagnosis) {
	                diagnosisV1 = diag.diagnosis;
	                diagnosisV1Internal = diag.internal || null;
	                diagnosisPolicy = summarizeDiagnosisForPolicy(diagnosisV1);
	                usedPhotos = true;
	                shadowVerifyPhotoBytes = diagnosisPhotoBytes;
	                const dq = diagnosisV1 && diagnosisV1.quality && typeof diagnosisV1.quality === 'object' ? diagnosisV1.quality : null;
	                if (dq && typeof dq.grade === 'string') photoQuality = mergePhotoQuality(photoQuality, dq, { extraPrefix: 'pixel_' });
                if (dq && dq.grade === 'fail') {
                  if (ctx.lang === 'CN') qualityReportReasons.push('///');
                  else
                    qualityReportReasons.push(
                      'Pixel-level photo quality did not pass (blur/lighting/WB/coverage); recommending a retake to avoid wrong guesses.',
                    );
                } else if (dq && dq.grade === 'degraded') {
                  if (ctx.lang === 'CN') qualityReportReasons.push('/');
                  else qualityReportReasons.push('Photo quality is degraded: keeping conclusions conservative and reducing unnecessary model calls.');
                }
              } else if (diag && !diag.ok) {
                const reason = String(diag.reason || 'diagnosis_failed');
                photoQuality = mergePhotoQuality(photoQuality, { grade: 'fail', reasons: [reason] }, { extraPrefix: 'pixel_' });
                if (ctx.lang === 'CN') qualityReportReasons.push(`${reason}`);
                else qualityReportReasons.push(`Photo checks could not complete reliably (${reason}); recommending a retake to avoid wrong guesses.`);
                if (!analysisFieldMissing.some((f) => f && f.field === 'analysis.used_photos' && f.reason === 'diagnosis_failed')) {
                  analysisFieldMissing.push({ field: 'analysis.used_photos', reason: 'diagnosis_failed' });
                }
              }
            }
          }
        }

        const qualityForReport = userRequestedPhoto && photosProvided ? photoQuality : { grade: 'pass', reasons: ['no_photo'] };
        const policyDetectorConfidenceLevel = diagnosisPolicy ? diagnosisPolicy.detector_confidence_level : detectorConfidence.level;
        const policyUncertainty = diagnosisPolicy ? diagnosisPolicy.uncertainty : null;

        const visionDecision = rollout.llmKillSwitch
          ? { decision: 'skip', reasons: ['llm_kill_switch'], downgrade_confidence: true }
          : forceVisionCall
            ? { decision: 'call', reasons: ['force_vision_call'], downgrade_confidence: true }
            : shouldCallLlm({
                kind: 'vision',
                quality: photoQuality,
                hasPrimaryInput,
                userRequestedPhoto,
                detectorConfidenceLevel: policyDetectorConfidenceLevel,
                uncertainty: policyUncertainty,
                visionAvailable,
                visionUnavailabilityReason: visionAvailability.reason,
                reportAvailable,
                degradedMode: SKIN_DEGRADED_MODE,
              });
        const reportDecision = rollout.llmKillSwitch
          ? { decision: 'skip', reasons: ['llm_kill_switch'], downgrade_confidence: true }
          : shouldCallLlm({
              kind: 'report',
              quality: qualityForReport,
              hasPrimaryInput,
              userRequestedPhoto,
              detectorConfidenceLevel: policyDetectorConfidenceLevel,
              uncertainty: policyUncertainty,
              visionAvailable,
              reportAvailable,
              degradedMode: SKIN_DEGRADED_MODE,
            });

        let analysis = null;
        if (userRequestedPhoto && photosProvided && !hasPrimaryInput) {
          analysisFieldMissing.push({ field: 'analysis.used_photos', reason: 'routine_or_recent_logs_required' });
          if (ctx.lang === 'CN') qualityReportReasons.push('/');
          else qualityReportReasons.push('You provided a photo, but Im missing routine/recent logs; returning a low-risk baseline first.');
        }

        if (userRequestedPhoto && photosProvided && photoQuality.grade === 'fail' && !forceVisionCall) {
          analysis = profiler.timeSync('detector', () => buildRetakeSkinAnalysis({ language: ctx.lang, photoQuality }), {
            kind: 'retake',
          });
          analysisSource = 'retake';
          if (ctx.lang === 'CN') qualityReportReasons.push(' AI ');
          else qualityReportReasons.push('Photo quality failed: skipping all AI analysis to avoid guessy results; please retake.');
        } else if (userRequestedPhoto && photosProvided && photoQuality.grade === 'fail' && forceVisionCall) {
          if (ctx.lang === 'CN') qualityReportReasons.push('');
          else qualityReportReasons.push('Force-vision debug enabled: attempting photo model call despite fail-grade quality.');
        }

        if (!analysis && visionDecision.decision === 'call') {
          const candidates = photoQuality.grade === 'pass'
            ? passedPhotos
            : degradedPhotos.length
              ? degradedPhotos
              : forceVisionCall
                ? [...passedPhotos, ...degradedPhotos, ...failedPhotos]
                : passedPhotos;
          const chosen = chooseVisionPhoto(candidates);
          if (!chosen) {
            analysisFieldMissing.push({ field: 'photos', reason: photosProvided ? 'no_usable_photo' : 'no_photo_uploaded' });
            if (ctx.lang === 'CN') qualityReportReasons.push(' photo_id ');
            else qualityReportReasons.push('No usable photo (missing photo_id or failed quality gate); skipping photo analysis.');
          } else {
            let photoBytes = null;
            if (diagnosisPhotoBytes && diagnosisPhoto && diagnosisPhoto.photo_id === chosen.photo_id) {
              photoBytes = diagnosisPhotoBytes;
            } else {
              try {
                profiler.start('decode', { kind: 'photo_fetch', slot: chosen.slot_id, purpose: 'vision' });
                const resp = await fetchPhotoBytesFromPivotaBackend({ req, photoId: chosen.photo_id });
                if (resp && resp.ok) photoBytes = resp.buffer;
                else {
                  recordPhotoFailure(resp && (resp.failure_code || resp.reason), resp && resp.detail);
                }
                profiler.end('decode', {
                  kind: 'photo_fetch',
                  slot: chosen.slot_id,
                  purpose: 'vision',
                  ok: Boolean(photoBytes),
                  bytes: photoBytes ? photoBytes.length : 0,
                });
              } catch (err) {
                recordPhotoFailure('DOWNLOAD_URL_FETCH_5XX', err && err.message ? err.message : null);
                profiler.fail('decode', err, { kind: 'photo_fetch', slot: chosen.slot_id, purpose: 'vision' });
                logger?.warn({ err: err.message }, 'aurora bff: failed to fetch photo bytes');
              }
            }

            if (photoBytes) {
              const vision = await runVisionSkinAnalysis({
                provider: selectedVisionProvider.provider,
                imageBuffer: photoBytes,
                language: ctx.lang,
                photoQuality,
                llmKillSwitch: rollout.llmKillSwitch,
                diagnosisPolicy,
                diagnosisV1,
                profileSummary,
                recentLogsSummary,
                profiler,
                promptVersion,
              });
              visionRuntime = vision;
              if (vision && vision.ok && vision.analysis) {
                analysis = vision.analysis;
                usedPhotos = true;
                shadowVerifyPhotoBytes = photoBytes;
                const openAiFallback = vision.provider === 'openai' && String(vision.fallback_from || '').trim().toLowerCase() === 'gemini';
                analysisSource = vision.provider === 'gemini'
                  ? 'vision_gemini'
                  : openAiFallback
                    ? 'vision_openai_fallback'
                    : 'vision_openai';
                logger?.info(
                  {
                    kind: 'metric',
                    name: 'aurora.skin.analysis.provider_success.count',
                    value: 1,
                    provider: vision.provider || selectedVisionProvider.provider || 'unknown',
                    analysis_source: analysisSource,
                  },
                  'metric',
                );
                if (openAiFallback) {
                  if (ctx.lang === 'CN') qualityReportReasons.push('Gemini  OpenAI ');
                  else qualityReportReasons.push('Gemini vision result was unavailable, so this run fell back to OpenAI vision.');
                  logger?.info({ kind: 'metric', name: 'aurora.skin_analysis.vision_openai_fallback.count', value: 1 }, 'metric');
                  logger?.info(
                    {
                      kind: 'metric',
                      name: 'aurora.skin.analysis.provider_fallback.count',
                      value: 1,
                      from: 'gemini',
                      to: 'openai',
                    },
                    'metric',
                  );
                }
              } else if (vision && !vision.ok) {
                const normalizedReason = normalizeVisionReason(vision.reason);
                const fallbackFrom = String(vision.fallback_from || '').trim().toLowerCase();
                analysisFieldMissing.push({
                  field: 'analysis.used_photos',
                  reason: normalizedReason || 'VISION_UNKNOWN',
                });
                if (ctx.lang === 'CN') qualityReportReasons.push(`${normalizedReason || 'VISION_UNKNOWN'}`);
                else qualityReportReasons.push(`Photo analysis failed (${normalizedReason || 'VISION_UNKNOWN'}); falling back to deterministic baseline.`);
                logger?.info(
                  {
                    kind: 'metric',
                    name: 'aurora.skin.analysis.provider_failure.count',
                    value: 1,
                    provider: vision.provider || selectedVisionProvider.provider || 'unknown',
                    reason: normalizedReason || 'VISION_UNKNOWN',
                    fallback_from: fallbackFrom || null,
                  },
                  'metric',
                );
                if (fallbackFrom === 'gemini' && String(vision.provider || '').trim().toLowerCase() === 'openai') {
                  logger?.info(
                    {
                      kind: 'metric',
                      name: 'aurora.skin.analysis.provider_fallback_failure.count',
                      value: 1,
                      from: 'gemini',
                      to: 'openai',
                      reason: normalizedReason || 'VISION_UNKNOWN',
                    },
                    'metric',
                  );
                }
                logger?.warn(
                  {
                    reason: normalizedReason || 'VISION_UNKNOWN',
                    provider: vision.provider || selectedVisionProvider.provider || 'unknown',
                    upstream_status_code: toNullableInt(vision.upstream_status_code),
                    error_code: vision.error || null,
                  },
                  'aurora bff: vision skin analysis failed',
                );
              }
            }
          }
        } else if (!analysis && visionDecision.decision === 'skip' && userRequestedPhoto && photosProvided) {
          const r = humanizeLlmReasons(visionDecision.reasons, { language: ctx.lang });
          if (ctx.lang === 'CN') qualityReportReasons.push(`${r.join('') || ''}`);
          else qualityReportReasons.push(`Skipped photo analysis: ${r.join('; ') || 'unknown reason'}`);
        }

        if (!analysis && reportDecision.decision === 'call' && hasPrimaryInput && AURORA_DECISION_BASE_URL && !USE_AURORA_BFF_MOCK) {
          const promptBase = buildSkinReportPrompt({
            language: ctx.lang,
            photoQuality: qualityForReport,
            diagnosisPolicy,
            diagnosisV1,
            profileSummary,
            routineCandidate: hasRoutine ? routineCandidate : null,
            recentLogsSummary,
            promptVersion,
          });

          let reportFailure = null;
          for (let attempt = 0; attempt < 2; attempt += 1) {
            const prompt =
              attempt === 0
                ? promptBase
                : `${promptBase}\nSELF-CHECK before responding: output MUST be strict JSON only (no markdown/text), exactly the specified keys, and strategy must end with a single direct question.\n`;

            let upstream = null;
            try {
              upstream = await profiler.timeLlmCall({ provider: 'aurora', model: null, kind: 'skin_text' }, async () =>
                auroraChat({ baseUrl: AURORA_DECISION_BASE_URL, query: prompt, timeoutMs: 12000 }),
              );
            } catch (err) {
              logger?.warn({ err: err.message }, 'aurora bff: skin analysis upstream failed');
              reportFailure = 'report_upstream_failed';
              break;
            }

            const answer = upstream && typeof upstream.answer === 'string' ? upstream.answer : '';
            const jsonOnly = unwrapCodeFence(answer);
            const parsedObj = parseJsonOnlyObject(jsonOnly);
            analysis = normalizeSkinAnalysisFromLLM(parsedObj, { language: ctx.lang });
            if (analysis) {
              analysisSource = 'aurora_text';
              break;
            }
            reportFailure = 'report_output_invalid';
          }
          if (!analysis && reportFailure) {
            if (ctx.lang === 'CN') qualityReportReasons.push(`${reportFailure}`);
            else qualityReportReasons.push(`Report model output was unstable (${reportFailure}); falling back to deterministic baseline.`);
          }
        }
        if (!analysis && reportDecision.decision === 'skip' && reportAvailable && hasPrimaryInput) {
          const r = humanizeLlmReasons(reportDecision.reasons, { language: ctx.lang });
          if (ctx.lang === 'CN') qualityReportReasons.push(`${r.join('') || ''}`);
          else qualityReportReasons.push(`Skipped report model: ${r.join('; ') || 'unknown reason'}`);
        }

        if (!analysis) {
          if (!hasPrimaryInput) {
            analysis = profiler.timeSync(
              'detector',
              () => buildLowConfidenceBaselineSkinAnalysis({ profile: profileSummary || profile, language: ctx.lang }),
              { kind: 'baseline_low_confidence' },
            );
            analysisSource = 'baseline_low_confidence';
          } else {
            if (userRequestedPhoto && photosProvided && diagnosisV1 && diagnosisV1.quality) {
              analysis = profiler.timeSync(
                'postprocess',
                () => buildSkinAnalysisFromDiagnosisV1(diagnosisV1, { language: ctx.lang, profileSummary }),
                { kind: 'diagnosis_v1_template' },
              );
              if (analysis) analysisSource = 'diagnosis_v1_template';
            }
            if (!analysis) {
              analysis = profiler.timeSync(
                'detector',
                () => buildRuleBasedSkinAnalysis({ profile: profileSummary || profile, recentLogs, language: ctx.lang }),
                { kind: 'rule_based' },
              );
            }
          }
        }

        const baseVisionReasons = Array.isArray(visionDecision.reasons) ? visionDecision.reasons.filter(Boolean) : [];
        const firstVisionFailureReason = pickPrimaryVisionReason(baseVisionReasons);
        const unavailabilityOnSkip = Boolean(visionDecision.decision === 'skip' && firstVisionFailureReason);
        const visionRetryDefault = {
          attempted: 0,
          final: 'fail',
          last_reason: firstVisionFailureReason || null,
        };
        visionDecisionForReport = {
          ...visionDecision,
          reasons: baseVisionReasons,
          provider: selectedVisionProvider.provider || 'gemini',
          upstream_status_code: null,
          latency_ms: null,
          retry: visionRetryDefault,
        };

        if (visionRuntime && visionRuntime.ok) {
          visionDecisionForReport = {
            ...visionDecisionForReport,
            decision: 'call',
            reasons: ['quality_pass'],
            provider: visionRuntime.provider || visionDecisionForReport.provider,
            retry: visionRuntime.retry || { attempted: 0, final: 'success', last_reason: null },
            upstream_status_code: null,
            latency_ms: toNullableNumber(visionRuntime.latency_ms),
          };
        } else if (visionRuntime && !visionRuntime.ok) {
          const runtimeReason = normalizeVisionReason(visionRuntime.reason);
          const runtimeReasons = [runtimeReason];
          if (usedPhotos) runtimeReasons.push(VisionUnavailabilityReason.VISION_CV_FALLBACK_USED);
          visionDecisionForReport = {
            ...visionDecisionForReport,
            decision: 'fallback',
            reasons: Array.from(new Set(runtimeReasons)),
            provider: visionRuntime.provider || visionDecisionForReport.provider,
            retry: visionRuntime.retry || { attempted: 0, final: 'fail', last_reason: runtimeReason },
            upstream_status_code: toNullableInt(visionRuntime.upstream_status_code),
            latency_ms: toNullableNumber(visionRuntime.latency_ms),
          };
        } else if (visionDecision.decision === 'call' && photoFailureCodes.length) {
          const reasons = [VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED];
          if (usedPhotos) reasons.push(VisionUnavailabilityReason.VISION_CV_FALLBACK_USED);
          visionDecisionForReport = {
            ...visionDecisionForReport,
            decision: 'fallback',
            reasons,
            retry: { attempted: 0, final: 'fail', last_reason: VisionUnavailabilityReason.VISION_IMAGE_FETCH_FAILED },
          };
        } else if (unavailabilityOnSkip && userRequestedPhoto && photosProvided && usedPhotos) {
          visionDecisionForReport = {
            ...visionDecisionForReport,
            decision: 'fallback',
            reasons: Array.from(new Set([...baseVisionReasons, VisionUnavailabilityReason.VISION_CV_FALLBACK_USED])),
          };
        }

        const visionNoticeReason = pickPrimaryVisionReason(visionDecisionForReport.reasons);
        const visionPhotoNoticeMessage = buildVisionPhotoNotice({
          reason: visionNoticeReason,
          language: ctx.lang,
        });

        recordVisionDecision({
          provider: visionDecisionForReport.provider || 'gemini',
          decision: visionDecisionForReport.decision,
          reasons: visionDecisionForReport.reasons,
          latencyMs: visionDecisionForReport.latency_ms,
        });

        const mustDowngrade =
          userRequestedPhoto &&
          photosProvided &&
          (photoQuality.grade === 'degraded' || photoQuality.grade === 'unknown') &&
          analysisSource !== 'retake';
        if (analysis && mustDowngrade) analysis = downgradeSkinAnalysisConfidence(analysis, { language: ctx.lang });
        if (analysis && diagnosisV1 && usedPhotos) {
          analysis = mergePhotoFindingsIntoAnalysis({
            analysis,
            diagnosisV1,
            language: ctx.lang,
            profileSummary,
          });
        }
        const photoNotUsed = Boolean(userRequestedPhoto && photosProvided && !usedPhotos);
        const photoFailureCode = photoFailureCodes[0] || null;
        let geometrySanitizer = null;
        let photoNotice = null;
        if (photoNotUsed && photoFailureCode) {
          photoNotice = {
            failure_code: photoFailureCode,
            message:
              ctx.lang === 'CN'
                ? `${photoFailureCode}/`
                : `We couldn't analyze your photo this time (reason: ${photoFailureCode}). Results below are based on your answers/history only. Please re-upload and retry.`,
          };
        }
        if (analysis) {
          analysis = buildExecutablePlanForAnalysis({
            analysis,
            language: ctx.lang,
            usedPhotos,
            photoQuality,
            profileSummary,
            photoNoticeOverride:
              photoNotice && typeof photoNotice.message === 'string' && photoNotice.message.trim()
                ? photoNotice.message
                : visionPhotoNoticeMessage,
            photoFailureCode,
            photosProvided,
          });
          geometrySanitizer =
            analysis && analysis.__geometry_sanitizer && typeof analysis.__geometry_sanitizer === 'object'
              ? analysis.__geometry_sanitizer
              : null;
          if (analysis && Object.prototype.hasOwnProperty.call(analysis, '__geometry_sanitizer')) {
            delete analysis.__geometry_sanitizer;
          }
        }

        let renderedAnalysisSource = analysisSource;
        if (photoNotUsed && analysisSource !== 'retake') {
          renderedAnalysisSource = 'rule_based_with_photo_qc';
        }
        const qualityGradeForMetrics = normalizeQualityGradeForMetrics(photoQuality && photoQuality.grade);
        const pipelineVersionForMetrics = normalizePipelineVersionForMetrics(pipelineVersion || 'unknown');
        const deviceClassForMetrics = inferDeviceClassForMetrics(req);
        const sanitizerTotals = geometrySanitizer || { checked_n: 0, dropped_n: 0, clipped_n: 0 };
        recordAnalyzeRequest({
          issueType: 'all',
          qualityGrade: qualityGradeForMetrics,
          pipelineVersion: pipelineVersionForMetrics,
          deviceClass: deviceClassForMetrics,
        });
        recordGeometrySanitizerTotals({
          issueType: 'all',
          qualityGrade: qualityGradeForMetrics,
          pipelineVersion: pipelineVersionForMetrics,
          deviceClass: deviceClassForMetrics,
          dropped: sanitizerTotals.dropped_n,
          clipped: sanitizerTotals.clipped_n,
        });
        const sanitizerByIssue =
          geometrySanitizer && geometrySanitizer.by_issue && typeof geometrySanitizer.by_issue === 'object'
            ? geometrySanitizer.by_issue
            : {};
        for (const [issueType, issueStatsRaw] of Object.entries(sanitizerByIssue)) {
          const issueStats = issueStatsRaw && typeof issueStatsRaw === 'object' ? issueStatsRaw : {};
          const checkedN = Number(issueStats.checked_n || 0);
          if (checkedN <= 0) continue;
          recordAnalyzeRequest({
            issueType,
            qualityGrade: qualityGradeForMetrics,
            pipelineVersion: pipelineVersionForMetrics,
            deviceClass: deviceClassForMetrics,
          });
          recordGeometrySanitizerTotals({
            issueType,
            qualityGrade: qualityGradeForMetrics,
            pipelineVersion: pipelineVersionForMetrics,
            deviceClass: deviceClassForMetrics,
            dropped: issueStats.dropped_n,
            clipped: issueStats.clipped_n,
          });
        }

        const photoModulesSkinMask = await maybeInferSkinMaskForPhotoModules({
          imageBuffer: diagnosisPhotoBytes,
          diagnosisInternal: diagnosisV1Internal,
          logger,
          requestId: ctx.request_id,
        });

        const photoModulesCard = maybeBuildPhotoModulesCardForAnalysis({
          requestId: ctx.request_id,
          analysis,
          usedPhotos,
          photoQuality,
          photoNotice:
            photoNotice && typeof photoNotice.message === 'string' && photoNotice.message.trim()
              ? photoNotice.message
              : visionPhotoNoticeMessage,
          diagnosisInternal: diagnosisV1Internal,
          profileSummary,
          language: ctx.lang,
          skinMask: photoModulesSkinMask,
        });

        if (analysis && persistLastAnalysis) {
          try {
            await saveLastAnalysisForIdentity(
              { auroraUid: identity.auroraUid, userId: identity.userId },
              { analysis, lang: ctx.lang },
            );
          } catch (err) {
            logger?.warn({ err: err && err.message ? err.message : String(err) }, 'aurora bff: failed to persist last analysis');
          }
        }

        let diagnosisArtifact = null;
        let ingredientPlan = null;
        let recommendationReady = false;
        let latestArtifactId = null;
        if (analysis && AURORA_DIAG_ARTIFACT_ENABLED && persistLastAnalysis) {
          try {
            const artifactCandidate = buildDiagnosisArtifactV1({
              ctx,
              identity,
              profileSummary,
              recentLogsSummary,
              analysis,
              analysisSource: renderedAnalysisSource,
              usePhoto: Boolean(userRequestedPhoto),
              usedPhotos,
              photos,
              photoQuality,
            });
            const savedArtifact = await saveDiagnosisArtifact({
              auroraUid: identity.auroraUid,
              userId: identity.userId,
              sessionId: ctx.brief_id || null,
              artifact: artifactCandidate,
              artifactId: artifactCandidate && artifactCandidate.artifact_id ? artifactCandidate.artifact_id : undefined,
            });
            diagnosisArtifact = savedArtifact && savedArtifact.artifact_json && typeof savedArtifact.artifact_json === 'object'
              ? {
                  ...savedArtifact.artifact_json,
                  artifact_id: savedArtifact.artifact_id,
                  created_at: savedArtifact.created_at || savedArtifact.artifact_json.created_at,
                }
              : artifactCandidate;
            logger?.info({ kind: 'metric', name: 'aurora.skin.artifact_created_rate', value: diagnosisArtifact ? 1 : 0 }, 'metric');
            recordAuroraSkinFlowMetric({ stage: 'artifact_created', hit: Boolean(diagnosisArtifact) });
            latestArtifactId = diagnosisArtifact && diagnosisArtifact.artifact_id
              ? String(diagnosisArtifact.artifact_id).trim()
              : null;

            if (diagnosisArtifact && AURORA_INGREDIENT_PLAN_ENABLED && latestArtifactId) {
              const planBuilt = buildIngredientPlan({
                artifact: diagnosisArtifact,
                profile: profileSummary || profile || {},
              });
              const savedPlan = await saveIngredientPlan({
                artifactId: latestArtifactId,
                auroraUid: identity.auroraUid,
                userId: identity.userId,
                plan: planBuilt,
              });
              ingredientPlan = savedPlan && savedPlan.plan_json && typeof savedPlan.plan_json === 'object'
                ? {
                    ...savedPlan.plan_json,
                    plan_id: savedPlan.plan_id,
                    created_at: savedPlan.created_at || savedPlan.plan_json.created_at,
                  }
                : planBuilt;
              logger?.info({ kind: 'metric', name: 'aurora.skin.ingredient_plan_rate', value: ingredientPlan ? 1 : 0 }, 'metric');
              recordAuroraSkinFlowMetric({ stage: 'ingredient_plan', hit: Boolean(ingredientPlan) });
            }

            const artifactGate = hasUsableArtifactForRecommendations(diagnosisArtifact);
            recommendationReady = Boolean(artifactGate && artifactGate.ok && artifactGate.confidence_level !== 'low');
          } catch (err) {
            logger?.warn(
              { err: err && err.message ? err.message : String(err), request_id: ctx.request_id },
              'aurora bff: diagnosis artifact/plan generation failed',
            );
          }
        }

        profiler.start('render', { kind: 'envelope' });
        const analysisSummaryPayload = {
          analysis,
          low_confidence: analysisSource === 'baseline_low_confidence',
          photos_provided: photosProvided,
          photo_qc: photoQcParts,
          used_photos: usedPhotos,
          analysis_source: renderedAnalysisSource,
          ...(photoNotice ? { photo_notice: photoNotice } : {}),
          quality_report: {
            photo_quality: { grade: photoQuality.grade, reasons: photoQuality.reasons },
            detector_confidence: detectorConfidence,
            ...(diagnosisPolicy ? { detector_policy: diagnosisPolicy } : {}),
            degraded_mode: SKIN_DEGRADED_MODE,
            llm: { vision: visionDecisionForReport || visionDecision, report: reportDecision },
            reasons: qualityReportReasons.slice(0, 8),
          },
          ...(diagnosisArtifact ? { diagnosis_artifact: diagnosisArtifact } : {}),
          ...(ingredientPlan ? { ingredient_plan: ingredientPlan } : {}),
          recommendation_ready: Boolean(recommendationReady),
          photo_pipeline_enabled: AURORA_AURORAAPP_PHOTO_PIPELINE_ENABLED,
        };

        const sessionPatch = { next_state: 'S5_ANALYSIS_SUMMARY' };
        appendLatestArtifactToSessionPatch(sessionPatch, latestArtifactId);

        const extraCards = [];
        if (ingredientPlan) {
          extraCards.push(buildIngredientPlanCard(ingredientPlan, ctx.request_id));
        }
        const artifactConfidence = diagnosisArtifact && diagnosisArtifact.overall_confidence && typeof diagnosisArtifact.overall_confidence === 'object'
          ? diagnosisArtifact.overall_confidence
          : null;
        if (artifactConfidence && String(artifactConfidence.level || '').toLowerCase() === 'low') {
          logger?.info({ kind: 'metric', name: 'aurora.skin.low_confidence_rate', value: 1 }, 'metric');
          extraCards.push({
            card_id: `conf_${ctx.request_id}`,
            type: 'confidence_notice',
            payload: buildConfidenceNoticeCardPayload({
              language: ctx.lang,
              reason: 'low_confidence',
              confidence: artifactConfidence,
              actions: ['upload_daylight_and_indoor_white', 'update_current_routine'],
            }),
          });
        }

        const envelope = buildEnvelope(ctx, {
          assistant_message: null,
          suggested_chips: [],
          cards: [
            {
              card_id: `analysis_${ctx.request_id}`,
              type: 'analysis_summary',
              payload: analysisSummaryPayload,
              ...(analysisFieldMissing.length ? { field_missing: analysisFieldMissing } : {}),
            },
            ...(photoModulesCard ? [photoModulesCard] : []),
            ...extraCards,
          ],
          session_patch: sessionPatch,
          events: [
            makeEvent(ctx, 'value_moment', { kind: 'skin_analysis', used_photos: usedPhotos, analysis_source: renderedAnalysisSource }),
          ],
        });
        profiler.end('render', { kind: 'envelope' });

        const report = profiler.report();
        logger?.info(
          {
            kind: shadowRun ? 'skin_analysis_profile_shadow' : 'skin_analysis_profile',
            request_id: ctx.request_id,
            trace_id: ctx.trace_id,
            pipeline_version: pipelineVersion || null,
            shadow_run: Boolean(shadowRun),
            experiments: experimentsSlim,
            analysis_source: renderedAnalysisSource,
            user_requested_photo: Boolean(userRequestedPhoto),
            photos_provided: Boolean(photosProvided),
            used_photos: Boolean(usedPhotos),
            photo_quality_grade: photoQuality && typeof photoQuality.grade === 'string' ? photoQuality.grade : 'unknown',
            total_ms: report.total_ms,
            llm_summary: report.llm_summary,
            stages: report.stages,
          },
          'aurora bff: skin analysis profile',
        );
        logger?.info(
          { kind: 'metric', name: `aurora.skin_analysis.${pipelineVersion || 'unknown'}.total_ms`, value: report.total_ms },
          'metric',
        );
	        if (!shadowRun) {
	          logger?.info({ kind: 'metric', name: 'aurora.skin_analysis.total_ms', value: report.total_ms }, 'metric');
	        }

        if (experimentsSlim.length) {
          const llmCalls = report && report.llm_summary && typeof report.llm_summary.calls === 'number' ? report.llm_summary.calls : 0;
          const qualityGrade = photoQuality && typeof photoQuality.grade === 'string' ? photoQuality.grade : 'unknown';
          const pv = pipelineVersion || 'unknown';

          for (const exp of experimentsSlim) {
            const expId = exp && typeof exp.experiment_id === 'string' ? exp.experiment_id : null;
            const variant = exp && typeof exp.variant === 'string' ? exp.variant : null;
            if (!expId || !variant) continue;

            logger?.info({ kind: 'metric', name: `aurora.skin_experiment.${expId}.${variant}.${pv}.requests`, value: 1 }, 'metric');
            logger?.info(
              { kind: 'metric', name: `aurora.skin_experiment.${expId}.${variant}.${pv}.total_ms`, value: report.total_ms },
              'metric',
            );
            logger?.info(
              { kind: 'metric', name: `aurora.skin_experiment.${expId}.${variant}.${pv}.llm_calls`, value: llmCalls },
              'metric',
            );
            logger?.info(
              { kind: 'metric', name: `aurora.skin_experiment.${expId}.${variant}.${pv}.quality_grade.${qualityGrade}`, value: 1 },
              'metric',
            );
          }
        }

	        setImmediate(() => {
	          sampleHardCase({
	            req,
	            ctx,
	            identity: { auroraUid: identity.auroraUid, userId: identity.userId },
	            pipelineVersion,
	            shadowRun,
	            profileSummary,
	            photoQuality,
	            diagnosisPolicy,
	            diagnosisV1,
	            analysis,
	            analysisSource,
	            geometrySanitizer,
	            diagnosisPhotoBytes,
	            diagnosisV1Internal,
	            logger,
	          }).catch((err) => {
	            logger?.warn({ err: err && err.message ? err.message : String(err) }, 'hard case sampler: failed');
	          });
	        });

	        if (!shadowRun) {
	          const verifyRuntimeLimits = (() => {
	            if (!DIAG_VERIFY_ALLOW_GUARD_TEST) return null;

	            const headerPerMin = Number(req.get('x-diag-verify-max-calls-per-min'));
	            const headerPerDay = Number(req.get('x-diag-verify-max-calls-per-day'));
	            const queryPerMin = Number(req.query && req.query.diag_verify_max_calls_per_min);
	            const queryPerDay = Number(req.query && req.query.diag_verify_max_calls_per_day);
	            const bodyLimits =
	              (isPlainObject(req.body) && isPlainObject(req.body.diag_verify_runtime_limits) && req.body.diag_verify_runtime_limits) ||
	              (isPlainObject(req.body) &&
	                isPlainObject(req.body.debug) &&
	                isPlainObject(req.body.debug.diag_verify_runtime_limits) &&
	                req.body.debug.diag_verify_runtime_limits) ||
	              null;
	            const bodyPerMin = Number(
	              bodyLimits &&
	                (bodyLimits.maxCallsPerMin != null ? bodyLimits.maxCallsPerMin : bodyLimits.max_calls_per_min),
	            );
	            const bodyPerDay = Number(
	              bodyLimits &&
	                (bodyLimits.maxCallsPerDay != null ? bodyLimits.maxCallsPerDay : bodyLimits.max_calls_per_day),
	            );

	            const pickFirstFinite = (...values) => {
	              for (const value of values) {
	                if (Number.isFinite(value) && value >= 0) return Math.trunc(value);
	              }
	              return null;
	            };

	            const maxCallsPerMin = pickFirstFinite(headerPerMin, bodyPerMin, queryPerMin);
	            const maxCallsPerDay = pickFirstFinite(headerPerDay, bodyPerDay, queryPerDay);
	            if (maxCallsPerMin == null && maxCallsPerDay == null) return null;
	            return {
	              ...(maxCallsPerMin != null ? { maxCallsPerMin } : {}),
	              ...(maxCallsPerDay != null ? { maxCallsPerDay } : {}),
	            };
	          })();
	          setImmediate(() => {
	            runGeminiShadowVerify({
	              imageBuffer: shadowVerifyPhotoBytes || diagnosisPhotoBytes || null,
	              language: ctx.lang,
	              photoQuality,
	              usedPhotos,
	              diagnosisV1,
	              diagnosisInternal: diagnosisV1Internal,
	              profileSummary,
	              recentLogsSummary,
	              inferenceId: ctx.request_id || ctx.trace_id || null,
	              traceId: ctx.trace_id || null,
	              assetId: diagnosisPhoto && typeof diagnosisPhoto.photo_id === 'string' ? diagnosisPhoto.photo_id : null,
	              runtimeLimits: verifyRuntimeLimits || undefined,
	              skinToneBucket:
	                diagnosisV1Internal && typeof diagnosisV1Internal.skin_tone_bucket === 'string'
	                  ? diagnosisV1Internal.skin_tone_bucket
	                  : 'unknown',
	              lightingBucket:
	                diagnosisV1Internal && typeof diagnosisV1Internal.lighting_bucket === 'string'
	                  ? diagnosisV1Internal.lighting_bucket
	                  : 'unknown',
	              logger,
	              metricsHooks: {
	                onProviderResult: (stat) =>
	                  recordEnsembleProviderResult({
	                    provider: stat.provider,
	                    ok: stat.ok,
	                    latencyMs: stat.latency_ms,
	                    failureReason: stat.failure_reason,
	                    schemaFailed: stat.schema_failed,
	                  }),
	                onAgreement: (score) => recordEnsembleAgreementScore(score),
	                onVerifyCall: ({ status }) => recordVerifyCall({ status }),
	                onVerifyFail: ({
	                  reason,
	                  provider,
	                  http_status_class: httpStatusClass,
	                  timeout_stage: timeoutStage,
	                  retry_count: retryCount,
	                  error_class: errorClass,
	                }) =>
	                  recordVerifyFail({
	                    reason,
	                    provider,
	                    httpStatusClass,
	                    timeoutStage,
	                    retryCount,
	                    errorClass,
	                  }),
	                onVerifyRetry: ({ attempts }) => recordVerifyRetry({ attempts }),
	                onVerifyBudgetGuard: () => recordVerifyBudgetGuard(),
	                onVerifyCircuitOpen: () => recordVerifyCircuitOpen(),
	                onVerifyAgreement: (score) => recordVerifyAgreementScore(score),
	                onVerifyHardCase: () => recordVerifyHardCase(),
	              },
		            })
		              .then((verify) => {
		                if (!verify || !verify.called) return;
		                logger?.info(
		                  {
		                    request_id: ctx.request_id,
		                    trace_id: ctx.trace_id,
		                    used_photos: usedPhotos,
		                    verify_ok: Boolean(verify.ok),
		                    verify_provider_status_code:
		                      Number.isFinite(Number(verify.provider_status_code)) ? Number(verify.provider_status_code) : null,
		                    verify_final_reason: verify.final_reason || null,
		                    verify_raw_final_reason: verify.raw_final_reason || null,
		                    verify_fail_reason: verify.verify_fail_reason || null,
		                    verify_timeout_stage: verify.timeout_stage || null,
		                    verify_upstream_request_id: verify.upstream_request_id || null,
		                    verify_attempts: Number.isFinite(Number(verify.attempts)) ? Number(verify.attempts) : null,
		                    verify_latency_ms: Number.isFinite(Number(verify.latency_ms)) ? Number(verify.latency_ms) : null,
		                    agreement_score: verify.agreement_score,
		                    disagreement_reasons: verify.disagreement_reasons,
		                    hard_case_written: Boolean(verify.hard_case_written),
		                  },
		                  'diag verify: shadow run recorded',
		                );
		              })
	              .catch((err) => {
	                logger?.warn({ err: err && err.message ? err.message : String(err) }, 'diag verify: shadow run failed');
	              });
	          });
	        }

	        return { envelope, report };
	      };

      const output = await runOnce({
        pipelineVersion: outputPipelineVersion,
        persistLastAnalysis: true,
        shadowRun: false,
      });

      if (shadowRunV2) {
        setImmediate(() => {
          runOnce({ pipelineVersion: 'v2', persistLastAnalysis: false, shadowRun: true }).catch((err) => {
            logger?.warn({ err: err && err.message ? err.message : String(err) }, 'aurora bff: v2 shadow run failed');
          });
        });
      }

      return res.json(output.envelope);
    } catch (err) {
      const status = err.status || 500;
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to generate skin analysis.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'ANALYSIS_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'ANALYSIS_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.get('/v1/session/bootstrap', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      let profile = null;
      let recentLogs = [];
      let dbError = null;
      const identity = await resolveIdentity(req, ctx);
      try {
        profile = await getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId });
        recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7);
      } catch (err) {
        dbError = err;
      }

      const isReturning = Boolean(profile) || recentLogs.length > 0;
      const checkinDue = isCheckinDue(recentLogs);

      const cards = [
        {
          card_id: `bootstrap_${ctx.request_id}`,
          type: 'session_bootstrap',
          payload: {
            profile: summarizeProfileForContext(profile),
            recent_logs: recentLogs,
            checkin_due: checkinDue,
            is_returning: isReturning,
            db_ready: !dbError,
          },
          ...(dbError
            ? { field_missing: [{ field: 'profile', reason: 'db_not_configured_or_unavailable' }] }
            : {}),
        },
      ];

      const events = [makeEvent(ctx, 'state_entered', { state: ctx.state || 'unknown', trigger_source: ctx.trigger_source })];
      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards,
        session_patch: {
          profile: summarizeProfileForContext(profile),
          recent_logs: recentLogs,
          checkin_due: checkinDue,
          is_returning: isReturning,
        },
        events,
      });
      return res.json(envelope);
    } catch (err) {
      const status = err.status || 500;
      logger?.warn({ err: err.message, status }, 'session bootstrap failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to bootstrap session.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'BOOTSTRAP_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'BOOTSTRAP_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/profile/update', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = UserProfilePatchSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const identity = await resolveIdentity(req, ctx);
      const updated = await upsertProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, parsed.data);

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          { card_id: `profile_${ctx.request_id}`, type: 'profile', payload: { profile: summarizeProfileForContext(updated) } },
        ],
        session_patch: { profile: summarizeProfileForContext(updated) },
        events: [makeEvent(ctx, 'profile_saved', { fields: Object.keys(parsed.data) })],
      });
      return res.json(envelope);
    } catch (err) {
      const { code, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const status =
        err && typeof err.status === 'number' && Number.isFinite(err.status) && err.status >= 400 && err.status < 600
          ? err.status
          : dbError
            ? 503
            : 500;
      logger?.warn({ err: err?.message || String(err), code, status }, 'profile update failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message:
          status >= 400 && status < 500
            ? makeAssistantMessage('Invalid request.')
            : makeAssistantMessage(dbError ? 'Storage is not ready yet. Please try again shortly.' : 'Failed to save profile.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error:
                status >= 400 && status < 500
                  ? err.code || 'BAD_REQUEST'
                  : dbNotConfigured
                    ? 'DB_NOT_CONFIGURED'
                    : dbSchemaError
                      ? 'DB_SCHEMA_NOT_READY'
                      : dbError
                        ? 'DB_UNAVAILABLE'
                        : 'PROFILE_SAVE_FAILED',
              ...(status >= 400 && status < 500 ? {} : code ? { code } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: (status >= 400 && status < 500 ? err.code : code) || 'PROFILE_SAVE_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

	  app.post('/v1/profile/delete', async (req, res) => {
	    const ctx = buildRequestContext(req, {});
	    try {
	      requireAuroraUid(ctx);
	      const identity = await resolveIdentity(req, ctx);
	      const result = await deleteIdentityData({ auroraUid: identity.auroraUid, userId: identity.userId });
	      try {
	        const hardCases = await deleteHardCasesForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId, logger });
	        if (hardCases && hardCases.deleted) {
	          logger?.info(
	            { kind: 'hard_case_delete', request_id: ctx.request_id, deleted: hardCases.deleted },
	            'hard case sampler: deleted on profile delete',
	          );
	        }
	      } catch (err) {
	        logger?.warn({ err: err && err.message ? err.message : String(err) }, 'hard case sampler: profile delete cleanup failed');
	      }

	      const envelope = buildEnvelope(ctx, {
	        assistant_message: null,
	        suggested_chips: [],
        cards: [
          {
            card_id: `profile_delete_${ctx.request_id}`,
            type: 'profile_deleted',
            payload: { ok: Boolean(result && result.ok), deleted: Boolean(result && result.deleted), storage: result?.storage || null },
          },
        ],
        session_patch: {
          profile: null,
          recent_logs: [],
          checkin_due: true,
          is_returning: false,
        },
        events: [makeEvent(ctx, 'profile_deleted', { storage: result?.storage || null })],
      });
      return res.json(envelope);
    } catch (err) {
      const { code, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const status =
        err && typeof err.status === 'number' && Number.isFinite(err.status) && err.status >= 400 && err.status < 600
          ? err.status
          : dbError
            ? 503
            : 500;
      logger?.warn({ err: err?.message || String(err), code, status }, 'profile delete failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message:
          status >= 400 && status < 500
            ? makeAssistantMessage('Invalid request.')
            : makeAssistantMessage(dbError ? 'Storage is not ready yet. Please try again shortly.' : 'Failed to delete profile data.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error:
                status >= 400 && status < 500
                  ? err.code || 'BAD_REQUEST'
                  : dbNotConfigured
                    ? 'DB_NOT_CONFIGURED'
                    : dbSchemaError
                      ? 'DB_SCHEMA_NOT_READY'
                      : dbError
                        ? 'DB_UNAVAILABLE'
                        : 'PROFILE_DELETE_FAILED',
              ...(status >= 400 && status < 500 ? {} : code ? { code } : {}),
            },
          },
        ],
        session_patch: {},
        events: [
          makeEvent(ctx, 'error', { code: (status >= 400 && status < 500 ? err.code : code) || 'PROFILE_DELETE_FAILED' }),
        ],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/tracker/log', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = TrackerLogSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const identity = await resolveIdentity(req, ctx);
      const saved = await upsertSkinLogForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, parsed.data);
      const recent = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7);

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          { card_id: `tracker_${ctx.request_id}`, type: 'tracker_log', payload: { log: saved, recent_logs: recent } },
        ],
        session_patch: { recent_logs: recent, checkin_due: isCheckinDue(recent) },
        events: [makeEvent(ctx, 'tracker_logged', { date: saved?.date || null })],
      });
      return res.json(envelope);
    } catch (err) {
      const { code, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const status =
        err && typeof err.status === 'number' && Number.isFinite(err.status) && err.status >= 400 && err.status < 600
          ? err.status
          : dbError
            ? 503
            : 500;
      logger?.warn({ err: err?.message || String(err), code, status }, 'tracker log failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message:
          status >= 400 && status < 500
            ? makeAssistantMessage('Invalid request.')
            : makeAssistantMessage(dbError ? 'Storage is not ready yet. Please try again shortly.' : 'Failed to save tracker log.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error:
                status >= 400 && status < 500
                  ? err.code || 'BAD_REQUEST'
                  : dbNotConfigured
                    ? 'DB_NOT_CONFIGURED'
                    : dbSchemaError
                      ? 'DB_SCHEMA_NOT_READY'
                      : dbError
                        ? 'DB_UNAVAILABLE'
                        : 'TRACKER_LOG_FAILED',
              ...(status >= 400 && status < 500 ? {} : code ? { code } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: (status >= 400 && status < 500 ? err.code : code) || 'TRACKER_LOG_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.get('/v1/tracker/recent', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const days = req.query.days ? Number(req.query.days) : 7;
      const identity = await resolveIdentity(req, ctx);
      const recent = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, days);
      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [{ card_id: `recent_${ctx.request_id}`, type: 'tracker_recent', payload: { days, logs: recent } }],
        session_patch: { recent_logs: recent, checkin_due: isCheckinDue(recent) },
        events: [makeEvent(ctx, 'tracker_loaded', { days })],
      });
      return res.json(envelope);
    } catch (err) {
      const { code, dbError, dbNotConfigured, dbSchemaError } = classifyStorageError(err);
      const status =
        err && typeof err.status === 'number' && Number.isFinite(err.status) && err.status >= 400 && err.status < 600
          ? err.status
          : dbError
            ? 503
            : 500;
      logger?.warn({ err: err?.message || String(err), code, status }, 'tracker recent failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message:
          status >= 400 && status < 500
            ? makeAssistantMessage('Invalid request.')
            : makeAssistantMessage(dbError ? 'Storage is not ready yet. Please try again shortly.' : 'Failed to load tracker logs.'),
        suggested_chips: [],
        cards: [
          {
            card_id: `err_${ctx.request_id}`,
            type: 'error',
            payload: {
              error:
                status >= 400 && status < 500
                  ? err.code || 'BAD_REQUEST'
                  : dbNotConfigured
                    ? 'DB_NOT_CONFIGURED'
                    : dbSchemaError
                      ? 'DB_SCHEMA_NOT_READY'
                      : dbError
                        ? 'DB_UNAVAILABLE'
                        : 'TRACKER_LOAD_FAILED',
              ...(status >= 400 && status < 500 ? {} : code ? { code } : {}),
            },
          },
        ],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: (status >= 400 && status < 500 ? err.code : code) || 'TRACKER_LOAD_FAILED' })],
      });
      return res.status(status).json(envelope);
    }
  });

  app.post('/v1/routine/simulate', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = RoutineSimulateRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const routine = parsed.data.routine || {};
      const testProduct = parsed.data.test_product || null;
      const sim = simulateConflicts({ routine, testProduct });
      const heatmapSteps = buildHeatmapStepsFromRoutine(routine, { testProduct });
      const heatmapPayload = CONFLICT_HEATMAP_V1_ENABLED
        ? buildConflictHeatmapV1({ routineSimulation: { safe: sim.safe, conflicts: sim.conflicts, summary: sim.summary }, routineSteps: heatmapSteps })
        : { schema_version: 'aurora.ui.conflict_heatmap.v1' };
      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `sim_${ctx.request_id}`,
            type: 'routine_simulation',
            payload: { safe: sim.safe, conflicts: sim.conflicts, summary: sim.summary },
          },
          {
            card_id: `heatmap_${ctx.request_id}`,
            type: 'conflict_heatmap',
            payload: heatmapPayload,
          },
        ],
        session_patch: {},
        events: [
          makeEvent(ctx, 'simulate_conflict', { safe: sim.safe, conflicts: sim.conflicts.length }),
          ...(CONFLICT_HEATMAP_V1_ENABLED
            ? [
              makeEvent(ctx, 'aurora_conflict_heatmap_impression', {
                schema_version: heatmapPayload.schema_version,
                state: heatmapPayload.state,
                num_steps: Array.isArray(heatmapPayload.axes?.rows?.items) ? heatmapPayload.axes.rows.items.length : 0,
                num_cells_nonzero: Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items.length : 0,
                num_unmapped_conflicts: Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts.length : 0,
                max_severity: Math.max(
                  0,
                  ...((Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items : []).map((c) => Number(c?.severity) || 0)),
                  ...((Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts : []).map((c) => Number(c?.severity) || 0)),
                ),
                routine_simulation_safe: Boolean(sim.safe),
                routine_conflict_count: sim.conflicts.length,
                trigger_source: ctx.trigger_source,
              }),
            ]
            : []),
        ],
      });
      return res.json(envelope);
    } catch (err) {
      logger?.warn({ err: err.message }, 'routine simulate failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to simulate routine.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'SIMULATE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: 'SIMULATE_FAILED' })],
      });
      return res.status(500).json(envelope);
    }
  });

  app.post('/v1/offers/resolve', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = OffersResolveRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const market = String(parsed.data.market || 'US').trim() || 'US';
      const items = parsed.data.items;

      const resolved = [];
      const fieldMissing = [];

      for (const item of items) {
        const itemStartedAt = Date.now();
        const itemElapsedMs = () => Math.max(0, Date.now() - itemStartedAt);
        const product = item.product;
        const offer = item.offer;
        const url = offer && (offer.affiliate_url || offer.affiliateUrl || offer.url);

        if (USE_AURORA_BFF_MOCK) {
          const nextItem = applyOfferItemPdpOpenContract({
            product: { ...product, image_url: product.image_url || 'https://img.example.com/mock.jpg' },
            offer: { ...offer, price: typeof offer.price === 'number' && offer.price > 0 ? offer.price : 12.34, currency: offer.currency || 'USD' },
          }, { timeToPdpMs: itemElapsedMs() });
          resolved.push(nextItem);
          continue;
        }

        if (!url) {
          resolved.push(applyOfferItemPdpOpenContract(item, { timeToPdpMs: itemElapsedMs() }));
          fieldMissing.push({ field: 'offer.affiliate_url', reason: 'missing_affiliate_url' });
          continue;
        }
        if (!PIVOTA_BACKEND_BASE_URL) {
          resolved.push(applyOfferItemPdpOpenContract(item, { timeToPdpMs: itemElapsedMs() }));
          fieldMissing.push({ field: 'offer.snapshot', reason: 'pivota_backend_not_configured' });
          continue;
        }

        try {
          const resp = await axios.post(
            `${PIVOTA_BACKEND_BASE_URL}/api/offers/external/resolve`,
            { market, url, forceRefresh: false },
            { timeout: 12000, validateStatus: () => true },
          );
          if (resp.status !== 200 || !resp.data || !resp.data.ok || !resp.data.offer) {
            const failReason = mapOfferResolveFailureCode({
              responseBody: resp?.data,
              statusCode: resp?.status,
            });
            resolved.push(
              applyOfferItemPdpOpenContract(item, {
                failReasonCode: failReason,
                resolveAttempted: true,
                timeToPdpMs: itemElapsedMs(),
              }),
            );
            fieldMissing.push({
              field: 'offer.snapshot',
              reason: failReason === 'db_error' ? 'external_offer_resolve_db_error' : 'external_offer_resolve_failed',
            });
            continue;
          }
          const snap = resp.data.offer;
          const patchedProduct = { ...product };
          const patchedOffer = { ...offer };

          if (snap.imageUrl) patchedProduct.image_url = snap.imageUrl;
          if (snap.title && !patchedProduct.name) patchedProduct.name = snap.title;
          if (snap.brand && !patchedProduct.brand) patchedProduct.brand = snap.brand;
          if (snap.price && typeof snap.price === 'object') {
            if (typeof snap.price.amount === 'number') patchedOffer.price = snap.price.amount;
            if (typeof snap.price.currency === 'string') patchedOffer.currency = snap.price.currency;
          }
          if (snap.canonicalUrl) patchedOffer.affiliate_url = snap.canonicalUrl;

          resolved.push(
            applyOfferItemPdpOpenContract(
              { ...item, product: patchedProduct, offer: patchedOffer },
              { resolveAttempted: true, timeToPdpMs: itemElapsedMs() },
            ),
          );
        } catch (err) {
          const failReason = mapOfferResolveFailureCode({ error: err });
          resolved.push(
            applyOfferItemPdpOpenContract(item, {
              failReasonCode: failReason,
              resolveAttempted: true,
              timeToPdpMs: itemElapsedMs(),
            }),
          );
          fieldMissing.push({
            field: 'offer.snapshot',
            reason: failReason === 'db_error' ? 'external_offer_resolve_db_error' : 'external_offer_resolve_timeout_or_network',
          });
        }
      }

      const offersPdpMeta = summarizeOfferPdpOpen(resolved);
      schedulePdpCorePrefetchFromItems(resolved, {
        logger,
        reason: 'offers_resolved',
      });

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [
          {
            card_id: `offers_${ctx.request_id}`,
            type: 'offers_resolved',
            payload: {
              items: resolved,
              market,
              metadata: {
                pdp_open_path_stats: offersPdpMeta.path_stats,
                fail_reason_counts: offersPdpMeta.fail_reason_counts,
                time_to_pdp_ms_stats: offersPdpMeta.time_to_pdp_ms_stats,
              },
            },
            ...(fieldMissing.length ? { field_missing: fieldMissing.slice(0, 8) } : {}),
          },
        ],
        session_patch: {},
        events: [
          makeEvent(ctx, 'offers_resolved', {
            count: resolved.length,
            market,
            pdp_open_path_stats: offersPdpMeta.path_stats,
            fail_reason_counts: offersPdpMeta.fail_reason_counts,
            time_to_pdp_ms_stats: offersPdpMeta.time_to_pdp_ms_stats,
          }),
        ],
      });
      return res.json(envelope);
    } catch (err) {
      logger?.warn({ err: err.message }, 'offers resolve failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to resolve offers.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'OFFERS_RESOLVE_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: 'OFFERS_RESOLVE_FAILED' })],
      });
      return res.status(500).json(envelope);
    }
  });

  app.post('/v1/affiliate/outcome', async (req, res) => {
    const ctx = buildRequestContext(req, {});
    try {
      requireAuroraUid(ctx);
      const parsed = AffiliateOutcomeRequestSchema.safeParse(req.body || {});
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return res.status(400).json(envelope);
      }

      const envelope = buildEnvelope(ctx, {
        assistant_message: null,
        suggested_chips: [],
        cards: [{ card_id: `out_${ctx.request_id}`, type: 'affiliate_outcome', payload: parsed.data }],
        session_patch: {},
        events: [makeEvent(ctx, 'outbound_opened', { outcome: parsed.data.outcome, url: parsed.data.url || null })],
      });
      return res.json(envelope);
    } catch (err) {
      logger?.warn({ err: err.message }, 'affiliate outcome failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to record outcome.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'OUTCOME_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: 'OUTCOME_FAILED' })],
      });
      return res.status(500).json(envelope);
    }
  });

  app.post('/v1/chat', async (req, res) => {
    const parsed = V1ChatRequestSchema.safeParse(req.body || {});
    const ctx = buildRequestContext(req, parsed.success ? parsed.data : req.body || {});
    const templateCtx = {
      ...ctx,
      accept_language: String(req.get('Accept-Language') || req.get('accept-language') || '').trim(),
    };
    let chatSessionId = getRecoDogfoodSessionId(req, ctx, '');
    let llmRouteMetaForResponse = null;
    const hasAnyLlmRouteMeta = (meta) =>
      Boolean(
        meta &&
          typeof meta === 'object' &&
          (
            meta.llm_provider_requested ||
            meta.llm_model_requested ||
            meta.llm_provider_effective ||
            meta.llm_model_effective
          ),
      );
    const applyLlmMetaToEnvelope = (envelope) => {
      if (!hasAnyLlmRouteMeta(llmRouteMetaForResponse)) return envelope;
      if (!envelope || typeof envelope !== 'object') return envelope;

      const out = { ...envelope };
      const baseSessionPatch = out.session_patch && typeof out.session_patch === 'object' && !Array.isArray(out.session_patch)
        ? { ...out.session_patch }
        : {};
      if (!baseSessionPatch.llm || typeof baseSessionPatch.llm !== 'object' || Array.isArray(baseSessionPatch.llm)) {
        baseSessionPatch.llm = llmRouteMetaForResponse;
      }
      out.session_patch = baseSessionPatch;

      const events = Array.isArray(out.events) ? out.events.slice() : [];
      const hasRouteEvent = events.some((evt) => evt && typeof evt === 'object' && evt.event_name === 'llm_route');
      if (!hasRouteEvent) {
        events.push(makeEvent(ctx, 'llm_route', llmRouteMetaForResponse));
      }
      out.events = events;
      return out;
    };
    const sendChatEnvelope = (envelope, statusCode = 200) => {
      const withLlmMeta = applyLlmMetaToEnvelope(envelope);
      const dogfoodAugmented = augmentEnvelopeProductAnalysisCardsForDogfood({
        envelope: withLlmMeta,
        req,
        ctx,
        mode: 'main_path',
        sessionId: chatSessionId,
        logger,
      });
      const normalized = applyReplyTemplates({ envelope: dogfoodAugmented, ctx: templateCtx });
      emitAudit(normalized, templateCtx, { logger });
      if (statusCode >= 400) return res.status(statusCode).json(normalized);
      return res.json(normalized);
    };

    try {
      requireAuroraUid(ctx);
      if (!parsed.success) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeAssistantMessage('Invalid request.'),
          suggested_chips: [],
          cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: 'BAD_REQUEST', details: parsed.error.format() } }],
          session_patch: {},
          events: [makeEvent(ctx, 'error', { code: 'BAD_REQUEST' })],
        });
        return sendChatEnvelope(envelope, 400);
      }

      chatSessionId = getRecoDogfoodSessionId(
        req,
        ctx,
        pickFirstTrimmed(
          parsed.data?.session?.session_id,
          parsed.data?.session?.sessionId,
          parsed.data?.session?.id,
        ),
      );

      const identity = await resolveIdentity(req, ctx);

      // Best-effort context injection.
      let profile = null;
      let recentLogs = [];
      let storageContextLoadFailed = false;
      try {
        profile = await getProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId });
        recentLogs = await getRecentSkinLogsForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, 7);
      } catch (err) {
        storageContextLoadFailed = true;
        logger?.warn({ err: err.code || err.message }, 'aurora bff: failed to load memory context');
      }
      if (storageContextLoadFailed) {
        recordProfileContextMissing({ side: 'backend' });
      }

      // If the client already has a profile snapshot (for example, cached from bootstrap or a local quick-profile flow),
      // use it as an additional best-effort context source so we don't re-ask for already-known fields when DB reads fail.
      const profilePatchFromSession = extractProfilePatchFromSession(parsed.data.session);
      if (!profilePatchFromSession) {
        recordProfileContextMissing({ side: 'frontend' });
      }
      if (profilePatchFromSession) {
        profile = { ...(profile || {}), ...profilePatchFromSession };
      }

      // Allow chips/actions to patch profile inline (so chat can progress without an extra API call).
      const profilePatchFromAction = parseProfilePatchFromAction(parsed.data.action);
      let appliedProfilePatch = null;
      if (profilePatchFromAction) {
        const patchParsed = UserProfilePatchSchema.safeParse(profilePatchFromAction);
        if (patchParsed.success) {
          appliedProfilePatch = patchParsed.data;
          // Always apply inline for gating even if DB is unavailable.
          profile = { ...(profile || {}), ...patchParsed.data };
          try {
            profile = await upsertProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, patchParsed.data);
          } catch (err) {
            logger?.warn({ err: err.code || err.message }, 'aurora bff: failed to apply profile chip patch');
          }
        }
      }

      const actionReplyText = extractReplyTextFromAction(parsed.data.action);
      const message = String(parsed.data.message || '').trim() || actionReplyText || '';
      const actionId =
        parsed.data.action && typeof parsed.data.action === 'object'
          ? parsed.data.action.action_id
          : typeof parsed.data.action === 'string'
            ? parsed.data.action
            : null;
      const clarificationId =
        parsed.data.action &&
        typeof parsed.data.action === 'object' &&
        parsed.data.action.data &&
        typeof parsed.data.action.data === 'object'
          ? parsed.data.action.data.clarification_id || parsed.data.action.data.clarificationId || null
          : null;
      const includeAlternatives = extractIncludeAlternativesFromAction(parsed.data.action);
      const debugHeader = req.get('X-Debug') ?? req.get('X-Aurora-Debug');
      const debugFromHeader = debugHeader == null ? undefined : coerceBoolean(debugHeader);
      const debugFromBody = typeof parsed.data.debug === 'boolean' ? parsed.data.debug : undefined;
      const debugUpstream = debugFromHeader ?? debugFromBody;
      const llmProvider =
        normalizeChatLlmProvider(parsed.data.llm_provider) ||
        normalizeChatLlmProvider(req.get('X-LLM-Provider') ?? req.get('X-Aurora-LLM-Provider'));
      const llmModel =
        normalizeChatLlmModel(parsed.data.llm_model) ||
        normalizeChatLlmModel(req.get('X-LLM-Model') ?? req.get('X-Aurora-LLM-Model'));
      llmRouteMetaForResponse =
        llmProvider || llmModel
          ? {
            llm_provider_requested: llmProvider || null,
            llm_model_requested: llmModel || null,
            llm_provider_effective: null,
            llm_model_effective: null,
          }
          : null;
      const anchorProductId =
        typeof parsed.data.anchor_product_id === 'string' && parsed.data.anchor_product_id.trim()
          ? parsed.data.anchor_product_id.trim()
          : '';
      const anchorProductUrl =
        typeof parsed.data.anchor_product_url === 'string' && parsed.data.anchor_product_url.trim()
          ? parsed.data.anchor_product_url.trim()
          : '';
      const upstreamMessages = Array.isArray(parsed.data.messages) ? parsed.data.messages : null;

      const makeChatAssistantMessage = (content, format = 'text') => {
        const preambleSeed = `${ctx.request_id || ''}|${ctx.trace_id || ''}|${String(content || '').slice(0, 96)}`;
        const text = addEmotionalPreambleToAssistantText(content, { language: ctx.lang, profile, seed: preambleSeed });
        return makeAssistantMessage(text, format);
      };

      const clientAgentState = normalizeAgentState(parsed.data.client_state);

      const requestedTransitionFromBody =
        parsed.data.requested_transition && typeof parsed.data.requested_transition === 'object'
          ? parsed.data.requested_transition
          : null;

      const derivedTransitionFromAction = !requestedTransitionFromBody && actionId
        ? deriveRequestedTransitionFromAction({ fromState: clientAgentState, actionId })
        : null;

      const derivedTransitionFromText = !requestedTransitionFromBody && !derivedTransitionFromAction && message
        ? inferTextExplicitTransition(message, ctx.lang)
        : null;

      const requestedTransition =
        requestedTransitionFromBody ||
        derivedTransitionFromAction ||
        (derivedTransitionFromText
          ? { trigger_source: 'text_explicit', trigger_id: derivedTransitionFromText.trigger_id, requested_next_state: derivedTransitionFromText.requested_next_state }
          : null);

      let agentState = clientAgentState;
      if (requestedTransition) {
        const triggerSource = String(requestedTransition.trigger_source || '').trim();
        const triggerId = String(requestedTransition.trigger_id || '').trim();
        const requestedNextState = normalizeAgentState(requestedTransition.requested_next_state);

        if (triggerSource === 'text_explicit') {
          const inferred = inferTextExplicitTransition(message, ctx.lang);
          if (!inferred || inferred.requested_next_state !== requestedNextState) {
            const envelope = buildEnvelope(ctx, {
              assistant_message: makeAssistantMessage(
                ctx.lang === 'CN'
                  ? 'text_explicit '
                  : 'Requested state transition rejected (text_explicit did not match allowlist).',
              ),
              suggested_chips: [],
              cards: [
                {
                  card_id: `err_${ctx.request_id}`,
                  type: 'error',
                  payload: {
                    error: 'STATE_TRANSITION_REJECTED',
                    details: { reason: 'TEXT_EXPLICIT_NOT_ALLOWED', requested_next_state: requestedNextState },
                  },
                },
              ],
              session_patch: {},
              events: [makeEvent(ctx, 'error', { code: 'STATE_TRANSITION_REJECTED', reason: 'TEXT_EXPLICIT_NOT_ALLOWED' })],
            });
            return sendChatEnvelope(envelope, 400);
          }
        }

        const validation = validateRequestedTransition({
          fromState: clientAgentState,
          triggerSource,
          triggerId,
          requestedNextState,
        });

        if (!validation.ok) {
          const envelope = buildEnvelope(ctx, {
            assistant_message: makeAssistantMessage(
              ctx.lang === 'CN'
                ? ''
                : 'Requested state transition rejected (state machine hard rule).',
            ),
            suggested_chips: [],
            cards: [
              {
                card_id: `err_${ctx.request_id}`,
                type: 'error',
                payload: {
                  error: 'STATE_TRANSITION_REJECTED',
                  details: {
                    reason: validation.reason,
                    from_state: clientAgentState,
                    requested_next_state: requestedNextState,
                    trigger_source: triggerSource,
                    trigger_id: triggerId,
                  },
                },
              },
            ],
            session_patch: {},
            events: [makeEvent(ctx, 'error', { code: 'STATE_TRANSITION_REJECTED', reason: validation.reason })],
          });
          return sendChatEnvelope(envelope, 400);
        }

        agentState = validation.next_state;
      }

      const recoInteractionAllowed = recommendationsAllowed({
        triggerSource: ctx.trigger_source,
        actionId,
        clarificationId,
        message,
        state: ctx.state,
        agentState,
      });

      const allowRecoCards =
        agentState === 'RECO_GATE' ||
        agentState === 'RECO_CONSTRAINTS' ||
        agentState === 'RECO_RESULTS' ||
        // Dynamic clarification chips (for example: chip.clarify.budget.*) may not exist in the
        // static state-machine map, but are still explicit recommendation interactions.
        recoInteractionAllowed;

      let upstreamMessage = message;
      let clarificationHistoryForUpstream = null;
      let resumeContextForUpstream = null;
      let pendingClarificationPatchOverride = undefined;
      let forceUpstreamAfterPendingAbandon = false;
      const clarifyChipAction = isClarifyChipAction(parsed.data.action, { actionId, clarificationId });
      const sessionStateRaw =
        parsed.data.session && typeof parsed.data.session === 'object' && !Array.isArray(parsed.data.session)
          ? parsed.data.session.state
          : null;
      const hasRawPendingClarification =
        sessionStateRaw &&
        typeof sessionStateRaw === 'object' &&
        !Array.isArray(sessionStateRaw) &&
        Object.prototype.hasOwnProperty.call(sessionStateRaw, 'pending_clarification');
      const pendingClarificationState = getPendingClarification(parsed.data.session);
      const pendingClarification = pendingClarificationState ? pendingClarificationState.pending : null;
      if (
        AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED &&
        pendingClarificationState &&
        pendingClarificationState.upgraded &&
        pendingClarificationPatchOverride === undefined
      ) {
        pendingClarificationPatchOverride = pendingClarification;
      }
      if (AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED && hasRawPendingClarification && !pendingClarification) {
        recordPendingClarificationAbandoned({ reason: 'error' });
      }

      let pendingClarificationExpired = false;
      if (AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED && pendingClarification) {
        const ageMs = Date.now() - Number(pendingClarification.created_at_ms || 0);
        if (!Number.isFinite(ageMs) || ageMs > PENDING_CLARIFICATION_TTL_MS) {
          pendingClarificationExpired = true;
          pendingClarificationPatchOverride = null;
          if (clarifyChipAction) forceUpstreamAfterPendingAbandon = true;
          recordPendingClarificationAbandoned({ reason: 'ttl' });
        }
      }

      if (
        AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED &&
        pendingClarification &&
        !pendingClarificationExpired &&
        !clarifyChipAction &&
        message
      ) {
        pendingClarificationPatchOverride = null;
        recordPendingClarificationAbandoned({ reason: 'free_text' });
      }

      if (
        AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED &&
        !pendingClarification &&
        clarifyChipAction &&
        hasPendingClarificationStateHint(parsed.data.action)
      ) {
        recordPendingClarificationAbandoned({ reason: 'missing_state' });
      }

      if (
        AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED &&
        pendingClarification &&
        !pendingClarificationExpired &&
        clarifyChipAction
      ) {
        const selectedOption = actionReplyText || parseClarificationReplyFromActionId(actionId);
        const selectedQuestionId =
          extractClarificationQuestionIdFromAction(parsed.data.action) ||
          (pendingClarification.current && pendingClarification.current.id) ||
          (typeof clarificationId === 'string' ? clarificationId.trim() : '') ||
          parseClarificationIdFromActionId(actionId);
        const { nextPending, nextQuestion, history } = advancePendingClarification(
          pendingClarification,
          selectedOption,
          selectedQuestionId,
        );

        if (nextPending && nextQuestion) {
          const profileSummaryForPatch = summarizeProfileForContext(profile);
          const sessionPatch = {};
          emitPendingClarificationPatch(sessionPatch, nextPending);
          if (profileSummaryForPatch) {
            sessionPatch.profile = profileSummaryForPatch;
            recordSessionPatchProfileEmitted({ changed: Boolean(appliedProfilePatch) });
          }
          const nextStepIndex = Array.isArray(nextPending.history) ? nextPending.history.length + 1 : 1;
          const chips = buildChipsForQuestion(nextQuestion, { stepIndex: nextStepIndex });
          recordAuroraChatSkipped({ reason: 'pending_clarification_step' });
          recordPendingClarificationStep({ stepIndex: Array.isArray(nextPending.history) ? nextPending.history.length : 1 });

          const questionText = String(nextQuestion.question || '').trim() ||
            (ctx.lang === 'CN' ? '' : 'One more quick question.');
          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(questionText),
            suggested_chips: chips,
            cards: [],
            session_patch: sessionPatch,
            events: [makeEvent(ctx, 'state_entered', { next_state: ctx.state || 'idle', reason: 'pending_clarification_step' })],
          });
          return sendChatEnvelope(envelope);
        }

        pendingClarificationPatchOverride = null;
        upstreamMessage = pendingClarification.resume_user_text || upstreamMessage || message;
        const compactHistory = compactClarificationHistory(history);
        if (AURORA_CHAT_CLARIFICATION_HISTORY_CONTEXT_ENABLED) {
          clarificationHistoryForUpstream = compactHistory;
        }
        const profileSummaryForResume = summarizeProfileForContext(profile);
        const knownProfileFieldsForResume = buildResumeKnownProfileFields(profileSummaryForResume);
        resumeContextForUpstream = {
          flow_id:
            pendingClarification && typeof pendingClarification.flow_id === 'string'
              ? pendingClarification.flow_id
              : null,
          resume_user_text: upstreamMessage || pendingClarification.resume_user_text || message || '(no message)',
          clarification_history: compactHistory,
          include_history: AURORA_CHAT_CLARIFICATION_HISTORY_CONTEXT_ENABLED,
          ...(knownProfileFieldsForResume ? { known_profile_fields: knownProfileFieldsForResume } : {}),
        };
        forceUpstreamAfterPendingAbandon = true;
        recordPendingClarificationCompleted();
      }

      // Optional session state override (used to escape sticky gates like S6_BUDGET when user switches intent).
      let nextStateOverride = null;

      // Escape sticky budget gate early so local short-circuit paths (env/conflict) can also return a session patch.
      if (ctx.state === 'S6_BUDGET') {
        const wantsFitCheck = looksLikeSuitabilityRequest(message);
        const wantsCompat = looksLikeCompatibilityOrConflictQuestion(message);
        const wantsScience = looksLikeIngredientScienceIntent(message, parsed.data.action);
        const wantsRecoNoRoutine =
          looksLikeRecommendationRequest(message) &&
          !looksLikeRoutineRequest(message, parsed.data.action);
        const wantsEnvStress =
          looksLikeWeatherOrEnvironmentQuestion(message) &&
          (ctx.trigger_source === 'text' || ctx.trigger_source === 'text_explicit');
        if (wantsFitCheck || wantsCompat || wantsScience || wantsEnvStress || wantsRecoNoRoutine) {
          if (stateChangeAllowed(ctx.trigger_source)) {
            nextStateOverride = allowRecoCards ? 'S7_PRODUCT_RECO' : 'idle';
          }
          ctx.state = nextStateOverride || 'idle';
        }
      }

      // Brand availability short-circuit: route "//" to catalog lookup (no diagnosis intake).
      if (
        AURORA_CHAT_CATALOG_AVAIL_FAST_PATH_ENABLED &&
        message &&
        (ctx.trigger_source === 'text' || ctx.trigger_source === 'text_explicit')
      ) {
        const availabilityIntent = detectCatalogAvailabilityIntent(message, ctx.lang);
        if (availabilityIntent) {
          recordCatalogAvailabilityShortCircuit({ brandId: availabilityIntent.brand_id, reason: availabilityIntent.reason });

          const availabilityQuery =
            String(availabilityIntent.query_hint || '').trim() ||
            buildAvailabilityCatalogQuery(message, availabilityIntent);
          const specificAvailabilityQuery = isSpecificAvailabilityQuery(availabilityQuery, availabilityIntent);
          const availabilityLabel = String(
            (specificAvailabilityQuery
              ? availabilityQuery
              : availabilityIntent.brand_name ||
                availabilityIntent.matched_alias ||
                availabilityQuery) ||
              (ctx.lang === 'CN' ? '' : 'target product'),
          )
            .trim()
            .slice(0, 120);

          const brandProduct = buildBrandPlaceholderProduct({
            brandId: availabilityIntent.brand_id,
            brandName: availabilityLabel,
            lang: ctx.lang,
          });

          const resolveAliasCandidates = [
            availabilityIntent.brand_name,
            availabilityIntent.matched_alias,
            availabilityQuery,
          ]
            .map((value) => String(value || '').trim())
            .filter(Boolean);
          const resolveAliases = [...new Set(resolveAliasCandidates)].slice(0, 8);
          const resolveHints = {
            ...(availabilityIntent.brand_name ? { brand: availabilityIntent.brand_name } : {}),
            ...(resolveAliases.length ? { aliases: resolveAliases } : {}),
          };

          let catalogResult = { ok: false, products: [], reason: 'unknown' };
          let products = [];
          let availabilityResolveFallback = null;
          let availabilityLocalResolveFallback = null;
          let availabilityResolveAttempted = false;
          let availabilityLocalResolveAttempted = false;
          if (PIVOTA_BACKEND_BASE_URL) {
            catalogResult = await searchPivotaBackendProducts({
              query: availabilityQuery || availabilityLabel || availabilityIntent.brand_id,
              limit: 8,
              logger,
              timeoutMs: CATALOG_AVAIL_SEARCH_TIMEOUT_MS,
            });
            products = Array.isArray(catalogResult.products) ? catalogResult.products : [];
          } else {
            catalogResult = { ok: false, products: [], reason: 'pivota_backend_not_configured' };
          }

          if (!products.length && CATALOG_AVAIL_RESOLVE_FALLBACK_ENABLED && PIVOTA_BACKEND_BASE_URL) {
            const reason = String(catalogResult.reason || '').trim().toLowerCase();
            const neutralCatalogMiss =
              !reason || reason === 'empty' || reason === 'no_candidates' || reason === 'not_found';
            const transientCatalogMiss =
              reason === 'upstream_timeout' || reason === 'upstream_error' || reason === 'rate_limited';
            const shouldRunResolveFallback =
              specificAvailabilityQuery &&
              (neutralCatalogMiss || (transientCatalogMiss && CATALOG_AVAIL_RESOLVE_FALLBACK_ON_TRANSIENT));
            if (shouldRunResolveFallback) {
              availabilityResolveAttempted = true;
              availabilityResolveFallback = await resolveAvailabilityProductByQuery({
                query: availabilityQuery || availabilityIntent.brand_name,
                lang: ctx.lang,
                hints: Object.keys(resolveHints).length ? resolveHints : null,
                logger,
              });
              if (availabilityResolveFallback?.ok && availabilityResolveFallback?.product) {
                products = [availabilityResolveFallback.product];
              }
            }
          }
          if (!products.length && specificAvailabilityQuery && RECO_PDP_STRICT_INTERNAL_FIRST) {
            availabilityLocalResolveAttempted = true;
            availabilityLocalResolveFallback = await resolveAvailabilityProductByLocalResolver({
              query: availabilityQuery || availabilityIntent.brand_name,
              lang: ctx.lang,
              hints: Object.keys(resolveHints).length ? resolveHints : null,
              logger,
            });
            if (availabilityLocalResolveFallback?.ok && availabilityLocalResolveFallback?.product) {
              products = [availabilityLocalResolveFallback.product];
            }
          }

          const offersItems = (products.length ? products : [brandProduct])
            .slice(0, 8)
            .map((product) => applyOfferItemPdpOpenContract({ product, offer: null }, { timeToPdpMs: 0 }));
          const offersPdpMeta = summarizeOfferPdpOpen(offersItems);

          const marketRaw = profile && typeof profile.region === 'string' ? profile.region.trim() : '';
          const market = marketRaw ? marketRaw.slice(0, 8).toUpperCase() : 'US';

          const hasResults = products.length > 0;
          const resolvedVia =
            availabilityResolveFallback?.ok
              ? 'products_resolve'
              : availabilityLocalResolveFallback?.ok
                ? 'local_resolver'
                : hasResults
                  ? 'products_search'
                  : 'none';
          const assistantRaw =
            ctx.lang === 'CN'
              ? hasResults
                ? `${availabilityLabel || ''}/`
                : `${availabilityLabel || ''}/`
              : hasResults
                ? `I found ${products.length} items for "${availabilityLabel || 'this product'}" (see the cards below). Are you looking for an official store, major retailers, or a specific product name?`
                : `I can help check our catalog, but I couldn't fetch items for "${availabilityLabel || 'this product'}" right now. Are you looking for an official store, major retailers, or a specific product name?`;

          const assistantText = applyCommerceMedicalClaimGuard(assistantRaw, ctx.lang);

          const profileSummary = summarizeProfileForContext(profile);
          const sessionPatch = {
            ...(nextStateOverride && stateChangeAllowed(ctx.trigger_source) ? { next_state: nextStateOverride } : {}),
            ...(profileSummary ? { profile: profileSummary } : {}),
          };
          if (profileSummary) {
            recordSessionPatchProfileEmitted({ changed: Boolean(appliedProfilePatch) });
          }

          const fieldMissing = [];
          if (!hasResults && catalogResult.reason) {
            fieldMissing.push({ field: 'catalog.products', reason: String(catalogResult.reason).slice(0, 60) });
            if (availabilityResolveFallback?.resolve_reason_code) {
              fieldMissing.push({
                field: 'catalog.resolve',
                reason: String(availabilityResolveFallback.resolve_reason_code).slice(0, 60),
              });
            }
            if (availabilityLocalResolveFallback?.resolve_reason_code) {
              fieldMissing.push({
                field: 'catalog.local_resolver',
                reason: String(availabilityLocalResolveFallback.resolve_reason_code).slice(0, 60),
              });
            }
          }

          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(assistantText),
            suggested_chips: [],
            cards: [
              {
                card_id: `parse_${ctx.request_id}`,
                type: 'product_parse',
                payload: {
                  product: hasResults && products[0] ? products[0] : brandProduct,
                  confidence: 1,
                  missing_info: [],
                  intent: 'availability',
                  brand_id: availabilityIntent.brand_id,
                  brand_name: availabilityLabel,
                },
              },
              {
                card_id: `offers_${ctx.request_id}`,
                type: 'offers_resolved',
                payload: {
                  items: offersItems,
                  market,
                  metadata: {
                    pdp_open_path_stats: offersPdpMeta.path_stats,
                    fail_reason_counts: offersPdpMeta.fail_reason_counts,
                    time_to_pdp_ms_stats: offersPdpMeta.time_to_pdp_ms_stats,
                  },
                },
                ...(fieldMissing.length ? { field_missing: fieldMissing.slice(0, 8) } : {}),
              },
            ],
            session_patch: sessionPatch,
            events: [
              makeEvent(ctx, 'catalog_availability_shortcircuit', {
                brand_id: availabilityIntent.brand_id,
                reason: availabilityIntent.reason,
                ok: Boolean(hasResults),
                count: products.length,
                query: String(availabilityQuery || '').slice(0, 120),
                resolved_via: resolvedVia,
                specific_query: specificAvailabilityQuery,
                catalog_reason: catalogResult.reason || null,
                resolve_reason_code: availabilityResolveFallback?.resolve_reason_code || null,
                local_resolve_attempted: availabilityLocalResolveAttempted,
                local_resolve_reason_code: availabilityLocalResolveFallback?.resolve_reason_code || null,
              }),
            ],
          });
          return sendChatEnvelope(envelope);
        }
      }

      // Local env-stress short-circuit: answer weather/environment questions without upstream.
      // Only for user-typed text (including text_explicit). Chips/actions should keep their intended routing.
      if (
        looksLikeWeatherOrEnvironmentQuestion(message) &&
        (ctx.trigger_source === 'text' || ctx.trigger_source === 'text_explicit')
      ) {
        const scenario = extractWeatherScenario(message);
        const envStressUi = buildEnvStressUiModelFromLocal({ profile, recentLogs, message, language: ctx.lang });
        const advice = buildWeatherAdviceMessage({ language: ctx.lang, scenario, profile });

        const lang = ctx.lang === 'CN' ? 'CN' : 'EN';
        const scenarioHint =
          scenario === 'snow'
            ? { cn: '', en: 'snowy weather' }
            : scenario === 'rain'
              ? { cn: '', en: 'rainy weather' }
              : scenario === 'uv'
                ? { cn: '/ UV', en: 'high UV' }
                : scenario === 'humid'
                  ? { cn: '', en: 'humid weather' }
                  : scenario === 'dry'
                    ? { cn: '', en: 'dry air' }
                    : scenario === 'cold'
                      ? { cn: '', en: 'cold weather' }
                      : scenario === 'wind'
                        ? { cn: '', en: 'windy weather' }
                        : scenario === 'travel'
                          ? { cn: '/', en: 'travel' }
                          : { cn: '', en: 'these conditions' };
        const suggestedChips = [
          {
            chip_id: 'chip.start.routine',
            label: lang === 'CN' ? ' AM/PM ' : 'Build an AM/PM routine',
            kind: 'quick_reply',
            data: {
              reply_text:
                lang === 'CN'
                  ? `${scenarioHint.cn} AM/PM `
                  : `Build an AM/PM routine for ${scenarioHint.en}`,
            },
          },
          {
            chip_id: 'chip.start.reco_products',
            label: lang === 'CN' ? '' : 'Recommend protective products',
            kind: 'quick_reply',
            data: {
              reply_text:
                lang === 'CN'
                  ? `${scenarioHint.cn}`
                  : `What protective products should I use for ${scenarioHint.en}?`,
            },
          },
        ];

        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(advice, 'markdown'),
          suggested_chips: suggestedChips,
          cards: envStressUi
            ? [{ card_id: `env_${ctx.request_id}`, type: 'env_stress', payload: envStressUi }]
            : [],
          session_patch:
            nextStateOverride && stateChangeAllowed(ctx.trigger_source) ? { next_state: nextStateOverride } : {},
          events: [makeEvent(ctx, 'value_moment', { kind: 'weather_advice', scenario })],
        });
        return sendChatEnvelope(envelope);
      }

      // Local compatibility/conflict short-circuit: return routine_simulation + conflict_heatmap without upstream.
      if (
        looksLikeCompatibilityOrConflictQuestion(message) &&
        // Allow both free text and chip/action reply_text, so users don't get stuck in unrelated gates (e.g. budget).
        (ctx.trigger_source === 'text' ||
          ctx.trigger_source === 'text_explicit' ||
          ctx.trigger_source === 'chip' ||
          ctx.trigger_source === 'action')
      ) {
        // NOTE: For ad-hoc "can I combine X with Y?" questions, do NOT auto-apply `profile.currentRoutine`.
        // Routine-specific simulation should be triggered from the routine feature/flow explicitly (e.g. /v1/routine/simulate).
        const simInput = buildLocalCompatibilitySimulationInput({ message });
        if (simInput) {
          const { routine, testProduct } = simInput;
          const sim = simulateConflicts({ routine, testProduct });
          const simPayload = { safe: sim.safe, conflicts: sim.conflicts, summary: sim.summary };
          const heatmapSteps = buildHeatmapStepsFromRoutine(routine, { testProduct });
          const heatmapPayload = CONFLICT_HEATMAP_V1_ENABLED
            ? buildConflictHeatmapV1({ routineSimulation: simPayload, routineSteps: heatmapSteps })
            : { schema_version: 'aurora.ui.conflict_heatmap.v1' };

          const routeText =
            buildRouteAwareAssistantText({
              route: 'conflict',
              payload: simPayload,
              language: ctx.lang,
              profile,
            }) ||
            (ctx.lang === 'CN'
              ? sim.safe
                ? '/'
                : '/'
              : sim.safe
                ? 'No major conflicts detected (see the heatmap below). If you feel irritation, reduce frequency and moisturize.'
                : 'Potential conflict detected (see the heatmap below). Safer: alternate nights and start low frequency.');
          const msgText = addEmotionalPreambleToAssistantText(routeText, {
            language: ctx.lang,
            profile,
            seed: ctx.request_id,
          });

          const events = [
            makeEvent(ctx, 'simulate_conflict', { safe: sim.safe, conflicts: sim.conflicts.length, source: 'local_chat' }),
          ];
          if (CONFLICT_HEATMAP_V1_ENABLED) {
            events.push(
              makeEvent(ctx, 'aurora_conflict_heatmap_impression', {
                schema_version: heatmapPayload.schema_version,
                state: heatmapPayload.state,
                num_steps: Array.isArray(heatmapPayload.axes?.rows?.items) ? heatmapPayload.axes.rows.items.length : 0,
                num_cells_nonzero: Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items.length : 0,
                num_unmapped_conflicts: Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts.length : 0,
                max_severity: Math.max(
                  0,
                  ...((Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items : []).map((c) => Number(c?.severity) || 0)),
                  ...((Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts : []).map((c) => Number(c?.severity) || 0)),
                ),
                routine_simulation_safe: Boolean(simPayload.safe),
                routine_conflict_count: Array.isArray(simPayload.conflicts) ? simPayload.conflicts.length : 0,
                trigger_source: ctx.trigger_source,
              }),
            );
          }

          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(msgText, 'markdown'),
            suggested_chips: [],
            cards: [
              { card_id: `sim_${ctx.request_id}`, type: 'routine_simulation', payload: simPayload },
              { card_id: `heatmap_${ctx.request_id}`, type: 'conflict_heatmap', payload: heatmapPayload },
            ],
            session_patch:
              nextStateOverride && stateChangeAllowed(ctx.trigger_source) ? { next_state: nextStateOverride } : {},
            events,
          });
          return sendChatEnvelope(envelope);
        }
      }

      // Explicit "Start diagnosis" should always enter the diagnosis flow (even if a profile already exists),
      // otherwise users can get stuck in an upstream "what next?" loop.
      if (String(agentState || '') === 'DIAG_PROFILE' || String(agentState || '').startsWith('DIAG_')) {
        const { score, missing } = profileCompleteness(profile);
        const requiredCore = ['skinType', 'sensitivity', 'barrierStatus', 'goals'];
        const missingCore = requiredCore.filter((k) => (Array.isArray(missing) ? missing.includes(k) : false));

        if (missingCore.length) {
          const prompt = buildDiagnosisPrompt(ctx.lang, missingCore);
          const chips = buildDiagnosisChips(ctx.lang, missingCore);
          const nextState = stateChangeAllowed(ctx.trigger_source) ? 'S2_DIAGNOSIS' : undefined;

          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(prompt),
            suggested_chips: chips,
            cards: [
              {
                card_id: `diag_${ctx.request_id}`,
                type: 'diagnosis_gate',
                payload: {
                  reason: 'diagnosis_start',
                  missing_fields: missingCore,
                  wants: 'diagnosis',
                  profile: summarizeProfileForContext(profile),
                  recent_logs: recentLogs,
                },
              },
            ],
            session_patch: nextState ? { next_state: nextState } : {},
            events: [makeEvent(ctx, 'state_entered', { next_state: nextState || null, reason: 'diagnosis_start' })],
          });
          return sendChatEnvelope(envelope);
        }

        const lang = ctx.lang === 'CN' ? 'CN' : 'EN';
        const prompt =
          lang === 'CN'
            ? ''
            : "Got it  I saved your skin profile. Want to upload a photo for a more accurate analysis? You can also skip photos and Ill give a low-confidence, safe baseline first.";

        const nextState = stateChangeAllowed(ctx.trigger_source) ? 'S2_DIAGNOSIS' : undefined;
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(prompt),
          suggested_chips: [
            {
              chip_id: 'chip.intake.upload_photos',
              label: lang === 'CN' ? '' : 'Upload a photo (more accurate)',
              kind: 'quick_reply',
              data: {},
            },
            {
              chip_id: 'chip.intake.skip_analysis',
              label: lang === 'CN' ? '' : 'Skip photo (low confidence)',
              kind: 'quick_reply',
              data: {},
            },
            {
              chip_id: 'chip_keep_chatting',
              label: lang === 'CN' ? '' : 'Just keep chatting',
              kind: 'quick_reply',
              data: {},
            },
          ],
          cards: [],
          session_patch: nextState ? { next_state: nextState, profile: summarizeProfileForContext(profile) } : { profile: summarizeProfileForContext(profile) },
          events: [makeEvent(ctx, 'state_entered', { next_state: nextState || null, reason: 'diagnosis_profile_complete' })],
        });
        return sendChatEnvelope(envelope);
      }

      const ingredientScienceIntent = looksLikeIngredientScienceIntent(message, parsed.data.action);
      const shouldKickoffIngredientScience =
        ingredientScienceIntent &&
        !looksLikeRoutineRequest(message, parsed.data.action) &&
        !looksLikeSuitabilityRequest(message) &&
        !looksLikeCompatibilityOrConflictQuestion(message) &&
        !looksLikeWeatherOrEnvironmentQuestion(message) &&
        !messageContainsSpecificIngredientScienceTarget(message);

      if (shouldKickoffIngredientScience) {
        const kickoff = buildIngredientScienceKickoff({ language: ctx.lang });
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(kickoff.prompt),
          suggested_chips: kickoff.chips,
          cards: [],
          session_patch:
            nextStateOverride && stateChangeAllowed(ctx.trigger_source) ? { next_state: nextStateOverride } : {},
          events: [makeEvent(ctx, 'state_entered', { next_state: ctx.state || 'idle', reason: 'ingredient_science_clarify' })],
        });
        return sendChatEnvelope(envelope);
      }

      const evaluateIntent =
        looksLikeProductEvaluationIntentV2(message, actionId) &&
        !looksLikeRoutineRequest(message, parsed.data.action) &&
        !looksLikeIngredientScienceIntent(message, parsed.data.action);
      const hasFitCheckAnchor = hasMeaningfulFitCheckAnchor({
        message,
        anchorProductId,
        anchorProductUrl,
      });
      if (evaluateIntent && !hasFitCheckAnchor) {
        const prompt = buildFitCheckAnchorPrompt(ctx.lang);
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(prompt.prompt),
          suggested_chips: prompt.chips,
          cards: [],
          session_patch:
            nextStateOverride && stateChangeAllowed(ctx.trigger_source) ? { next_state: nextStateOverride } : {},
          events: [makeEvent(ctx, 'state_entered', { next_state: ctx.state || 'idle', reason: 'fit_check_anchor_required' })],
        });
        return sendChatEnvelope(envelope);
      }

      if (isBudgetOptimizationEntryAction(actionId) && allowRecoCards) {
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(buildBudgetGatePrompt(ctx.lang)),
          suggested_chips: buildBudgetGateChips(ctx.lang),
          cards: [
            {
              card_id: `budget_${ctx.request_id}`,
              type: 'budget_gate',
              payload: { reason: 'budget_optimization_optional', profile: summarizeProfileForContext(profile) },
            },
          ],
          session_patch: stateChangeAllowed(ctx.trigger_source) ? { next_state: 'S6_BUDGET' } : {},
          events: [makeEvent(ctx, 'state_entered', { next_state: 'S6_BUDGET', reason: 'budget_optimization_optional' })],
        });
        return sendChatEnvelope(envelope);
      }

      // Phase 0 gate: Diagnosis-first (no recos/offers before minimal profile).
      // NOTE: In chat, avoid forcing users into "diagnosis-first" unless they explicitly asked to start diagnosis.
      // For recommendation/fit-check intents, proceed with best-effort and ask optional refinement questions later.

      // Budget gate + routing: when waiting for budget selection, proceed to routine generation.
      if (ctx.state === 'S6_BUDGET') {
        const rawBudget =
          normalizeBudgetHint(appliedProfilePatch && appliedProfilePatch.budgetTier) ||
          normalizeBudgetHint(profile && profile.budgetTier) ||
          normalizeBudgetHint(message);

        // If user asks a different explicit question while we're waiting for budget, don't trap them behind the routine budget gate.
        // Example: "Is this product suitable for me?" should go to fit-check/product analysis (budget is irrelevant).
        const wantsFitCheck = looksLikeSuitabilityRequest(message);
        const wantsCompat = looksLikeCompatibilityOrConflictQuestion(message);
        const wantsScience = looksLikeIngredientScienceIntent(message, parsed.data.action);
        const wantsRecoNoRoutine =
          looksLikeRecommendationRequest(message) &&
          !looksLikeRoutineRequest(message, parsed.data.action);
        const wantsEnvStress =
          looksLikeWeatherOrEnvironmentQuestion(message) &&
          (ctx.trigger_source === 'text' || ctx.trigger_source === 'text_explicit');

        if (wantsFitCheck || wantsCompat || wantsScience || wantsEnvStress || wantsRecoNoRoutine) {
          // Clear the budget-gate state so the client doesn't get stuck in a loop.
          if (stateChangeAllowed(ctx.trigger_source)) {
            nextStateOverride = allowRecoCards ? 'S7_PRODUCT_RECO' : 'idle';
          }
          ctx.state = nextStateOverride || 'idle';
        } else {
          if (!allowRecoCards) {
            const lang = ctx.lang === 'CN' ? 'CN' : 'EN';
            const suggestedChips = [
              {
                chip_id: 'chip.start.reco_products',
                label: lang === 'CN' ? '' : 'Get product recommendations',
                kind: 'quick_reply',
                data: { reply_text: lang === 'CN' ? '' : 'Get product recommendations' },
              },
              {
                chip_id: 'chip.start.routine',
                label: lang === 'CN' ? ' routine' : 'Build an AM/PM routine',
                kind: 'quick_reply',
                data: { reply_text: lang === 'CN' ? ' routine' : 'Build an AM/PM skincare routine' },
              },
            ];

            const envelope = buildEnvelope(ctx, {
              assistant_message: makeChatAssistantMessage(
                lang === 'CN'
                  ? ''
                  : 'To see recommendations and purchase links, please tap Get product recommendations.',
              ),
              suggested_chips: suggestedChips,
              cards: [],
              session_patch: {},
              events: [],
            });
            return sendChatEnvelope(envelope);
          }

          if (!rawBudget) {
            const envelope = buildEnvelope(ctx, {
              assistant_message: makeChatAssistantMessage(buildBudgetGatePrompt(ctx.lang)),
              suggested_chips: buildBudgetGateChips(ctx.lang),
              cards: [
                {
                  card_id: `budget_${ctx.request_id}`,
                  type: 'budget_gate',
                  payload: { reason: 'budget_optimization_optional', profile: summarizeProfileForContext(profile) },
                },
              ],
              session_patch: stateChangeAllowed(ctx.trigger_source) ? { next_state: 'S6_BUDGET' } : {},
              events: [makeEvent(ctx, 'state_entered', { next_state: 'S6_BUDGET', reason: 'budget_optimization_optional' })],
            });
            return sendChatEnvelope(envelope);
          }

          if (!profile || profile.budgetTier !== rawBudget) {
            profile = { ...(profile || {}), budgetTier: rawBudget };
            try {
              profile = await upsertProfileForIdentity({ auroraUid: identity.auroraUid, userId: identity.userId }, { budgetTier: rawBudget });
            } catch (err) {
              logger?.warn({ err: err.code || err.message }, 'aurora bff: failed to persist budgetTier');
            }
          }

          const { norm, suggestedChips } = await generateRoutineReco({
            ctx,
            profile,
            recentLogs,
            focus: 'daily routine',
            constraints: { simplicity: 'high' },
            includeAlternatives,
            logger,
          });

          const hasRecs = Array.isArray(norm.payload.recommendations) && norm.payload.recommendations.length > 0;
          const nextState = hasRecs && stateChangeAllowed(ctx.trigger_source) ? 'S7_PRODUCT_RECO' : undefined;
          const payload = !debugUpstream ? stripInternalRefsDeep(norm.payload) : norm.payload;

          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(
              ctx.lang === 'CN'
                ? ' AM/PM routine'
                : 'Got it. I generated a simple AM/PM routine (see the card below).',
            ),
            suggested_chips: suggestedChips,
            cards: [
              {
                card_id: `reco_${ctx.request_id}`,
                type: 'recommendations',
                payload,
                ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
              },
            ],
            session_patch: nextState ? { next_state: nextState } : {},
            events: [
              makeEvent(ctx, 'value_moment', { kind: 'routine_generated' }),
              makeEvent(ctx, 'recos_requested', { explicit: true }),
            ],
          });
          return sendChatEnvelope(envelope);
        }
      }

      // If user explicitly asks to build an AM/PM routine, generate it first.
      // Budget refinement is optional and can be done after showing a usable plan.
      if (
        allowRecoCards &&
        looksLikeRoutineRequest(message, parsed.data.action) &&
        recoInteractionAllowed
      ) {
        const budget = normalizeBudgetHint(profile && profile.budgetTier);

        const { norm, suggestedChips } = await generateRoutineReco({
          ctx,
          profile,
          recentLogs,
          focus: 'daily routine',
          constraints: { simplicity: 'high' },
          includeAlternatives,
          logger,
        });

        const hasRecs = Array.isArray(norm.payload.recommendations) && norm.payload.recommendations.length > 0;
        const nextState = hasRecs && stateChangeAllowed(ctx.trigger_source) ? 'S7_PRODUCT_RECO' : undefined;
        const payload = !debugUpstream ? stripInternalRefsDeep(norm.payload) : norm.payload;
        const nextChips = Array.isArray(suggestedChips) ? [...suggestedChips] : [];
        if (!budget) nextChips.push(buildBudgetOptimizationEntryChip(ctx.lang));

        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(
            !budget
              ? ctx.lang === 'CN'
                ? ' AM/PM routine'
                : 'I generated a simple AM/PM routine first (efficacy + tolerance prioritized). If you want, I can optimize it by budget next.'
              : ctx.lang === 'CN'
                ? ' AM/PM routine'
                : 'I generated a simple AM/PM routine (see the card below).',
          ),
          suggested_chips: nextChips,
          cards: [
            {
              card_id: `reco_${ctx.request_id}`,
              type: 'recommendations',
              payload,
              ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
            },
          ],
          session_patch: nextState ? { next_state: nextState } : {},
          events: [
            makeEvent(ctx, 'value_moment', { kind: 'routine_generated' }),
            makeEvent(ctx, 'recos_requested', { explicit: true }),
          ],
        });
        return sendChatEnvelope(envelope);
      }

      const budgetClarificationAction =
        !forceUpstreamAfterPendingAbandon && isBudgetClarificationAction(actionId, clarificationId);
      const budgetChipCanContinueReco =
        budgetClarificationAction &&
        ctx.state === 'S6_BUDGET';
      const profileClarificationAction =
        !forceUpstreamAfterPendingAbandon &&
        Boolean(appliedProfilePatch && Object.keys(appliedProfilePatch).length > 0) &&
        (String(actionId || '').trim().toLowerCase().startsWith('chip.clarify.') || Boolean(clarificationId));
      const budgetChipOutOfFlow =
        budgetClarificationAction &&
        !budgetChipCanContinueReco &&
        isBareBudgetSelectionMessage(message) &&
        !looksLikeRecommendationRequest(message) &&
        !looksLikeSuitabilityRequest(message) &&
        !looksLikeRoutineRequest(message, parsed.data.action) &&
        !looksLikeCompatibilityOrConflictQuestion(message) &&
        !looksLikeWeatherOrEnvironmentQuestion(message);

      // Guardrail for stale budget chips:
      // if the client sends a leftover budget clarify action outside budget/reco flow, do not call upstream
      // and do not emit the confusing parse-only stub fallback.
      if (budgetChipOutOfFlow) {
        const lang = ctx.lang === 'CN' ? 'CN' : 'EN';
        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(
            lang === 'CN'
              ? ' /  / '
              : 'Budget noted. What should I do next? (evaluate one product / get recommendations / check conflicts)',
          ),
          suggested_chips: [
            {
              chip_id: 'chip.action.analyze_product',
              label: lang === 'CN' ? '' : 'Evaluate one product',
              kind: 'quick_reply',
              data: { reply_text: lang === 'CN' ? '<>' : 'Is this suitable for me: <product name>' },
            },
            {
              chip_id: 'chip.start.reco_products',
              label: lang === 'CN' ? '' : 'Get recommendations',
              kind: 'quick_reply',
              data: { reply_text: lang === 'CN' ? '' : 'Get product recommendations' },
            },
            {
              chip_id: 'chip.action.dupe_compare',
              label: lang === 'CN' ? '' : 'Check compatibility',
              kind: 'quick_reply',
              data: {
                reply_text:
                  lang === 'CN' ? '/A + ' : 'Can I use retinoid + acids in the same night?',
              },
            },
          ],
          cards: [
            {
              card_id: `profile_${ctx.request_id}`,
              type: 'profile',
              payload: { profile: summarizeProfileForContext(profile) },
            },
          ],
          session_patch: {},
          events: [makeEvent(ctx, 'state_entered', { next_state: ctx.state || 'idle', reason: 'stale_budget_chip_ignored' })],
        });
        return sendChatEnvelope(envelope);
      }

      // If user explicitly asks for product recommendations (via chip OR explicit free text), generate them deterministically
      // (some upstream chat flows only return clarifying chips without a recommendations card).
      const wantsProductRecommendations =
        !forceUpstreamAfterPendingAbandon &&
        allowRecoCards &&
        !looksLikeIngredientScienceIntent(message, parsed.data.action) &&
        !looksLikeRoutineRequest(message, parsed.data.action) &&
        !looksLikeSuitabilityRequest(message) &&
        recoInteractionAllowed &&
        (
          actionId === 'chip.start.reco_products' ||
          actionId === 'chip_get_recos' ||
          budgetChipCanContinueReco ||
          profileClarificationAction ||
          looksLikeRecommendationRequest(message)
        );

      if (wantsProductRecommendations) {
        recordAuroraSkinFlowMetric({ stage: 'reco_request', hit: true });
        const { score: profileScore, missing: profileMissing } = profileCompleteness(profile);
        const hardRequiredFields = ['skinType', 'sensitivity', 'barrierStatus', 'goals'];
        const hardRequiredMissing = hardRequiredFields.filter((field) =>
          Array.isArray(profileMissing) ? profileMissing.includes(field) : false,
        );

        // Diagnosis-first gate: if profile is incomplete, do NOT generate recommendations yet.
        // This applies regardless of the current state; otherwise users see weakly-related recos before core profile.
        if (hardRequiredMissing.length > 0) {
          const required = hardRequiredMissing;
          const prompt = buildDiagnosisPrompt(ctx.lang, required);
          const chips = buildDiagnosisChips(ctx.lang, required);
          const nextState = stateChangeAllowed(ctx.trigger_source) ? 'S2_DIAGNOSIS' : undefined;
          const sessionPatch = nextState ? { next_state: nextState } : {};
          if (AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED) {
            const pendingFromGate = buildPendingClarificationForGate({
              language: ctx.lang,
              missing: required,
              message,
              wants: 'recommendation',
            });
            if (pendingFromGate) emitPendingClarificationPatch(sessionPatch, pendingFromGate);
          }

          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(prompt),
            suggested_chips: chips,
            cards: [
              {
                card_id: `diag_${ctx.request_id}`,
                type: 'diagnosis_gate',
                payload: {
                  reason: 'diagnosis_first',
                  missing_fields: required,
                  wants: 'recommendation',
                  profile: summarizeProfileForContext(profile),
                  recent_logs: recentLogs,
                },
              },
            ],
            session_patch: sessionPatch,
            events: [
              makeEvent(ctx, 'recos_requested', { explicit: true, gated: true, reason: 'diagnosis_first' }),
              makeEvent(ctx, 'state_entered', { next_state: nextState || null, reason: 'diagnosis_first' }),
            ],
          });
          return sendChatEnvelope(envelope);
        }

        const refinementMissing = (Array.isArray(profileMissing) ? profileMissing : []).filter(
          (f) => f === 'skinType' || f === 'sensitivity',
        );
        const refinementChips = refinementMissing.length ? buildDiagnosisChips(ctx.lang, refinementMissing) : [];

        const safety = evaluateSafetyBoundary({
          message,
          profile,
          language: ctx.lang,
        });
        if (safety.block) {
          logger?.info({ kind: 'metric', name: 'aurora.skin.safety_block_rate', value: 1 }, 'metric');
          recordAuroraSkinFlowMetric({ stage: 'reco_safety_block', hit: true });
          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(safety.assistant_message),
            suggested_chips: [],
            cards: [
              {
                card_id: `conf_${ctx.request_id}`,
                type: 'confidence_notice',
                payload: buildConfidenceNoticeCardPayload({
                  language: ctx.lang,
                  reason: 'safety_block',
                  confidence: { score: 0, level: 'low', rationale: ['medical_boundary'] },
                  severity: 'block',
                  details: safety.notice_bullets,
                }),
              },
            ],
            session_patch: {},
            events: [
              makeEvent(ctx, 'recos_requested', { explicit: true, blocked: true, reason: 'safety_boundary' }),
            ],
          });
          return sendChatEnvelope(envelope);
        }

        const preferredArtifactId = extractLatestArtifactIdFromSession(parsed.data.session);
        let latestArtifact = null;
        let artifactLookupError = null;
        try {
          latestArtifact = await getLatestDiagnosisArtifact({
            auroraUid: identity.auroraUid,
            userId: identity.userId,
            sessionId: ctx.brief_id || null,
            maxAgeDays: 30,
            preferArtifactId: preferredArtifactId,
          });
        } catch (err) {
          artifactLookupError = err;
          logger?.warn(
            { err: err && err.message ? err.message : String(err), request_id: ctx.request_id },
            'aurora bff: failed to load latest diagnosis artifact',
          );
        }

        const latestArtifactForGate =
          latestArtifact &&
          latestArtifact.artifact_json &&
          typeof latestArtifact.artifact_json === 'object'
            ? {
                ...latestArtifact.artifact_json,
                artifact_id: latestArtifact.artifact_id,
                created_at: latestArtifact.created_at || latestArtifact.artifact_json.created_at,
              }
            : latestArtifact;

        const artifactGate = hasUsableArtifactForRecommendations(latestArtifactForGate);
        if (AURORA_PRODUCT_MATCHER_ENABLED && !artifactGate.ok) {
          const chips = buildRecoEntryChips(ctx.lang);
          const nextState = stateChangeAllowed(ctx.trigger_source) ? 'S2_DIAGNOSIS' : undefined;
          const sessionPatch = nextState ? { next_state: nextState } : {};
          const envelope = buildEnvelope(ctx, {
            assistant_message: makeChatAssistantMessage(
              ctx.lang === 'CN'
                ? ' daylight + indoor_white'
                : 'I need a diagnosis result first (upload daylight + indoor_white photos, or run a low-confidence baseline) before personalized recommendations.',
            ),
            suggested_chips: [...refinementChips, ...chips].slice(0, 8),
            cards: [
              {
                card_id: `conf_${ctx.request_id}`,
                type: 'confidence_notice',
                payload: buildConfidenceNoticeCardPayload({
                  language: ctx.lang,
                  reason: 'artifact_missing',
                  confidence: { score: 0, level: 'low', rationale: ['artifact_not_found'] },
                  actions: ['upload_daylight_and_indoor_white', 'run_low_confidence_baseline'],
                  details: artifactLookupError ? [String(artifactLookupError.message || artifactLookupError)] : [],
                }),
              },
            ],
            session_patch: sessionPatch,
            events: [
              makeEvent(ctx, 'recos_requested', { explicit: true, gated: true, reason: 'artifact_missing' }),
            ],
          });
          return sendChatEnvelope(envelope);
        }

        let mappedIngredientPlan = null;
        if (latestArtifact && AURORA_INGREDIENT_PLAN_ENABLED) {
          const latestArtifactId = String(latestArtifact.artifact_id || '').trim();
          try {
            const existingPlan = latestArtifactId
              ? await getIngredientPlanByArtifactId({ artifactId: latestArtifactId })
              : null;
            if (existingPlan && existingPlan.plan_json && typeof existingPlan.plan_json === 'object') {
              mappedIngredientPlan = {
                ...existingPlan.plan_json,
                plan_id: existingPlan.plan_id,
                created_at: existingPlan.created_at || existingPlan.plan_json.created_at,
              };
            } else {
              const builtPlan = buildIngredientPlan({ artifact: latestArtifact.artifact_json || latestArtifact, profile });
              if (latestArtifactId) {
                const savedPlan = await saveIngredientPlan({
                  artifactId: latestArtifactId,
                  auroraUid: identity.auroraUid,
                  userId: identity.userId,
                  plan: builtPlan,
                });
                mappedIngredientPlan = savedPlan && savedPlan.plan_json && typeof savedPlan.plan_json === 'object'
                  ? {
                      ...savedPlan.plan_json,
                      plan_id: savedPlan.plan_id,
                      created_at: savedPlan.created_at || savedPlan.plan_json.created_at,
                    }
                  : builtPlan;
              } else {
                mappedIngredientPlan = builtPlan;
              }
            }
          } catch (err) {
            logger?.warn(
              { err: err && err.message ? err.message : String(err), request_id: ctx.request_id },
              'aurora bff: ingredient plan lookup/build failed',
            );
          }
        }

        let matcherBundle = null;
        let matcherPayload = null;
        const artifactConfidenceLevel = artifactGate && artifactGate.confidence_level ? artifactGate.confidence_level : 'low';
        const lowConfidenceArtifact = artifactConfidenceLevel === 'low';

        if (AURORA_PRODUCT_MATCHER_ENABLED && latestArtifact) {
          try {
            const artifactPayload = latestArtifact.artifact_json && typeof latestArtifact.artifact_json === 'object'
              ? {
                  ...latestArtifact.artifact_json,
                  artifact_id: latestArtifact.artifact_id,
                  created_at: latestArtifact.created_at || latestArtifact.artifact_json.created_at,
                }
              : latestArtifact;
            const planForMatcher =
              mappedIngredientPlan ||
              buildIngredientPlan({ artifact: artifactPayload, profile: profile || {} });
            if (!mappedIngredientPlan) mappedIngredientPlan = planForMatcher;

            matcherBundle = buildProductRecommendationsBundle({
              ingredientPlan: planForMatcher,
              artifact: artifactPayload,
              profile,
              language: ctx.lang,
              disallowTreatment: lowConfidenceArtifact,
              catalogPath: DIAG_PRODUCT_CATALOG_PATH,
            });
            matcherPayload = toLegacyRecommendationsPayload(matcherBundle, { language: ctx.lang });
          } catch (err) {
            logger?.warn(
              { err: err && err.message ? err.message : String(err), request_id: ctx.request_id },
              'aurora bff: product matcher failed',
            );
          }
        }

        let norm = null;
        let upstreamDebug = null;
        let alternativesDebug = null;
        if (!matcherPayload || !Array.isArray(matcherPayload.recommendations) || matcherPayload.recommendations.length === 0) {
          const upstreamReco = await generateProductRecommendations({
            ctx,
            profile,
            recentLogs,
            message,
            includeAlternatives,
            debug: debugUpstream,
            logger,
          });
          norm = upstreamReco.norm;
          upstreamDebug = upstreamReco.upstreamDebug;
          alternativesDebug = upstreamReco.alternativesDebug;
        } else {
          norm = {
            payload: {
              ...matcherPayload,
              intent: 'reco_products',
              profile: summarizeProfileForContext(profile),
              source: 'artifact_matcher_v1',
            },
            field_missing: [],
          };
        }

        const hasRecs = Array.isArray(norm && norm.payload && norm.payload.recommendations)
          ? norm.payload.recommendations.length > 0
          : false;
        recordAuroraSkinFlowMetric({ stage: 'reco_generated', hit: Boolean(hasRecs) });
        if (hasRecs) {
          logger?.info({ kind: 'metric', name: 'aurora.skin.reco_generated_rate', value: 1 }, 'metric');
        }
        const nextState = hasRecs && stateChangeAllowed(ctx.trigger_source) ? 'S7_PRODUCT_RECO' : undefined;
        const payload = !debugUpstream ? stripInternalRefsDeep(norm.payload) : norm.payload;

        const recoAssistantBase = buildRouteAwareAssistantText({
          route: 'reco',
          payload,
          language: ctx.lang,
          profile,
        });
        const recoUnavailableLead = ctx.lang === 'CN'
          ? ''
          : "I couldn't fetch a complete purchasable shortlist from upstream, so here's a safe and actionable plan first.";

        const assistantTextRaw = hasRecs
          ? lowConfidenceArtifact
            ? (ctx.lang === 'CN'
              ? ' treatment daylight + indoor_white '
              : 'Current diagnosis confidence is low, so I prepared a gentle baseline and avoided high-irritation treatments. Retake daylight + indoor_white photos for better precision.')
            : (recoAssistantBase ||
              (ctx.lang === 'CN'
                ? profileScore >= 3
                  ? ''
                  : '//'
                : 'I summarized the key results into structured cards below.'))
          : (recoAssistantBase
            ? `${recoUnavailableLead}\n\n${recoAssistantBase}`
            : (ctx.lang === 'CN'
              ? '///'
              : "I couldn't get a structured product recommendation yet. Tell me what category you want (cleanser / serum / moisturizer / sunscreen), and Ill continue."));
        const assistantText = addEmotionalPreambleToAssistantText(assistantTextRaw, {
          language: ctx.lang,
          profile,
          seed: ctx.request_id,
        });

        const cards = [
          {
            card_id: `reco_${ctx.request_id}`,
            type: 'recommendations',
            payload,
            ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
          },
        ];
        if (mappedIngredientPlan) {
          cards.push(buildIngredientPlanCard(mappedIngredientPlan, ctx.request_id));
        }
        if (latestArtifact && lowConfidenceArtifact) {
          logger?.info({ kind: 'metric', name: 'aurora.skin.low_confidence_rate', value: 1 }, 'metric');
          recordAuroraSkinFlowMetric({ stage: 'reco_low_confidence', hit: true });
          const confNode =
            latestArtifact.artifact_json &&
            latestArtifact.artifact_json.overall_confidence &&
            typeof latestArtifact.artifact_json.overall_confidence === 'object'
              ? latestArtifact.artifact_json.overall_confidence
              : { score: 0.5, level: 'low', rationale: ['artifact_low_confidence'] };
          cards.push({
            card_id: `conf_${ctx.request_id}`,
            type: 'confidence_notice',
            payload: buildConfidenceNoticeCardPayload({
              language: ctx.lang,
              reason: 'low_confidence',
              confidence: confNode,
              actions: ['upload_daylight_and_indoor_white', 'update_current_routine'],
            }),
          });
        }

        if (debugUpstream && upstreamDebug) {
          cards.push({
            card_id: `aurora_debug_${ctx.request_id}`,
            type: 'aurora_debug',
            payload: upstreamDebug,
          });
          if (alternativesDebug) {
            cards.push({
              card_id: `aurora_alt_debug_${ctx.request_id}`,
              type: 'aurora_alt_debug',
              payload: { items: alternativesDebug },
            });
          }
        }

        const sessionPatch = nextState ? { next_state: nextState } : {};
        appendLatestArtifactToSessionPatch(sessionPatch, latestArtifact && latestArtifact.artifact_id);

        if (AURORA_PRODUCT_MATCHER_ENABLED && matcherBundle && latestArtifact) {
          try {
            await saveRecoRun({
              artifactId: latestArtifact.artifact_id,
              planId: mappedIngredientPlan && mappedIngredientPlan.plan_id ? mappedIngredientPlan.plan_id : null,
              auroraUid: identity.auroraUid,
              userId: identity.userId,
              requestContext: {
                request_id: ctx.request_id,
                trace_id: ctx.trace_id,
                trigger_source: ctx.trigger_source,
                low_confidence: lowConfidenceArtifact,
                source: 'artifact_matcher_v1',
              },
              reco: matcherBundle,
              overallConfidence:
                matcherBundle.confidence && Number.isFinite(Number(matcherBundle.confidence.score))
                  ? Number(matcherBundle.confidence.score)
                  : null,
            });
          } catch (err) {
            logger?.warn(
              { err: err && err.message ? err.message : String(err), request_id: ctx.request_id },
              'aurora bff: failed to persist reco run',
            );
          }
        }

        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(assistantText),
          suggested_chips: refinementChips,
          cards,
          session_patch: sessionPatch,
          events: [
            makeEvent(ctx, 'value_moment', { kind: 'product_reco' }),
            makeEvent(ctx, 'recos_requested', {
              explicit: true,
              source: matcherPayload ? 'artifact_matcher_v1' : 'upstream_fallback',
              low_confidence: lowConfidenceArtifact,
            }),
          ],
        });
        return sendChatEnvelope(envelope);
      }

      // If user just patched profile via chip/action, continue the diagnosis flow without calling upstream.
      // Clarification chips usually carry reply_text (for UX), so we must not require empty message here.
      const hasExplicitUserIntentMessage =
        looksLikeSuitabilityRequest(message) ||
        looksLikeCompatibilityOrConflictQuestion(message) ||
        looksLikeWeatherOrEnvironmentQuestion(message) ||
        looksLikeRecommendationRequest(message);

	      if (appliedProfilePatch && (!message || profileClarificationAction) && !hasExplicitUserIntentMessage) {
	        const inDiagnosisFlow =
	          String(agentState || '').startsWith('DIAG_') ||
	          String(ctx.state || '').startsWith('S2_') ||
	          String(ctx.state || '').startsWith('S3_') ||
	          profileClarificationAction;

	        const { score, missing } = profileCompleteness(profile);

	        const requiredCore = ['skinType', 'sensitivity', 'barrierStatus', 'goals'];
	        const missingCore = requiredCore.filter((k) => (Array.isArray(missing) ? missing.includes(k) : false));
	        const profileSummaryForPatch = summarizeProfileForContext(profile);
	        if (profileSummaryForPatch) {
	          recordSessionPatchProfileEmitted({ changed: true });
	        }

	        if (inDiagnosisFlow && missingCore.length) {
	          const prompt = buildDiagnosisPrompt(ctx.lang, missingCore);
	          const chips = buildDiagnosisChips(ctx.lang, missingCore);
	          const nextState = stateChangeAllowed(ctx.trigger_source) ? 'S2_DIAGNOSIS' : undefined;

	          const envelope = buildEnvelope(ctx, {
	            assistant_message: makeChatAssistantMessage(prompt),
	            suggested_chips: chips,
	            cards: [
              {
                card_id: `diag_${ctx.request_id}`,
                type: 'diagnosis_gate',
                payload: {
                  reason: 'diagnosis_progress',
                  missing_fields: missingCore,
                  wants: 'diagnosis',
                  profile: summarizeProfileForContext(profile),
                  recent_logs: recentLogs,
                },
              },
            ],
            session_patch: nextState
              ? { next_state: nextState, profile: profileSummaryForPatch }
              : { profile: profileSummaryForPatch },
            events: [
              makeEvent(ctx, 'profile_saved', { fields: Object.keys(appliedProfilePatch) }),
              makeEvent(ctx, 'state_entered', { next_state: nextState || null, reason: 'diagnosis_progress' }),
            ],
          });
          return sendChatEnvelope(envelope);
        }

        const lang = ctx.lang === 'CN' ? 'CN' : 'EN';
        const suggestedChips = [
          {
            chip_id: 'chip.action.reco_routine',
            label: lang === 'CN' ? ' routine' : 'Build an AM/PM routine',
            kind: 'quick_reply',
            data: { reply_text: lang === 'CN' ? ' routine' : 'Build an AM/PM skincare routine' },
          },
          {
            chip_id: 'chip.action.analyze_product',
            label: lang === 'CN' ? '' : 'Evaluate a specific product',
            kind: 'quick_reply',
            data: { reply_text: lang === 'CN' ? '' : 'Evaluate a specific product for me' },
          },
          {
            chip_id: 'chip.action.dupe_compare',
            label: lang === 'CN' ? '/' : 'Find dupes / alternatives',
            kind: 'quick_reply',
            data: { reply_text: lang === 'CN' ? ' tradeoffs' : 'Find dupes and compare tradeoffs' },
          },
        ];

        const envelope = buildEnvelope(ctx, {
          assistant_message: makeChatAssistantMessage(
            lang === 'CN'
              ? ''
              : 'Got it. What would you like to do next?',
          ),
          suggested_chips: suggestedChips,
          cards: [
            {
              card_id: `profile_${ctx.request_id}`,
              type: 'profile',
              payload: { profile: summarizeProfileForContext(profile) },
            },
          ],
          session_patch: { profile: profileSummaryForPatch },
          events: [makeEvent(ctx, 'profile_saved', { fields: Object.keys(appliedProfilePatch) })],
        });
        return sendChatEnvelope(envelope);
      }

      let upstream = null;
      const profileSummary = summarizeProfileForContext(profile);
      const historyForPrefix = Array.isArray(clarificationHistoryForUpstream) ? clarificationHistoryForUpstream : [];
      if (historyForPrefix.length) {
        recordClarificationHistorySent({ count: historyForPrefix.length });
      }
      const prefix = buildContextPrefix({
        profile: profileSummary,
        recentLogs,
        lang: ctx.lang,
        state: ctx.state,
        agent_state: agentState,
        trigger_source: ctx.trigger_source,
        action_id: parsed.data.action && typeof parsed.data.action === 'object' ? parsed.data.action.action_id : null,
        clarification_id: clarificationId,
        ...(historyForPrefix.length ? { clarification_history: historyForPrefix } : {}),
      });
      const query = `${prefix}${upstreamMessage || '(no message)'}`;
      const isResumeUpstreamCall = Boolean(
        AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED &&
          forceUpstreamAfterPendingAbandon &&
          resumeContextForUpstream &&
          typeof resumeContextForUpstream === 'object',
      );
      const resumePrefixEnabledForCall = Boolean(
        isResumeUpstreamCall &&
          (AURORA_CHAT_RESUME_PREFIX_V2_ENABLED || AURORA_CHAT_RESUME_PREFIX_V1_ENABLED),
      );
      const resumeContextForCall = isResumeUpstreamCall
        ? {
            ...resumeContextForUpstream,
            enabled: resumePrefixEnabledForCall,
            template_version: AURORA_CHAT_RESUME_PREFIX_V2_ENABLED ? 'v2' : 'v1',
          }
        : null;
      if (isResumeUpstreamCall) {
        const resumePrefixHistoryCount =
          resumePrefixEnabledForCall &&
          resumeContextForCall &&
          resumeContextForCall.include_history !== false &&
          Array.isArray(resumeContextForCall.clarification_history)
            ? Math.min(6, resumeContextForCall.clarification_history.length)
            : 0;
        recordResumePrefixInjected({ enabled: resumePrefixEnabledForCall });
        recordResumePrefixHistoryItems({ count: resumePrefixHistoryCount });
      }
      const upstreamStartedAt = Date.now();
      try {
        upstream = await auroraChat({
          baseUrl: AURORA_DECISION_BASE_URL,
          query,
          timeoutMs: AURORA_CHAT_UPSTREAM_TIMEOUT_MS,
          debug: debugUpstream,
          allow_recommendations: allowRecoCards,
          ...(llmProvider ? { llm_provider: llmProvider } : {}),
          ...(llmModel ? { llm_model: llmModel } : {}),
          ...(anchorProductId ? { anchor_product_id: anchorProductId } : {}),
          ...(anchorProductUrl ? { anchor_product_url: anchorProductUrl } : {}),
          ...(upstreamMessages && upstreamMessages.length ? { messages: upstreamMessages } : {}),
          ...(isResumeUpstreamCall && resumeContextForCall ? { resume_context: resumeContextForCall } : {}),
        });
        recordUpstreamCall({ path: 'aurora_chat', status: 'ok' });
      } catch (err) {
        recordUpstreamCall({ path: 'aurora_chat', status: 'error' });
        if (err.code !== 'AURORA_NOT_CONFIGURED') {
          logger?.warn({ err: err.message }, 'aurora bff: aurora upstream failed');
        }
      } finally {
        observeUpstreamLatency({ path: 'aurora_chat', latencyMs: Date.now() - upstreamStartedAt });
      }

      const answer = upstream && typeof upstream.answer === 'string'
        ? upstream.answer
        : ctx.lang === 'CN'
          ? 'Aurora '
          : '(Received. Aurora upstream is unavailable or not configured; returning a gated/memory-aware fallback response.)';
      const llmRouteMeta = {
        llm_provider_requested: llmProvider || null,
        llm_model_requested: llmModel || null,
        llm_provider_effective:
          upstream && typeof upstream.llm_provider === 'string' ? String(upstream.llm_provider || '').trim() || null : null,
        llm_model_effective:
          upstream && typeof upstream.llm_model === 'string' ? String(upstream.llm_model || '').trim() || null : null,
      };
      const hasLlmRouteMeta = Boolean(
        llmRouteMeta.llm_provider_requested ||
          llmRouteMeta.llm_model_requested ||
          llmRouteMeta.llm_provider_effective ||
          llmRouteMeta.llm_model_effective,
      );
      if (hasAnyLlmRouteMeta(llmRouteMeta)) {
        llmRouteMetaForResponse = llmRouteMeta;
      }

      if (isResumeUpstreamCall && AURORA_CHAT_RESUME_PROBE_METRICS_ENABLED) {
        const resumeMode = classifyResumeResponseMode(answer);
        recordResumeResponseMode({ mode: resumeMode });
        const knownProfileFieldsForProbe = buildResumeKnownProfileFields(profileSummary);
        const reaskFields = detectResumePlaintextReaskFields(answer, knownProfileFieldsForProbe);
        for (const field of reaskFields) {
          recordResumePlaintextReaskDetected({ field });
        }
      }

      const rawCards = upstream && Array.isArray(upstream.cards) ? upstream.cards : [];
      const allowRecs = allowRecoCards;
      let cards = allowRecs ? rawCards : stripRecommendationCards(rawCards);
      const fieldMissing = [];
      if (!allowRecs && rawCards.length !== cards.length) {
        fieldMissing.push({ field: 'cards', reason: 'recommendations_not_requested' });
      }

      if (allowRecs && includeAlternatives && Array.isArray(cards) && cards.length) {
        const recoIdx = cards.findIndex((c) => {
          if (!c || typeof c !== 'object') return false;
          const t = typeof c.type === 'string' ? c.type.trim().toLowerCase() : '';
          if (t !== 'recommendations') return false;
          const payload = c.payload && typeof c.payload === 'object' ? c.payload : null;
          return payload && Array.isArray(payload.recommendations);
        });

        if (recoIdx !== -1) {
          const card = cards[recoIdx];
          const basePayload = card.payload && typeof card.payload === 'object' ? card.payload : {};
          const alt = await enrichRecommendationsWithAlternatives({
            ctx,
            profileSummary,
            recentLogs,
            recommendations: basePayload.recommendations,
            logger,
          });
          const nextCard = {
            ...card,
            payload: { ...basePayload, recommendations: alt.recommendations },
            field_missing: mergeFieldMissing(card.field_missing, alt.field_missing),
          };
          cards = cards.map((c, i) => (i === recoIdx ? nextCard : c));
        }
      }

      const clarification = upstream && upstream.clarification && typeof upstream.clarification === 'object'
        ? upstream.clarification
        : null;
      recordClarificationPresent({ present: Boolean(clarification) });

      const clarificationQuestions = filterClarificationQuestionsForChips({
        clarification,
        profileSummary,
        filterKnown: AURORA_CHAT_CLARIFICATION_FILTER_KNOWN_ENABLED,
      });

      let pendingClarificationFromUpstream = null;
      const suggestedChips = [];
      if (clarificationQuestions[0]) {
        const q0 = clarificationQuestions[0];
        const qid = String(q0.id || 'clarify').trim() || 'clarify';
        const repeatedField = (() => {
          const field = normalizeClarificationField(qid);
          return hasKnownClarificationFieldValue(profileSummary, field) ? field : null;
        })();
        if (repeatedField) recordRepeatedClarifyField({ field: repeatedField });

        if (AURORA_CHAT_CLARIFICATION_FLOW_V2_ENABLED && clarificationQuestions.length > 1) {
          const resumeUserText = String(upstreamMessage || message || '(no message)').trim() || '(no message)';
          const seededPending = sanitizePendingClarification(
            {
              v: PENDING_CLARIFICATION_SCHEMA_V1,
              flow_id: makeFlowId(),
              created_at_ms: Date.now(),
              resume_user_text: resumeUserText,
              step_index: 0,
              current: { id: qid },
              queue: clarificationQuestions.slice(1).map((q) => ({
                id: String(q.id || 'clarify'),
                question: String(q.question || ''),
                options: Array.isArray(q.options) ? q.options : [],
              })),
              history: [],
            },
            { recordMetrics: true },
          );
          if (seededPending && seededPending.pending && seededPending.pending.queue.length > 0) {
            pendingClarificationFromUpstream = seededPending.pending;
            recordClarificationFlowV2Started();
          }
        }
        suggestedChips.push(...buildChipsForQuestion(q0, { stepIndex: 1 }));
      }

      const contextRaw = upstream && upstream.context && typeof upstream.context === 'object' ? upstream.context : null;
      const derivedCards = [];
      let heatmapImpressionEvent = null;
      const responseIntentMessage = upstreamMessage || message;
      const envStressActionRequested = typeof actionId === 'string' && /env[_-]?stress|environment[_-]?stress|weather|itinerary/i.test(actionId);
      const looksEnv = looksLikeWeatherOrEnvironmentQuestion(responseIntentMessage);
      const wantsEnvStressCard = Boolean(debugUpstream) || envStressActionRequested || looksEnv;

      const isEnvStressCard = (card) => {
        if (!card || typeof card !== 'object') return false;
        const t = typeof card.type === 'string' ? card.type.trim().toLowerCase() : '';
        if (/^(env_stress|environment_stress|envstress|environmentstress)$/.test(t)) return true;
        if (t.includes('env') && t.includes('stress')) return true;
        const payload = card.payload && typeof card.payload === 'object' ? card.payload : null;
        const schema = payload && typeof payload.schema_version === 'string' ? payload.schema_version.trim() : '';
        if (schema === 'aurora.ui.env_stress.v1' || schema === 'aurora.env_stress.v1') return true;
        return false;
      };

      if (!wantsEnvStressCard && Array.isArray(cards) && cards.length) {
        const before = cards.length;
        cards = cards.filter((c) => !isEnvStressCard(c));
        if (before !== cards.length) fieldMissing.push({ field: 'cards.env_stress', reason: 'not_requested' });
      }

      let envStressUi = null;
      if (contextRaw) {
        const envStressRaw = isPlainObject(contextRaw.env_stress) ? contextRaw.env_stress : isPlainObject(contextRaw.envStress) ? contextRaw.envStress : null;
        envStressUi = buildEnvStressUiModelFromUpstream(envStressRaw, { language: ctx.lang });
      }
      if (!envStressUi && (envStressActionRequested || looksEnv)) {
        envStressUi = buildEnvStressUiModelFromLocal({ profile, recentLogs, message: responseIntentMessage, language: ctx.lang });
      }
      if (envStressUi && wantsEnvStressCard) {
        derivedCards.push({
          card_id: `env_${ctx.request_id}`,
          type: 'env_stress',
          payload: envStressUi,
        });
      }

      if (contextRaw) {
        const conflictDetector = isPlainObject(contextRaw.conflict_detector)
          ? contextRaw.conflict_detector
          : isPlainObject(contextRaw.conflictDetector)
            ? contextRaw.conflictDetector
            : null;
        const wantsConflictCards =
          Boolean(debugUpstream) ||
          looksLikeCompatibilityOrConflictQuestion(responseIntentMessage) ||
          (typeof actionId === 'string' && /(routine|compat|conflict|heatmap)/i.test(actionId)) ||
          (conflictDetector && conflictDetector.safe === false) ||
          (Array.isArray(conflictDetector && conflictDetector.conflicts) && conflictDetector.conflicts.length > 0);

        if (wantsConflictCards && conflictDetector && typeof conflictDetector.safe === 'boolean') {
          derivedCards.push({
            card_id: `conflicts_${ctx.request_id}`,
            type: 'routine_simulation',
            payload: conflictDetector,
          });
          const heatmapSteps = extractHeatmapStepsFromConflictDetector({ conflictDetector, contextRaw });
          const heatmapPayload = CONFLICT_HEATMAP_V1_ENABLED
            ? buildConflictHeatmapV1({ routineSimulation: conflictDetector, routineSteps: heatmapSteps })
            : { schema_version: 'aurora.ui.conflict_heatmap.v1' };
          derivedCards.push({
            card_id: `heatmap_${ctx.request_id}`,
            type: 'conflict_heatmap',
            payload: heatmapPayload,
          });
          if (CONFLICT_HEATMAP_V1_ENABLED) {
            heatmapImpressionEvent = makeEvent(ctx, 'aurora_conflict_heatmap_impression', {
              schema_version: heatmapPayload.schema_version,
              state: heatmapPayload.state,
              num_steps: Array.isArray(heatmapPayload.axes?.rows?.items) ? heatmapPayload.axes.rows.items.length : 0,
              num_cells_nonzero: Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items.length : 0,
              num_unmapped_conflicts: Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts.length : 0,
              max_severity: Math.max(
                0,
                ...((Array.isArray(heatmapPayload.cells?.items) ? heatmapPayload.cells.items : []).map((c) => Number(c?.severity) || 0)),
                ...((Array.isArray(heatmapPayload.unmapped_conflicts) ? heatmapPayload.unmapped_conflicts : []).map((c) => Number(c?.severity) || 0)),
              ),
              routine_simulation_safe: Boolean(conflictDetector.safe),
              routine_conflict_count: Array.isArray(conflictDetector.conflicts) ? conflictDetector.conflicts.length : 0,
              trigger_source: ctx.trigger_source,
            });
          }
        }
      }

      // Product suitability derived card: if upstream provides an anchor product context (common for "/" flows),
      // emit a renderable `product_analysis` card (UI expects this, not the raw context blob).
      const anchorFromContext = (() => {
        if (!contextRaw) return null;
        if (isPlainObject(contextRaw.anchor)) return contextRaw.anchor;
        if (isPlainObject(contextRaw.anchor_product)) return contextRaw.anchor_product;
        if (isPlainObject(contextRaw.anchorProduct)) return contextRaw.anchorProduct;
        return null;
      })();

      const mapAnchorContextToProductAnalysis = (anchor, { lang, profileSummary: profileSummaryOpt } = {}) => {
        const a = isPlainObject(anchor) ? anchor : {};
        const outLang = String(lang || '').toUpperCase() === 'CN' ? 'CN' : 'EN';
        const p = isPlainObject(profileSummaryOpt) ? profileSummaryOpt : null;

        const uniqStrings = (items, max = null) => {
          const out = [];
          const seen = new Set();
          for (const raw of Array.isArray(items) ? items : []) {
            const s = typeof raw === 'string' ? raw.trim() : raw == null ? '' : String(raw).trim();
            if (!s) continue;
            const key = s.toLowerCase();
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(s);
            if (typeof max === 'number' && max > 0 && out.length >= max) break;
          }
          return out;
        };

        const brand = typeof a.brand === 'string' ? a.brand.trim() : '';
        const name = typeof a.name === 'string' ? a.name.trim() : '';
        const productId = typeof a.id === 'string' ? a.id.trim() : typeof a.product_id === 'string' ? a.product_id.trim() : '';
        const displayName = [brand, name].filter(Boolean).join(' ').trim() || (typeof a.display_name === 'string' ? a.display_name.trim() : '');

        const score = isPlainObject(a.score) ? a.score : {};
        const scoreTotal = coerceNumber(score.total);
        const scoreScience = coerceNumber(score.science);
        const scoreSocial = coerceNumber(score.social);
        const scoreEng = coerceNumber(score.engineering);

        const social = isPlainObject(a.social) ? a.social : {};
        const redScore = coerceNumber(social.red_score ?? social.redScore);
        const redditScore = coerceNumber(social.reddit_score ?? social.redditScore);
        const burnRate = coerceNumber(social.burn_rate ?? social.burnRate);
        const topKeywords = Array.isArray(social.top_keywords) ? social.top_keywords : Array.isArray(social.topKeywords) ? social.topKeywords : [];

        const kb = isPlainObject(a.kb_profile) ? a.kb_profile : isPlainObject(a.kbProfile) ? a.kbProfile : {};
        const keyActives = Array.isArray(kb.keyActives) ? kb.keyActives : [];
        const comparisonNotes = Array.isArray(kb.comparisonNotes) ? kb.comparisonNotes : [];
        const sensitivityFlags = Array.isArray(kb.sensitivityFlags) ? kb.sensitivityFlags : [];
        const pairingRules = Array.isArray(kb.pairingRules) ? kb.pairingRules : [];
        const textureFinish = Array.isArray(kb.textureFinish) ? kb.textureFinish : [];

        const expert = isPlainObject(a.expert_knowledge) ? a.expert_knowledge : isPlainObject(a.expertKnowledge) ? a.expertKnowledge : {};
        const chemistNotes = typeof expert.chemist_notes === 'string' ? expert.chemist_notes : typeof expert.chemistNotes === 'string' ? expert.chemistNotes : '';
        const sensitivityNotes =
          typeof expert.sensitivity_notes === 'string'
            ? expert.sensitivity_notes
            : typeof expert.sensitivityNotes === 'string'
              ? expert.sensitivityNotes
              : '';

        const riskFlags = uniqStrings([
          ...(Array.isArray(a.risk_flags_canonical) ? a.risk_flags_canonical : []),
          ...(Array.isArray(a.risk_flags) ? a.risk_flags : []),
          ...(Array.isArray(sensitivityFlags) ? sensitivityFlags : []),
        ].map((x) => String(x || '').trim()).filter(Boolean));

        const vetoed = Boolean(a.vetoed);
        const verdict = (() => {
          if (vetoed) return outLang === 'CN' ? '' : 'Avoid';
          if (riskFlags.some((f) => /high_irritation/i.test(f))) return outLang === 'CN' ? '' : 'Caution';
          if (scoreTotal != null && scoreTotal < 55) return outLang === 'CN' ? '' : 'Caution';
          return outLang === 'CN' ? '' : 'Suitable';
        })();

        const take = (arr, n) => (Array.isArray(arr) ? arr.filter(Boolean).slice(0, n) : []);
        const truncate = (s, max = 200) => {
          const t = typeof s === 'string' ? s.trim() : s == null ? '' : String(s).trim();
          if (!t) return '';
          return t.length > max ? `${t.slice(0, max - 1)}` : t;
        };

        const normalizeProfileEnum = (v) => {
          const s = typeof v === 'string' ? v.trim().toLowerCase() : '';
          return s || null;
        };
        const profileSkinType = normalizeProfileEnum(p?.skinType);
        const profileSensitivity = normalizeProfileEnum(p?.sensitivity);
        const profileBarrier = normalizeProfileEnum(p?.barrierStatus);
        const profileGoals = Array.isArray(p?.goals) ? p.goals.map((g) => normalizeProfileEnum(g)).filter(Boolean) : [];

        const profileTags = (() => {
          if (!p) return [];
          const tags = [];

          const skinTypeLabel = (() => {
            if (!profileSkinType) return null;
            if (outLang === 'CN') {
              if (profileSkinType === 'oily') return '';
              if (profileSkinType === 'dry') return '';
              if (profileSkinType === 'combo' || profileSkinType === 'combination') return '';
              if (profileSkinType === 'normal') return '';
              if (profileSkinType === 'sensitive') return '';
              return `${profileSkinType}`;
            }
            if (profileSkinType === 'combo' || profileSkinType === 'combination') return 'combination';
            return profileSkinType;
          })();

          const sensitivityLabel = (() => {
            if (!profileSensitivity) return null;
            if (outLang === 'CN') {
              if (profileSensitivity === 'low') return '';
              if (profileSensitivity === 'medium') return '';
              if (profileSensitivity === 'high') return '';
              return `${profileSensitivity}`;
            }
            if (profileSensitivity === 'low') return 'low sensitivity';
            if (profileSensitivity === 'medium') return 'medium sensitivity';
            if (profileSensitivity === 'high') return 'high sensitivity';
            return `sensitivity=${profileSensitivity}`;
          })();

          const barrierLabel = (() => {
            if (!profileBarrier) return null;
            if (outLang === 'CN') {
              if (profileBarrier === 'healthy') return '';
              if (profileBarrier === 'impaired') return '';
              return `${profileBarrier}`;
            }
            if (profileBarrier === 'healthy') return 'healthy barrier';
            if (profileBarrier === 'impaired') return 'impaired barrier';
            return `barrier=${profileBarrier}`;
          })();

          if (skinTypeLabel) tags.push(skinTypeLabel);
          if (sensitivityLabel) tags.push(sensitivityLabel);
          if (barrierLabel) tags.push(barrierLabel);
          return tags;
        })();

        const lowerKeyActives = uniqStrings(take(keyActives, 12).map((x) => String(x || '').trim()).filter(Boolean))
          .join(' | ')
          .toLowerCase();
        const hasNiacinamide = /\bniacinamide\b|/.test(lowerKeyActives);
        const hasZincPca = /\bzinc\b.*\bpca\b|\s*pca/.test(lowerKeyActives);
        const isAcidLike =
          riskFlags.some((f) => /\bacid\b/i.test(f)) ||
          /\baha\b|\bbha\b|\bpha\b|\bglycolic\b|\blactic\b|\bsalicylic\b|||||/.test(lowerKeyActives);

        const isHighIrritation =
          riskFlags.some((f) => /high_irritation/i.test(f)) ||
          /\bhigh irritation\b||can sting|may sting/.test(String(sensitivityNotes || '').toLowerCase());

        const profileSuggestsCaution =
          profileBarrier === 'impaired' ||
          profileSensitivity === 'high' ||
          (profileSensitivity === 'medium' && (isAcidLike || isHighIrritation));

        const reasons = uniqStrings([
          ...take(comparisonNotes, 1).map((s) => truncate(s, 200)),
          ...(profileTags.length
            ? [
              outLang === 'CN'
                ? `${truncate(profileTags.join(' / '), 80)}`
                : `Based on your profile: ${truncate(profileTags.join(' / '), 80)}.`,
            ]
            : []),
          ...(profileSkinType === 'oily' && (hasNiacinamide || hasZincPca)
            ? [
              outLang === 'CN'
                ? '/'
                : 'Oily-skin friendly: niacinamide/zinc are commonly used for oil control and the look of pores/marks.',
            ]
            : []),
          ...(profileGoals.includes('brightening') && hasNiacinamide
            ? [
              outLang === 'CN' ? '/' : 'Your goal includes brightening: niacinamide is commonly used for uneven tone/marks.',
            ]
            : []),
          ...(profileGoals.includes('acne') && (hasNiacinamide || hasZincPca)
            ? [
              outLang === 'CN' ? '/' : 'Your goal includes acne-prone concerns: these actives are often used for oil/acne-prone routines.',
            ]
            : []),
          ...take(keyActives, 3).map((s) => (outLang === 'CN' ? `${truncate(s, 180)}` : `Key active: ${truncate(s, 180)}`)),
          ...(profileSuggestsCaution
            ? [
              outLang === 'CN'
                ? ' 23 /'
                : 'How to use: start low (23/week or less); if stinging/redness happens, pause and focus on barrier support.',
            ]
            : []),
          ...(isHighIrritation
            ? [
              outLang === 'CN'
                ? '/'
                : 'Risk: higher irritation/pilling potential; use a small amount, let it absorb, and avoid heavy layering.',
            ]
            : []),
          ...(isAcidLike
            ? [
              outLang === 'CN'
                ? '/A/'
                : 'Layering note: avoid stacking strong acids/retinoids in the same night to reduce irritation.',
            ]
            : []),
        ]).filter(Boolean).slice(0, 5);

        const assessment = {
          verdict,
          reasons,
          ...(productId || brand || name || displayName
            ? {
              anchor_product: {
                ...(productId ? { product_id: productId, sku_id: productId } : {}),
                ...(brand ? { brand } : {}),
                ...(name ? { name } : {}),
                ...(displayName ? { display_name: displayName } : {}),
                availability: Array.isArray(a.availability) ? a.availability : [],
              },
            }
            : {}),
        };

        const platformScores = {};
        if (redScore != null) platformScores.RED = redScore;
        if (redditScore != null) platformScores.Reddit = redditScore;
        if (burnRate != null) platformScores.burn_rate = burnRate;

        const evidence = {
          science: {
            key_ingredients: uniqStrings(take(keyActives, 8).map((s) => truncate(s, 120)), 8),
            mechanisms: [],
            fit_notes: uniqStrings([...take(textureFinish, 2), ...take(pairingRules, 1)].map((s) => truncate(s, 200)), 3),
            risk_notes: uniqStrings(
              [
                ...riskFlags.map((s) => truncate(s, 120)),
                ...(sensitivityNotes ? [truncate(sensitivityNotes, 200)] : []),
              ].filter(Boolean),
              4,
            ),
          },
          social_signals: {
            ...(Object.keys(platformScores).length ? { platform_scores: platformScores } : {}),
            typical_positive: uniqStrings(take(topKeywords, 6).map((s) => truncate(s, 60)), 6),
            typical_negative: [],
            risk_for_groups: [],
          },
          expert_notes: uniqStrings([chemistNotes, sensitivityNotes].map((s) => truncate(s, 200)).filter(Boolean), 2),
          confidence: scoreScience != null ? Math.max(0, Math.min(1, scoreScience / 100)) : null,
          missing_info: [],
        };

        const confidence = scoreTotal != null ? Math.max(0, Math.min(1, scoreTotal / 100)) : null;
        const missing_info = [];

        // Preserve score breakdown as lightweight expert note (no internal kb ids).
        const scoreLineParts = [
          scoreTotal != null ? `Total ${Math.round(scoreTotal)}/100` : null,
          scoreScience != null ? `Science ${Math.round(scoreScience)}` : null,
          scoreSocial != null ? `Social ${Math.round(scoreSocial)}` : null,
          scoreEng != null ? `Eng ${Math.round(scoreEng)}` : null,
        ].filter(Boolean);
        if (scoreLineParts.length) {
          evidence.expert_notes = uniqStrings([
            ...(Array.isArray(evidence.expert_notes) ? evidence.expert_notes : []),
            truncate(scoreLineParts.join(', '), 200),
          ], 3);
        }

        return { assessment, evidence, confidence, missing_info };
      };

      if (
        looksLikeSuitabilityRequest(responseIntentMessage) &&
        anchorFromContext &&
        !derivedCards.some((c) => String(c?.type || '').toLowerCase() === 'product_analysis') &&
        !cards.some((c) => String(c?.type || '').toLowerCase() === 'product_analysis')
      ) {
        const mapped = mapAnchorContextToProductAnalysis(anchorFromContext, { lang: ctx.lang, profileSummary });
        const norm = normalizeProductAnalysis(mapped);
        const payload = finalizeProductAnalysisRecoContract(
          enrichProductAnalysisPayload(norm.payload, { lang: ctx.lang }),
          { logger, requestId: ctx.request_id, mode: 'main_path' },
        );
        derivedCards.push({
          card_id: `analyze_${ctx.request_id}`,
          type: 'product_analysis',
          payload: debugUpstream ? payload : stripInternalRefsDeep(payload),
          ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
        });
      }

      // Fit-check fallback: if user asks suitability but upstream did not provide a renderable
      // `product_analysis` card, run a dedicated deep-scan to guarantee actionable output.
      const wantsSuitabilityFallback =
        looksLikeSuitabilityRequest(responseIntentMessage);

      const hasProductAnalysisCard = (arr) =>
        Array.isArray(arr) &&
        arr.some((c) => {
          const t = String(c && c.type ? c.type : '').trim().toLowerCase();
          return t === 'product_analysis';
        });

      if (
        wantsSuitabilityFallback &&
        !hasProductAnalysisCard(cards) &&
        !hasProductAnalysisCard(derivedCards)
      ) {
        const productInput =
          anchorProductUrl ||
          extractProductInputFromFitCheckText(responseIntentMessage) ||
          '';

        if (productInput) {
          const commonMeta = {
            profile: profileSummary,
            recentLogs,
            lang: ctx.lang,
            state: ctx.state || 'idle',
            trigger_source: ctx.trigger_source,
          };
          const productParsePrefix = buildContextPrefix({
            ...commonMeta,
            intent: 'product_parse',
            action_id: 'chat.fit_check.parse',
          });
          const productAnalyzePrefix = buildContextPrefix({
            ...commonMeta,
            intent: 'product_analyze',
            action_id: 'chat.fit_check.deep_scan',
          });

          let parsedProduct = null;
          let anchorId = anchorProductId || '';

          // Best-effort parse to anchor_product_id to improve KB hit rate.
          if (!anchorId) {
            try {
              const parseQuery =
                `${productParsePrefix}Task: Parse the user's product input into a normalized product entity.\n` +
                `Return ONLY a JSON object with keys: product, confidence, missing_info (string[]).\n` +
                `Input: ${productInput}`;
              const parseUpstream = await auroraChat({
                baseUrl: AURORA_DECISION_BASE_URL,
                query: parseQuery,
                timeoutMs: 12000,
                ...(anchorProductUrl ? { anchor_product_url: anchorProductUrl } : {}),
              });
              const parseStructured =
                parseUpstream && parseUpstream.structured && typeof parseUpstream.structured === 'object' && !Array.isArray(parseUpstream.structured)
                  ? parseUpstream.structured
                  : parseUpstream && typeof parseUpstream.answer === 'string'
                    ? extractJsonObjectByKeys(parseUpstream.answer, ['product', 'parse', 'anchor_product', 'anchorProduct'])
                    : null;
              const parseMapped =
                parseStructured && typeof parseStructured === 'object' && !Array.isArray(parseStructured)
                  ? mapAuroraProductParse(parseStructured)
                  : parseStructured;
              const parseNorm = normalizeProductParse(parseMapped);
              parsedProduct = parseNorm.payload.product || null;
              anchorId =
                parsedProduct && (parsedProduct.sku_id || parsedProduct.product_id)
                  ? String(parsedProduct.sku_id || parsedProduct.product_id)
                  : '';
            } catch (err) {
              // ignore; continue without anchor id
            }
          }

          const deepScanQuery =
            `${productAnalyzePrefix}Task: Deep-scan this product for suitability vs the user's profile.\n` +
            `Return ONLY a JSON object with keys: assessment, evidence, confidence (0..1), missing_info (string[]).\n` +
            `Evidence must include science/social_signals/expert_notes.\n` +
            `Product: ${productInput}`;

          const runDeepScan = async ({ queryText, timeoutMs }) => {
            try {
              return await auroraChat({
                baseUrl: AURORA_DECISION_BASE_URL,
                query: queryText,
                timeoutMs,
                ...(anchorId ? { anchor_product_id: String(anchorId) } : {}),
                ...(anchorProductUrl ? { anchor_product_url: anchorProductUrl } : {}),
              });
            } catch {
              return null;
            }
          };

          let deepUpstream = await runDeepScan({ queryText: deepScanQuery, timeoutMs: 16000 });

          const deepStructured =
            deepUpstream && deepUpstream.structured && typeof deepUpstream.structured === 'object' && !Array.isArray(deepUpstream.structured)
              ? deepUpstream.structured
              : null;
          const deepAnswerObj =
            deepUpstream && typeof deepUpstream.answer === 'string'
              ? extractJsonObjectByKeys(deepUpstream.answer, [
                'assessment',
                'evidence',
                'confidence',
                'missing_info',
                'missingInfo',
                'analyze',
                'verdict',
                'reasons',
                'science_evidence',
                'social_signals',
                'expert_notes',
              ])
              : null;
          const deepAnswerLooksLikeAnalysis =
            deepAnswerObj &&
            typeof deepAnswerObj === 'object' &&
            !Array.isArray(deepAnswerObj) &&
            (deepAnswerObj.assessment != null ||
              deepAnswerObj.evidence != null ||
              deepAnswerObj.analyze != null ||
              deepAnswerObj.analysis != null ||
              deepAnswerObj.product_analysis != null ||
              deepAnswerObj.productAnalysis != null ||
              deepAnswerObj.confidence != null ||
              deepAnswerObj.missing_info != null ||
              deepAnswerObj.missingInfo != null ||
              deepAnswerObj.verdict != null ||
              deepAnswerObj.reasons != null ||
              deepAnswerObj.science_evidence != null ||
              deepAnswerObj.scienceEvidence != null ||
              deepAnswerObj.social_signals != null ||
              deepAnswerObj.socialSignals != null ||
              deepAnswerObj.expert_notes != null ||
              deepAnswerObj.expertNotes != null);

          const structuredOrJson =
            deepStructured && deepStructured.analyze && typeof deepStructured.analyze === 'object'
              ? deepStructured
              : deepAnswerLooksLikeAnalysis
                ? deepAnswerObj
                : deepStructured || deepAnswerObj;
          const mapped =
            structuredOrJson && typeof structuredOrJson === 'object' && !Array.isArray(structuredOrJson)
              ? mapAuroraProductAnalysis(structuredOrJson)
              : structuredOrJson;
          let norm = normalizeProductAnalysis(mapped);

          // Retry once with minimal prefix if personalized context is dropped upstream.
          if (!norm.payload.assessment && productInput) {
            const minimalPrefix = buildContextPrefix({
              lang: ctx.lang,
              state: ctx.state || 'idle',
              trigger_source: ctx.trigger_source,
              intent: 'product_analyze_fallback',
              action_id: 'chat.fit_check.deep_scan_fallback',
            });
            const minimalQuery =
              `${minimalPrefix}Task: Deep-scan this product for suitability vs the user's profile.\n` +
              `Return ONLY a JSON object with keys: assessment, evidence, confidence (0..1), missing_info (string[]).\n` +
              `Evidence must include science/social_signals/expert_notes.\n` +
              `Product: ${productInput}`;
            const deepUpstream2 = await runDeepScan({ queryText: minimalQuery, timeoutMs: 14000 });
            const deepStructured2 =
              deepUpstream2 && deepUpstream2.structured && typeof deepUpstream2.structured === 'object' && !Array.isArray(deepUpstream2.structured)
                ? deepUpstream2.structured
                : null;
            const deepAnswer2 =
              deepUpstream2 && typeof deepUpstream2.answer === 'string'
                ? extractJsonObjectByKeys(deepUpstream2.answer, [
                  'assessment',
                  'evidence',
                  'confidence',
                  'missing_info',
                  'missingInfo',
                  'analyze',
                  'verdict',
                  'reasons',
                  'science_evidence',
                  'social_signals',
                  'expert_notes',
                ])
                : null;
            const structuredOrJson2 =
              deepStructured2 && deepStructured2.analyze && typeof deepStructured2.analyze === 'object'
                ? deepStructured2
                : deepAnswer2 && typeof deepAnswer2 === 'object' && !Array.isArray(deepAnswer2)
                  ? deepAnswer2
                  : deepStructured2 || deepAnswer2;
            const mapped2 =
              structuredOrJson2 && typeof structuredOrJson2 === 'object' && !Array.isArray(structuredOrJson2)
                ? mapAuroraProductAnalysis(structuredOrJson2)
                : structuredOrJson2;
            const norm2 = normalizeProductAnalysis(mapped2);
            if (norm2 && norm2.payload && norm2.payload.assessment) {
              const internalCodes = getProductAnalysisInternalMissingCodes(norm2.payload);
              norm = {
                payload: applyProductAnalysisGapContract({
                  ...norm2.payload,
                  internal_debug_codes: Array.from(new Set([...internalCodes, 'profile_context_dropped_for_reliability'])),
                }),
                field_missing: norm2.field_missing,
              };
            }
          }

          const productUrlForFallback =
            anchorProductUrl ||
            (/^https?:\/\//i.test(String(productInput || '').trim()) ? String(productInput || '').trim() : '');
          const needsUrlIngredientAnalysis = (() => {
            const assessment = norm && norm.payload && typeof norm.payload === 'object' ? norm.payload.assessment : null;
            if (!assessment || typeof assessment !== 'object') return true;
            const verdict = String(assessment.verdict || '').trim().toLowerCase();
            return !verdict || verdict === 'unknown' || verdict === '';
          })();
          if (PRODUCT_URL_INGREDIENT_ANALYSIS_ENABLED && needsUrlIngredientAnalysis && productUrlForFallback) {
            const urlNorm = await buildProductAnalysisFromUrlIngredients({
              productUrl: productUrlForFallback,
              lang: ctx.lang,
              profileSummary,
              parsedProduct,
              logger,
            });
            if (urlNorm && urlNorm.payload && urlNorm.payload.assessment) {
              const mergedMissingInfo = Array.from(
                new Set([
                  ...(Array.isArray(norm?.payload?.missing_info) ? norm.payload.missing_info : []),
                  ...(Array.isArray(urlNorm.payload.missing_info) ? urlNorm.payload.missing_info : []),
                ]),
              );
              const mergedInternalCodes = Array.from(
                new Set([
                  ...getProductAnalysisInternalMissingCodes(norm?.payload),
                  ...getProductAnalysisInternalMissingCodes(urlNorm.payload),
                ]),
              );
              norm = {
                payload: applyProductAnalysisGapContract({
                  ...urlNorm.payload,
                  missing_info: mergedMissingInfo,
                  internal_debug_codes: mergedInternalCodes,
                }),
                field_missing: mergeFieldMissing(urlNorm.field_missing, norm.field_missing),
              };
            }
          }

          let payload = enrichProductAnalysisPayload(norm.payload, { lang: ctx.lang, profileSummary });
          if (parsedProduct && payload && typeof payload === 'object') {
            const a = payload.assessment && typeof payload.assessment === 'object' ? payload.assessment : null;
            if (a && !a.anchor_product && !a.anchorProduct) {
              payload = { ...payload, assessment: { ...a, anchor_product: parsedProduct } };
            }
          }
          payload = finalizeProductAnalysisRecoContract(payload, {
            logger,
            requestId: ctx.request_id,
            mode: 'main_path',
          });

          if (payload) {
            derivedCards.push({
              card_id: `analyze_${ctx.request_id}`,
              type: 'product_analysis',
              payload: debugUpstream ? payload : stripInternalRefsDeep(payload),
              ...(norm.field_missing?.length ? { field_missing: norm.field_missing.slice(0, 8) } : {}),
            });
          }
        }
      }

      const contextCard = INCLUDE_RAW_AURORA_CONTEXT && contextRaw
        ? [{
          card_id: `aurora_ctx_${ctx.request_id}`,
          type: 'aurora_context_raw',
          payload: {
            intent: upstream && typeof upstream.intent === 'string' ? upstream.intent : null,
            clarification,
            context: contextRaw,
          },
        }]
        : [];

      const structured = getUpstreamStructuredOrJson(upstream);
      const structuredBlocked = Boolean(structured) && !allowRecs && structuredContainsCommerceLikeFields(structured);
      if (structuredBlocked) {
        fieldMissing.push({ field: 'aurora_structured', reason: 'recommendations_not_requested' });
      }
      const structuredWithExternalVerification = mergeExternalVerificationIntoStructured(structured, contextRaw);
      const structuredForEnvelope =
        structuredWithExternalVerification && !debugUpstream
          ? stripInternalRefsDeep(structuredWithExternalVerification)
          : structuredWithExternalVerification;

      const structuredCitations = Array.isArray(structuredForEnvelope?.external_verification?.citations)
        ? structuredForEnvelope.external_verification.citations
        : [];
      // UI treats aurora_structured primarily as a "references" card; if citations are empty it is hidden.
      const structuredIsRenderable = Boolean(structuredForEnvelope && !structuredBlocked && structuredCitations.length > 0);
      const uiDebug = Boolean(debugUpstream);
      const hasRenderableCards =
        structuredIsRenderable ||
        derivedCards.some((c) => isRenderableCardForChatboxUi(c, { debug: uiDebug })) ||
        cards.some((c) => isRenderableCardForChatboxUi(c, { debug: uiDebug }));

      let safeAnswer = sanitizeUpstreamAnswer(answer, {
        language: ctx.lang,
        hasRenderableCards,
        // Always keep assistant_message end-user readable; internal kb:* refs belong in debug payloads only.
        stripInternalRefs: true,
      });

      const routeCards = [...(Array.isArray(derivedCards) ? derivedCards : []), ...(Array.isArray(cards) ? cards : [])];
      const routeHintFromCards = inferRouteFromCards(routeCards);
      const routeHintFromMessage =
        !routeHintFromCards
          ? inferRouteFromMessageIntent(responseIntentMessage, { allowRecoCards: allowRecs })
          : null;
      const routeHint = resolveRouteHint(routeHintFromCards, routeHintFromMessage);
      if (routeHint && routeHint.route) {
        const routeStructured = buildRouteAwareAssistantText({
          route: routeHint.route,
          payload: routeHint.payload,
          language: ctx.lang,
          profile,
        });
        const shouldUpgrade =
          looksLikeGenericStructuredNotice(safeAnswer) ||
          !isRouteStructuredAnswer(safeAnswer, routeHint.route);
        if (shouldUpgrade && routeStructured) safeAnswer = routeStructured;
      }
      safeAnswer = addEmotionalPreambleToAssistantText(safeAnswer, {
        language: ctx.lang,
        profile,
        seed: ctx.request_id,
      });

      const cardsForEnvelopeRaw = !debugUpstream ? stripInternalRefsDeep(cards) : cards;
      const cardsForEnvelope = Array.isArray(cardsForEnvelopeRaw)
        ? cardsForEnvelopeRaw.map((card) => {
          if (!card || typeof card !== 'object' || Array.isArray(card)) return card;
          const type = String(card.type || '').trim().toLowerCase();
          if (type !== 'product_analysis') return card;
          const payload = finalizeProductAnalysisRecoContract(card.payload, {
            logger,
            requestId: ctx.request_id,
            mode: 'main_path',
          });
          return { ...card, payload };
        })
        : cardsForEnvelopeRaw;
      const shouldEchoProfile =
        Boolean(profileSummary) &&
        (Boolean(appliedProfilePatch) || !profilePatchFromSession);
      const sessionPatch = {};
      if (nextStateOverride && stateChangeAllowed(ctx.trigger_source)) {
        sessionPatch.next_state = nextStateOverride;
      }
      if (shouldEchoProfile) {
        sessionPatch.profile = profileSummary;
        recordSessionPatchProfileEmitted({ changed: Boolean(appliedProfilePatch) });
      }
      if (pendingClarificationPatchOverride !== undefined) {
        emitPendingClarificationPatch(sessionPatch, pendingClarificationPatchOverride);
      } else if (pendingClarificationFromUpstream) {
        emitPendingClarificationPatch(sessionPatch, pendingClarificationFromUpstream);
      }
      if (hasLlmRouteMeta) {
        sessionPatch.llm = llmRouteMeta;
      }

      const assembledCards = [
        ...(structuredForEnvelope && !structuredBlocked
          ? [{
            card_id: `structured_${ctx.request_id}`,
            type: 'aurora_structured',
            payload: structuredForEnvelope,
          }]
          : []),
        ...derivedCards,
        ...cardsForEnvelope.map((c, idx) => ({
          card_id: c.card_id || `aurora_${ctx.request_id}_${idx}`,
          type: c.type || 'aurora_card',
          title: c.title,
          payload: c.payload || c,
          ...(Array.isArray(c.field_missing) ? { field_missing: c.field_missing } : {}),
        })),
        ...contextCard,
        ...(fieldMissing.length
          ? [{ card_id: `gate_${ctx.request_id}`, type: 'gate_notice', payload: {}, field_missing: fieldMissing }]
          : []),
      ];

      const pendingForTemplate =
        pendingClarificationPatchOverride !== undefined
          ? pendingClarificationPatchOverride
          : pendingClarificationFromUpstream || null;
      const pendingCurrentNormId =
        pendingForTemplate &&
        typeof pendingForTemplate === 'object' &&
        pendingForTemplate.current &&
        typeof pendingForTemplate.current === 'object'
          ? String(
            pendingForTemplate.current.norm_id ||
            pendingForTemplate.current.normId ||
            pendingForTemplate.current.id ||
            '',
          ).trim()
          : '';

      const templateDecision = selectTemplate({
        language: ctx.lang,
        intent: routeHint && routeHint.route === 'env' ? 'weather_env' : null,
        cards: assembledCards,
        session_patch: sessionPatch,
        pending_clarification: pendingForTemplate,
      });
      const templateRendered = renderAssistantMessage(templateDecision, {
        language: ctx.lang,
        assistant_message: { role: 'assistant', content: safeAnswer, format: 'markdown' },
        cards: assembledCards,
        session_patch: sessionPatch,
        pending_clarification: pendingForTemplate,
      });
      if (templateRendered && templateRendered.applied) {
        recordTemplateApplied({
          templateId: templateDecision && templateDecision.id,
          moduleName: templateDecision && templateDecision.module,
          variant: templateDecision && templateDecision.variant,
          source: 'chat',
        });
      } else {
        recordTemplateFallback({
          reason: templateRendered && templateRendered.reason ? templateRendered.reason : 'keep_existing',
          moduleName: templateDecision && templateDecision.module,
        });
      }

      const adaptedChips = adaptChips({
        existingChips: suggestedChips,
        maxChips: 10,
        currentNormId: pendingCurrentNormId || null,
      });
      const finalAssistantText =
        templateRendered && typeof templateRendered.content === 'string' && templateRendered.content.trim()
          ? templateRendered.content
          : safeAnswer;
      const finalAssistantFormat =
        templateRendered && templateRendered.format === 'text'
          ? 'text'
          : 'markdown';

      const envelope = buildEnvelope(ctx, {
        assistant_message: makeChatAssistantMessage(finalAssistantText, finalAssistantFormat),
        suggested_chips: adaptedChips.chips,
        cards: assembledCards,
        session_patch: sessionPatch,
        events: [
          makeEvent(ctx, 'value_moment', { kind: 'chat_reply' }),
          ...(hasLlmRouteMeta ? [makeEvent(ctx, 'llm_route', llmRouteMeta)] : []),
          ...(allowRecs ? [makeEvent(ctx, 'recos_requested', { explicit: true })] : []),
          ...(heatmapImpressionEvent ? [heatmapImpressionEvent] : []),
        ],
      });
      return sendChatEnvelope(envelope);
    } catch (err) {
      const status = err.status || 500;
      logger?.error({ err: err.message, status }, 'aurora bff chat failed');
      const envelope = buildEnvelope(ctx, {
        assistant_message: makeAssistantMessage('Failed to process chat.'),
        suggested_chips: [],
        cards: [{ card_id: `err_${ctx.request_id}`, type: 'error', payload: { error: err.code || 'CHAT_FAILED' } }],
        session_patch: {},
        events: [makeEvent(ctx, 'error', { code: err.code || 'CHAT_FAILED' })],
      });
      return sendChatEnvelope(envelope, status);
    }
  });
}

const __internal = {
  normalizeClarificationField,
  detectBrandAvailabilityIntent,
  detectCatalogAvailabilityIntent,
  buildAvailabilityCatalogQuery,
  isSpecificAvailabilityQuery,
  resolveAvailabilityProductByQuery,
  resolveAvailabilityProductByLocalResolver,
  searchPivotaBackendProducts,
  getRecoCatalogSearchSourceHealthSnapshot,
  normalizeRecoCatalogProduct,
  scoreRealtimeCompetitorCandidate,
  routeCandidates,
  recoBlocks,
  augmentProductAnalysisPayloadForDogfood,
  augmentEnvelopeProductAnalysisCardsForDogfood,
  getRecoDogfoodSessionId,
  getRecoTrackingMetadata,
  registerRecoTrackingSnapshot,
  createAsyncTicket,
  applyAsyncBlockPatch,
  getAsyncUpdates,
  hasRecoPrelabelAdminAccess,
  attachPrelabelSuggestionsToPayload,
  sanitizeProductAnalysisPayloadForPrelabel,
  buildPrelabelKbKey,
  parseBoolQueryValue,
  parseIntQueryValue,
  mapSuggestionForResponse,
  generatePrelabelsForAnchor,
  loadSuggestionsForAnchor,
  buildLabelQueue,
  runRecoBlocksForUrl,
  resolveProductAnalysisSocialState,
  applyProductAnalysisSocialProvenance,
  applyRecoGuardrailToProductAnalysisPayload,
  getRecoGuardrailCircuitSnapshot,
  buildProductCatalogQueryCandidates,
  buildRealtimeCompetitorQueryPlan,
  mapCatalogProductToAnchorProduct,
  resolveCatalogProductForProductInput,
  extractProductPriceFromHtml,
  normalizePriceObject,
  runOpenAIVisionSkinAnalysis,
  runGeminiVisionSkinAnalysis,
  runVisionSkinAnalysis,
  shouldAttemptOpenAiFallbackFromGemini,
  resolveVisionProviderSelection,
  fetchPhotoBytesFromPivotaBackend,
  classifySignedUrlFetchFailure,
  isSignedUrlExpiredSignal,
  setPhotoBytesCache,
  getPhotoBytesCache,
  buildLowConfidenceBaselineSkinAnalysis,
  buildRuleBasedSkinAnalysis,
  normalizeSkinAnalysisFromLLM,
  mergePhotoFindingsIntoAnalysis,
  buildExecutablePlanForAnalysis,
  maybeBuildPhotoModulesCardForAnalysis,
  buildEmotionalPreamble,
  addEmotionalPreambleToAssistantText,
  stripMismatchedLeadingGreeting,
  looksLikeGreetingAlready,
  looksLikeProductEvaluationIntentV2,
  isMeaningfulFitCheckProductInput,
  hasMeaningfulFitCheckAnchor,
  buildFitCheckAnchorPrompt,
  isRecoKnownTestSeedItem,
  limitRecoKnownTestSeedRecommendations,
  buildRecoDiversityToken,
  applyRecoRecentDiversityGuard,
  getRecoRecentExposureTokens,
  updateRecoRecentExposureTokens,
  enrichRecoItemWithPdpOpenContract,
  enrichRecommendationsWithPdpOpenContract,
  getPdpPrefetchStateSnapshot,
  runPdpHotsetPrewarmBatch,
  resolveRecoPdpByStableIds,
  maybeInferSkinMaskForPhotoModules,
  __setResolveProductRefForTest(fn) {
    resolveProductRefDirectImpl = typeof fn === 'function' ? fn : null;
  },
  __resetResolveProductRefForTest() {
    resolveProductRefDirectImpl = resolveProductRefDirect;
  },
  __setVisionRunnersForTest(runners = {}) {
    const geminiFn = runners && typeof runners.gemini === 'function' ? runners.gemini : null;
    const openAiFn = runners && typeof runners.openai === 'function' ? runners.openai : null;
    runGeminiVisionSkinAnalysisImpl = geminiFn || runGeminiVisionSkinAnalysis;
    runOpenAIVisionSkinAnalysisImpl = openAiFn || runOpenAIVisionSkinAnalysis;
  },
  __resetVisionRunnersForTest() {
    runGeminiVisionSkinAnalysisImpl = runGeminiVisionSkinAnalysis;
    runOpenAIVisionSkinAnalysisImpl = runOpenAIVisionSkinAnalysis;
  },
  __setInferSkinMaskOnFaceCropForTest(fn) {
    inferSkinMaskOnFaceCropImpl = typeof fn === 'function' ? fn : inferSkinMaskOnFaceCrop;
  },
  __resetInferSkinMaskOnFaceCropForTest() {
    inferSkinMaskOnFaceCropImpl = inferSkinMaskOnFaceCrop;
  },
};

module.exports = { mountAuroraBffRoutes, __internal };
